{"meta":{"title":"MELOMANCE","subtitle":"Blog Powered by Hexo","description":"Blog Powered by Hexo","author":"MELOMANCE","url":"http://melomance.github.io"},"pages":[],"posts":[{"title":"Hexo 글쓰기","slug":"[HX] hexo writing","date":"2018-04-22T15:00:00.000Z","updated":"2018-06-17T12:54:47.947Z","comments":true,"path":"2018/04/23/[HX] hexo writing/","link":"","permalink":"http://melomance.github.io/2018/04/23/[HX] hexo writing/","excerpt":"","text":"새 포스트나 페이지를 생성하기 위해 아래 명령어를 입력하세요.$ hexo new [layout] &lt;title&gt; post 는 기본 layout입니다. 하지만 _config.yml 파일의 default_layout 설정을 변경하여 당신이 만든 것으로 변경할 수 있습니다. 레이아웃Hexo에는 세 개의 기본 레이아웃이 존재합니다. post, page, draft 입니다. 이 각각의 레이아웃에 의해 생성된 파일들은 서로 다른 경로에 저장됩니다. 새롭게 생성된 포스트는 source/_posts 폴더에 저장됩니다. 레이아웃 경로 post source/_posts page source draft source/_drafts Don’t process my posts!당신의 post가 처리되는 것을 원치 않는다면 front-matter에 layout: false를 선언하면 됩니다. 파일명기본적으로, Hexo는 post의 제목을 파일명과 동일하게 사용합니다. _config.yml 파일의 new_post_name 설정을 변경하여 기본 파일명을 바꿀 수 있습니다. 예를 들어, :year-:month-:day-:title.md는 포스트가 생성된 날짜를 파일명의 접두사로 사용하게 합니다. 당신은 아래와 같은 placeholder를 사용할 수 있습니다. Placeholder 설명 :title Post 제목 (소문자, 공백은 ‘-‘하이픈으로 변경됩니다.) :year 연도를 생성합니다. e.g. 2015 :month 월을 생성합니다. (0이 붙습니다.), e.g. 04 :i_month 월을 생성합니다. (0이 붙지 않습니다.), e.g. 4 :day 일을 생성합니다. (0이 붙습니다.), e.g. 07 :i_day 일을 생성합니다. (0이 붙지 않습니다.), e.g. 7 Draft이전에, 우리는 Hexo의 특별한 레이아웃에 대해 언급한 적이 있습니다. 바로 draft입니다. Post는 이 레이아웃으로 초기화되며 source/_drafts폴더에 저장됩니다. 당신은 publish 명령어를 통해 draft를 source/_posts폴더로 옮길 수 있습니다. publish는 new 명령어와 비슷하게 동작합니다.$ hexo publish [layout] &lt;title&gt; 기본적으로 Draft는 표시되지 않습니다. Hexo 실행 시 –draft 옵션을 추가하거나 _config.yml파일에서 render_drafts를 활성화 하면 draft를 렌더링할 수 있습니다. Scaffold포스트 생성 시 Hexo는 scaffolds 폴더 내의 적당한 파일을 기반으로 구성합니다.$ hexo new photo \"My Gallery\" 이 명령어가 수행되면 Hexo는 scaffolds 폴더 내에서 photo.md를 찾기 시작하고 이를 기반으로 한 포스트를 구성합니다. Scaffolds 내에서는 아래의 placeholder를 사용할 수 있습니다. Placeholder 설명 layout 레이아웃 title 제목 date 파일 생성일 ※ 출처: https://hexo.io/ko/docs/writing.html","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://melomance.github.io/tags/hexo/"}]},{"title":"Hexo 명령어","slug":"[HX] hexo command","date":"2018-04-21T15:00:00.000Z","updated":"2018-06-11T14:34:59.412Z","comments":true,"path":"2018/04/22/[HX] hexo command/","link":"","permalink":"http://melomance.github.io/2018/04/22/[HX] hexo command/","excerpt":"","text":"init$ hexo init [folder] 웹 사이트를 초기화합니다. folder가 준비되어 있지 않다면 Hexo는 현재 디렉토리에 웹 사이트를 세팅합니다. new$ hexo new [layout] &lt;title&gt; 새 글(article)을 생성합니다. layout이 준비되어 있지 않다면, Hexo는 _config.yml에 정의된 default_layout을 사용합니다. 만약 title에 공백이 포함된다면 따옴표로 감싸주세요. generate$ hexo generate 정적 파일들을 생성합니다. 옵션 설명 -d, –deploy 생성이 종료된 후 deploy 합니다. -w, –watch 파일의 변경사항을 감시(watch)합니다. publish$ hexo publish [layout] &lt;filename&gt; 작성한 내용을 배포합니다. server$ hexo server 로컬 서버를 구동시킵니다. 기본적으로 http://localhost:4000/ 를 사용합니다. 옵션 설명 -p, –port 기본 포트를 덮어씁니다. -s, –static 정적인 파일만 구동합니다. -l, –log Logger를 활성화 시킵니다. Logger 형식을 덮어씁니다. deploy$ hexo deploy 웹 사이트를 deploy 합니다. 옵션 설명 -g, –generate Deploy 하기 전에 generate를 수행합니다. render$ hexo render &lt;file1&gt; [file2] ... 파일을 렌더링합니다. 옵션 설명 -o, –output Output destination migrate$ hexo migrate &lt;type&gt; 다른 블로그 시스템의 내용을 Hexo로 마이그레이션 합니다. clean$ hexo clean 캐시 파일 (db.json) 및 생성된 파일들 (public) 을 삭제합니다. list$ hexo list &lt;type&gt; 경로(route) 목록을 보여줍니다. version$ hexo version 버전 정보를 보여줍니다. 옵션안전 모드$ hexo --safe 플러그인과 스크립트를 불러오지 않습니다. 새로운 플러그인을 설치한 후 문제가 생기면 이 모드를 사용해 보시기 바랍니다. 디버그 모드$ hexo --debug 터미널에 verbose 로그 메시지를 출력하고 debug.log 파일에 저장합니다. Hexo에 문제 발생 시 사용해 보시기 바랍니다. 에러 발견 시 raise a GitHub issue에 등록해 주세요. Silent 모드$ hexo --silent 터미널에 내용을 출력하지 않습니다. 설정 파일의 변경(customizing)$ hexo --config custom.yml _config.yml 대신 커스터미이징한 설정 파일을 사용할 수 있습니다. Draft 포스트 표시$ hexo --draft Draft 포스트를 보여줍니다(source/_drafts 폴더에 저장되어 있습니다). 현재 작업 디렉토리의 변경(customizing)$ hexo --cwd /path/to/cwd 현재 작업 디렉토리의 경로를 변경할 수 있습니다. ※ 출처: https://hexo.io/ko/docs/commands.html","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://melomance.github.io/tags/hexo/"}]},{"title":"수출입관련 국내법규","slug":"[FX] 수출입국내법규","date":"2017-12-28T13:27:00.000Z","updated":"2018-06-27T12:52:18.467Z","comments":true,"path":"2017/12/28/[FX] 수출입국내법규/","link":"","permalink":"http://melomance.github.io/2017/12/28/[FX] 수출입국내법규/","excerpt":"","text":"수출입관련 국내법규수출입거래라는 원인행위 [대외무역법]과 [관세법]의 적용을 받는다. 대외무역법: 대외무역을 진흥하고 공정한 거래질서를 확립하는 것이 목적으로 원칙적이고 포괄적 내용 위주로 규정되어 있다. 관세법: 수출입물품의 통관에 있어 가장 기본이 되는 법이다. 수출입거래와 관련되는 수입대금의 지급이나 수출대금의 영수와 같은 결제 행위 [외국환거래법]과 [기타법령]의 적용을 받는다. 외국환거래법: 외국환거래법-외국환거래법 시행령-외국환거래규정의 법체계로 구성되어 있다. 기타법령: 외국인투자 촉진법, 남북교류협력에 관한 법률 외국환거래규정상 수출입대금 지급등의 절차외국환거래법상 지급등 지급뿐만 아니라 추심과 수령을 포괄하는 개념 건당 미화 2천불 초과하는 지급등 (지급등을 하고자 하는 자) 외국환은행의 장에게 지급등의 사유와 금액을 입증하는 서류를 제출 (은행) 지급의 사유와 금액을 입증하는 서류(수출입계약서, 수출신고필증, 수입신고필증)를 징구 당해 지급등 또는 그 원인이 되는 거래, 행위가 법, 영, 이 규정 및 타법령 등에 의하여 신고등을 하여야 하는 경우에는 지급등을 하기에 앞서 그 신고등을 먼저 하여야 한다. 제3자 지급등국내수입기업이 해외수출기업이 아닌 제3자에게 해외로 결제하는 것을 포함해서, 거주자가 비거주자와의 거래관련 결제를 위해 거래당사자가 아닌 제3자에게 지급등을 하는 경우 외국환은행의 장 신고사항에 해당하는 경우 신고면제사항에 해당하는 경우 위의 두 경우를 제외하고, 원칙적으로는 한국은행총재에게 신고해야 한다. 비거주자로부터 수령하는 경우 신고면제 거주자가 미화 2천불 초과, 미화 1만불 이내의 금액을 제3자와 지급등 하려는 경우 외국환은행의 장 신고사항 미화2천불 이하의 금액을 제3자와 지급등을 하는 경우 신고면제 상계상계는 거주자와 비거주자가 수출입, 용역거래, 자본거래 등 대외거래를 함에 있어 채권과 채무를 매 건별로 결제하지 않고, 특정시점에서 채권과 채무를 서로 상쇄하여 그 차액만 결제하는 것이다. 양자 간 상계 외국환은행의 장 신고사항(금액상관 없이) 다자 간 상계 한국은행총재 신고사항(금액상관 없이) 상계를 실시하고자 하는 자는 관계증빙서류를 5년간 보관해야 한다. 상호계산상계는 이미 거래가 발생한 채권/채무 금액에 대해 차액 결제하는 것인 반면 상호계산은 향후 발생할 채권과 채무를 정기적으로 차액 정산하기 위해 결산주기를 정해서 이용하는 것으로 지정거래 외국환은행 신고사항이다. 상호계산의 신고 (상호계산방법으로 지급등을 하고자 하는 자) 상호계산신고서, 등기부등본 또는 사업자등록증 사본, 거래외국환은행 지정(변경)신청서를 지정거래 외국환은행의 장에게 제출 (지정거래외국환은행) 외국환거래관련자료 제출 집계표 및 상호계산신고서 사본을 첨부하여 익월 10일까지 국세청장 및 관세청장에게 통보 상호계산계정을 폐쇄하는 경우 (지정거래외국환은행) 외국환거래관련자료 제출 집계표 및 상호계산계정폐쇄신고서 사본을 첨부하여 익월 10일까지 국세청장 및 관세청장에게 통보 수출입대금 지급등 관련 한국은행총재 신고사항계약건당 미화 5만불 초과하는 수출대금을 다음의 방법으로 수령하는 경우 본지사 간의 수출거래로서 무신용장 인수인도조건방식 또는 외상수출채권매입방식에 의하여 결제기간이 물품의 선적 후 또는 수출환어음의 일람 후 3년을 초과하는 경우 본지사 간의 수출거래로서 수출대금을 물품의 선적 전에 수령하고자 하는 경우 본지사 간이 아닌 수출거래로서 수출대금을 물품의 선적 전 1년을 초과하여 수령하고자 하는 경우(선박, 철도차량, 항공기, 대외무역법에 의한 산업설비의 경우는 제외) 다음의 방법으로 수입대금을 지급하는 경우 계약건당 미화 5만불을 초과하는 미가공 재수출할 목적으로 금을 수입하는 경우로서 수입대금을 선적서류 또는 물품의 수령일로부터 30일을 초과하여 지급하거나 내수용으로 30일을 초과하여 지급하거나 내수용으로 30일을 초과하여 연지급수입한 금을 미가공 재수출하고자 하는 경우 계약건당 미화 2만불을 초과하는 수입대금을 선적서류 또는 물품의 수령 전 1년을 초과하여 송금방식에 의하여 지급하고자 하는 경우 (선박, 철도차량, 항공기, 대외무역법에 따른 산업설비에 대한 미화 2백만불 이내의 수입대금을 지급하는 경우는 제외) 대외채권 회수의무외국환거래법 제7조 및 외국환거래규정 제1-3조 등에 의하여, 거주자는 건당 미회수 잔액이 미화 50만불을 초과하는 대외채권은 예외적인 사유를 제외하고는 채권의 만기일 또는 조건 성취일로부터 3년 이내에 국내로 회수하여야 한다. 채권회수의무가 없는 경우 외국환거래규정에 의해 해외보유가 인정된 채권 외국인거주자가 외국에 있는 비거주자로부터 상속/유증/증여에 의하여 취득한 채권 외국환거래규정에 의하여 인정된 자본거래(해외직접투자등을 포함)로 전환한 경우의 전환 전 채권 회수대상채권 제외절차다음과 같은 사유로 발생한 경우 외국환은행에 채권회수의무 면제에 관한 인정을 신청한다. 거래상대방의 파산, 행방불명 기타 이에 준하는 불가항력으로 인해 채권회수가 불가능한 경우 거래당사자 간의 분쟁으로 중재기관, 법원 또는 보험기관 등이 채권금액 감면을 결정하여 채권회수가 불가능한 경우 거래상대방의 인수거절, 지급거절, 거래당사자 간의 합의에 의한 채권금액 감면으로 채권회수가 불가능한 경우 상기방법으로 외국환은행으로부터 채권회수의무 면제에 관한 인정을 받은 경우가 아니라면, 회수대상채권제외신고서에 의하여 한국은행총재에게 채권회수의무 면제에 관한 인정을 받아야 한다. 거주자와 비거주자의 구분외국환거래법상의 구분구분기준이 되는 거주성은 국적과 관계없이 일정기간을 거주하고 있거나, 거주할 의사를 가지고 있고, 경제적으로 밀착되어 있는지의 여부에 따라 결정된다. 거주자대한민국내에 주소 또는 거소를 둔 개인과 대한민국내에주된 사무소를 둔 법인이다. 다음 각호에 해당하는 자는 거주자로 본다. 대한민국 재외공관 대한민국 재외공관에서 근무할 목적으로 외국에 파견되어 체재하고 있는 대한민국 국민 국민인 비거주자이었던 자로서 입국하여 국내에 3개월 이상 체재하고 있는 자 다음 각호에 해당하는 외국인은 거주자 국내에서 영업활동에 종사 하고 있는 자 6월이상 국내에 체재하고 있는 자 국내 주둔 미합중국군대 등의 외국군인 및 군속 그리고 초청계약자, 동거가족은 제외 국내에 있는 외국정부의 공관 또는 국제기구에서 근무하는 외교관·영사 또는 그 수행원이나 사용인, 외국정부 또는 국제기구의 공무로 입국하는 자는 제외 비거주자의 국내지점, 출장소, 기타 사무소 비거주자거주자외의 개인 및 법인이다. 다음 각호에 해당하는 자는 비거주자로 봅니다. 국내에 있는 외국정부의 공관과 국제기구 국내에 있는 외국정부의 공관 또는 국제기구에 근무할 목적으로 파견되어 국내에 체재하고 있는 외국인 외국과의 협정등에 의하여 국내에 주둔하는 외국군대와 외국인인 그 구성원 및 군속 거주자의 외국에 있는 지점, 출장소, 기타의 사무소 다음 각호에 해당하는 대한민국 국민은 비거주자 외국에서 영업활동에 종사하고 있는 자 외국에 있는 국제기구에서 근무하고 있는 자 2년이상 외국에 체재하고 있는 자(이 경우 일시 귀국의 목적으로 귀국하여 3개월 이내의 기간 동안 체재한 경우 그 체재기간은 2년에 포함되는 것으로 본다.)","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Foreign Exchange","slug":"Finance/Foreign-Exchange","permalink":"http://melomance.github.io/categories/Finance/Foreign-Exchange/"}],"tags":[{"name":"외국환","slug":"외국환","permalink":"http://melomance.github.io/tags/외국환/"}]},{"title":"신용장의 이해","slug":"[FX] 신용장의-이해","date":"2017-11-15T13:47:52.000Z","updated":"2018-08-30T15:48:29.540Z","comments":true,"path":"2017/11/15/[FX] 신용장의-이해/","link":"","permalink":"http://melomance.github.io/2017/11/15/[FX] 신용장의-이해/","excerpt":"","text":"신용장 거래의 기본당사자개설은행(Issuing Bank)개설의뢰인의 요청과 지시에 따라 수출기업 앞으로 신용장을 개설하는 은행이다. 개설은행은 발행한 신용장 금액까지 일치하는 제시에 대한 결제의무를 부담한다. 수익자(Beneficiary)매매계약상의 수출기업으로서 신용장에 의하여 수혜를 받는 당사자로, 일치하는 제시(complying presentation)를 할 의무를 부담한다. 확인은행(Confirming Bank)개설은행의 요청 또는 수권을 받은 제3의 은행이 일치하는 제시에 대해 결제 또는 상환청구권 없이 매입을 하겠다는 추가적인 확약을 하는 은행이다. 개설은행의 공신력이 미약한 경우 수출기업은 제3의 은행의 결제 확약을 요구한다. 신용장거래의 기타당사자개설의뢰인(Applicant)자신의 거래은행에 수출기업 앞으로 신용장 개설 요청을 의뢰하는 당사자이다. 통지은행(Advising Bank)개설은행의 요청에 따라 신용장을 수익자에게 통지하는 은행이다. 신용장의 외견상 진정성 확인과 수신받은 신용장을 정확히 통지할 의무를 부담한다. 통지은행은 확인은행이 아닌 한 수익자에게 통지한 신용장에 대해 결제/매입을 할 의무가 없다. 개설은행과 수익자 소재지 은행 간 RMA 미체결 개설은행과 수익자의 거래은행과 모두 RMA를 체결한 제3의 은행을 이용한다. 개설은행 $\\rightarrow$ 제1통지은행 $\\rightarrow$ 제2통지은행(제3의은행) $\\rightarrow$ 수익자 지정은행수익자가 신용장 조건에 일치하는 제시를 하면 지급/연지급/인수/매입을 할 수 있도록 개설은행에 의해 권한을 받은 은행이다. 개설은행은 신용장에 이용 가능 은행으로 지정되어 있지 않다 하더라도 항상 수익자가 신용장을 이용할 수 있는 은행이다. 신용장 이용장소를 특정은행으로 명시한 경우 개설은행과 특정은행에서만 신용장 이용 가능하다. 신용장이 모든 은행에서 이용 가능하다고 표시한 경우 모든 은행에서 신용장을 이용할 수 있다. 지급은행(Payment Bank)지급신용장(by payment) 조건에서 수익자가 제시한 하자 없는 서류에 대해서 직접 대금지급을 해주는 은행이다. 매입은행(Negotiating Bank)매입신용장(by negotiation) 조건에 따라 수익자가 제시한 하자 없는 환어음 또는/그리고 선적서류를 매입하는 은행이다. 인수은행(Accepting Bank)인수신용장(by acceptance) 조건에 따라 수익자가 발행한 환어음을 인수하는 은행이다. 연지급확약은행(Deferred Payment Undertaking Bank)연지급신용장(by deferred payment) 조건에 따라 수익자가 제시한 선적서류에 대해 만기에 지급을 하겠다는 연지급확약을 하는 은행이다. 상환은행(Reimbursing Bank)개설은행의 지시에 따라 청구은행에 신용장 대금을 상환하는 은행이다. 청구은행(Claiming Bank)신용장 조건에 따라 결제 또는 매입을 하고 상환은행에게 상환청구를 하는 은행이다. 양도은행(Transferring Bank)양도가능신용장 하에서 수익자의 요청에 의하여 신용장의 권리와 의무를 제3자(제2수익자)에게 이전하는 은행이다. 신용장의 이용방식신용장에는 반드시 어떤 방식으로 이용 가능한지를 명시해야 한다. 일람지급방식(by sight payment) 개설은행이 일람불로 지급한다. 지정은행이 개설은행으로부터 신용장 대금을 지급받기 전에 일치한 제시를 한 수익자에게 미리 지급을 할 수 있게 해야 하므로 상환방식, 또는 지정은행이 개설은행의 계좌를 보유하여 바로 인출할 수 있는 차기방식으로 신용장이 개설되어야 한다. 연지급방식(by deferred payment) 연지급은행이 연지급을 확약하고 만기에 지급한다. 인수신용장과 동일하나 환어음을 요구하지 않는다. 일부 국가의 경우 환어음 인수/지급시에 인지세(stamp duty)를 부과하고 있어 인수방식보다 연지급방식을 선호한다. 인수방식(by acceptance) 수익자가 발행한 어음을 환어음의 지급인이 인수하고 만기에 지급한다. 기한부 신용장으로 항상 환어음을 요구하는 방식이다. 환어음 인수은행은 개설은행도 될 수 있고 특정 지정은행으로 표시될 수도 있다. 환어음의 지급은행과 지정은행인 인수은행은 동일해야 한다. 매입방식(by negotiation) 지정은행인 매입은행이 수익자의 서류/환어음을 매수하는 방식이다. 일람지급신용장, 기한부신용장에서 사용 가능하다. 환어음을 요구하는 경우 환어음의 지급은행과 매입은행이 동일해서는 안된다. 신용장방식 대금 결제방법송금방식(Remittance)개설은행이 선적서류를 수령한 후에 결제하는 방식이다. 상환방식과 달리 개설은행 입장에서는 일치하는 제시인지의 여부를 판단한 후에 지급이 이루어지므로 안전하다. 상환방식(Reimbursement)지정은행이 선적서류를 개설은행에 송부하고 대금청구는 개설은행이 아닌 상환은행에 청구하여 신용장 대금을 수령하는 방식이다. 차기방식(Debit)지정은행이 개설은행의 계좌를 보유하여 바로 인출할 수 있는 방식이다. 신용장의 지급기일(Tenor)At sight개설의뢰인이 신용장 대금 상환과 동시에 선적서류를 수령할 수 있다. Usance개설의뢰인이 선적서류를 수령 후에 청구대금을 만기에 결제하는 방식이다. Shipper’s Usance수입상은 만기에 결제하고 수출상도 만기에 청구대금 원금을 수령한다. Banker’s Usance수출상은 일람불로 지급받고 수입상은 만기에 원금과 이자를 상환한다. TAG MT 700 - Documentary Credits and Guarantee 42C: Drafts At … 서류심사의 기준서류만 검토지정은행, 확인은행, 개설은행은 서류에 나타난 문면상 내용에 의해서만 판단한다. 서류심사기간서류 접수일 다음일로부터 계산하여 최장 5은행영업일 서류제시기간서류제시기일을 지시하지 않은 경우, 수익자는 선적 후 21일 또는 유효기일이 종료되는 기일 중 빨리 도래하는 일자 내에 서류제시장소에 제시가 이루어져야 한다. 서류상호간 저촉여부제시된 서류 자체조건과 신용장에서 요구하여 수익자가 제시한 서류 상호간에는 저촉이 있어서는 안된다. 물품, 서비스 또는 의무이행의 명세송장의 물품, 서비스 또는 의무이행의 명세는 반드시 신용장의 물품, 서비스 또는 의무이행의 명세와 상응. 송장을 제외한 서류들은 기재되었다면 저촉하지 않은 일반적인 명세로 기재되어도 된다. 제시서류의 기능 확인송장, 운송서류, 보험서류를 제외한 서류들은 신용장에서 요구한 서류의 제 기능을 수행해야 한다. 신용장에서 요구하지 않은 서류서류심사 대상이 아니며 은행은 어떠한 책임없이 제시자에게 그 서류를 반환할 수 있다. 비서류적 조건은행은 서류만을 다루므로 비서류적 조건은 무시한다. 서류의 발행일신용장에 다른 지시가 없다면 서류의 발행일은 신용장 개설일 이전이어도 된다. 원본서류와 사본원본 서류의 제시 신용장에서 명시된 서류의 원본은 적어도 한 통은 제시되어야 한다. 서류 자체가 원본이 아니라는 표시가 없다면 명백하게 서류 발행자의 원서명, 마크, 스탬프 또는 라벨이 표시된 서류를 원본 취급한다. 신용장이 사본서류의 제시를 요구하였다면 원본 또는 사본이 제시되는 것이 허용된다. 신용장이 복수의 서류제시를 요구 in duplicate, in two folds 또는 in two copies 서류 자체에 다른 명시가 없다면 적어도 한 통은 원본이고 나머지는 사본서류가 제시되면 된다. 최종선적일/제시기간/유효기일최종선적일수출상이 선적을 이행해야 하는 최종선적일 제시기간선적서류를 제시해야 하는 기간 유효기일(= 최종선적일 + 제시기간): 서류를 제출할 수 있는 최종일 유효기일이 길면 수입상에서는 개설수수료가 부담된다. 유효기일이 짧으면 수익자(수출상)는 서류제시기간이 촉박하다. TAG MT 700 - Documentary Credits and Guarantee 31D: Date and Place Expiry 44C: LATEST DATE OF SHIPEMENT 48: PERIOD FOR PRESENTATION 양도가능신용장(Transferable L/C)신용장의 원 수익자(제1수익자) 요청에 의하여 신용장의 전부 또는 일부분을 다른 수익자(제2수익자)가 사용할 수 있는 신용장. TAG MT 700 - Documentary Credits and Guarantee 40A: Form of Documentary Credit : IRREVOCABLE TRANSFERABLE 신용장의 확인(Confirmation)일치하는 제시에 대해 결제(honour) 또는 매입하겠다는 개설은행의 확약에 추가한 확인은행의 확약을 의미한다. WITHOUT신용장 통지은행이 확인을 추가하지 않는 경우 MAYADD신용장 수익자가 확인 수수료를 부담하는 경우 CONFIRMED신용장 개설의뢰인이 확인 수수료를 부담하는 경우 TAG MT 700 - Documentary Credits and Guarantee 49C: Confirmation Instructions : WITHOUT","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Foreign Exchange","slug":"Finance/Foreign-Exchange","permalink":"http://melomance.github.io/categories/Finance/Foreign-Exchange/"}],"tags":[{"name":"외국환","slug":"외국환","permalink":"http://melomance.github.io/tags/외국환/"}]},{"title":"신용장 통일규칙","slug":"[FX] 신용장 통일규칙","date":"2017-11-15T13:45:00.000Z","updated":"2018-11-03T15:36:00.285Z","comments":true,"path":"2017/11/15/[FX] 신용장 통일규칙/","link":"","permalink":"http://melomance.github.io/2017/11/15/[FX] 신용장 통일규칙/","excerpt":"","text":"신용장 통일규칙(UCP)무역거래에서 신용장 업무를 취급할 때의 준수사항과 해석기준을 정한 국제적인 통일규칙이다. 국제상업회의소(ICC)가 1933년 화환신용장통일규칙으로 첫 제정하여 2006년까지 6차례 개정되었다. 제6차 개정된 UCP 600은 2007년 7월 1일부터 국제상거래에서 널리 사용되고 있다. Uniform Customs and Practice for Documentary Credits 600[Article 1] Application of UCP[제1조] 신용장통일규칙의 적용범위 UCP LATEST VERSION: UCP 600 [Article 2] Definitions[제2조] 정의 용어 설명 신용장(Credit) 그 명칭과 상관없이 개설은행이 일치하는 제시에 대하여 결제하겠다는 확약으로서 취소가 불가능한 모든 약정 개설은행(Issuing Bank) 개설의뢰인의 신청 또는 그 자신을 위하여 신용장을 개설한 은행 통지은행(Advising Bank) 개설은행의 요청에 따라 신용장을 통지하는 은행 지정은행(Nominated Bank) 신용장의 수익자가 조건에 일치하는 제시를 하면 결제/매입을 할 수 있도록 개설은행에 의해 권한을 받은 특정 은행을 의미모든 은행에 대한 수권이 있는 신용장의 경우에는 모든 은행 확인은행(Confirming Bank) 개설은행의 수권 또는 요청에 의하여 신용장에 확인을 한 은행 확인(Confirmation) 일치하는 제시에 대하여 결제 또는 매입하겠다는 개설은행의 확약에 추가하여 확인은행이 하는 확약 개설의뢰인(Applicant) 신용장 개설을 신청한 당사자 수익자(Beneficiary) 신용장 개설을 통하여 이익을 받는 당사자 일치하는 제시(Complying Presentation) 신용장 조건, 적용 가능한 UCP조항, 국제표준은행관행(ISBP)에 따른 제시를 의미 결제(Honour) At Sight: 일람불로 지급 Deferred Payment: 연지급 확약 후 만기에 대금지급 Acceptance: 환어음 인수 후 만기에 대금지급 매입(Negotiation) 지정은행이 일치하는 제시에 대해 타은행을 지급인으로 하는 환어음 및/또는 서류를 구매하는 행위 제시(Presentation) 신용장에 의하여 이루어지는 개설은행 또는 지정은행에 대한 서류의 인도 또는 그렇게 인도된 그 서류 자체 제시자(Presenter) 제시를 하는 수익자, 은행 또는 다른 당사자 은행영업일(Banking Day) 신용장통일규칙이 적용되는 행위의 수행을 위해 은행이 정규적으로 영업하는 날 [Article 3] Interpretations[제3조] 해석 [Article 4] Credits vs. Contracts[제4조] 신용장과 원인계약 독립성 원칙: 신용장은 기초거래와 별개의 거래 은행은 계약을 신용장의 일부분으로 포함하려는 시도를 저지해야 한다. [Article 5] Documents v. Goods, Services or Performance [제5조] 서류와 물품, 용역 또는 의무이행 은행은 서류를 다루는 것이지 서류와 관련된 물품, 서비스 또는 의무이행을 다루는 것이 아니다. [Article 6] Availability, Expiry Date and Place for Presentation[제6조] 이용가능성, 유효기일 그리고 제시장소 [Article 7] Issuing Bank Undertaking[제7조] 개설은행의 의무 [Article 8] Confirming Bank Undertaking[제8조] 확인은행의 의무 [Article 9] Advising of Credits and Amendments[제9조] 신용장 및 이에 대한 조건변경의 통지 [Article 10] Amendments[제10조] 조건변경(Amendments) [Article 11] Teletransmitted and Pre-Advised Credits and Amendments[제11조] 전신과 사전통지된(Teletransmitted and Pre-Advised) 신용장 및 그 조건변경 [Article 12] Nomination[제12조] 지정(Nomination) [Article 13] Bank-to-Bank Reimbursement Arrangements[제13조] 은행간 상환약정 [Article 14] Standard for Examination of Documents[제14조] 서류심사의 기준 [Article 15] Complying Presentation[제15조] 일치하는 제시 개설은행은 제시가 일치한다고 판단할 경우 결제honour)해야 한다. 확인은행은 제시가 일치한다고 판단할 경우 결제 또는 매입하고 그 서류를 개설은행에 송부해야 한다. 지정은행은 제시가 일치한다고 판단하고 결제 똔느 매입한 경우 그 서류를 확인은행 또는 개설은행에 송부해야 한다. [Article 16] Discrepant Documents, Waiver and Notice[제16조] 하자 있는 서류,권리포기(waiver)및 통지 [Article 17] Original Documents and Copies[제17조] 원본 서류와 사본 [Article 18] Commercial Invoice[제18조] 상업송장 [Article 19] Transport Document Covering at Least Two Different Modes of Transport[제19조] 적어도 두 개 이상의 다른 운송방법을 포괄하는 운송서류 [Article 20] Bill of Lading[제20조] 선하증권 [Article 21] Non-Negotiable Sea Waybill[제21조] 비유통 해상화물운송장 [Article 22] Charter Party Bill of Lading[제22조] 용선계약부 선하증권 [Article 23] Air Transport Document[제23조] 항공운송서류 [Article 24] Road, Rail or Inland Waterway Transport Documents[제24조] 도로, 철도 또는 내수로 운송서류 [Article 25] Courier Receipt, Post Receipt or Certificate of Posting[제25조] 특송배달영수증,우편영수증 또는 우편증명서 [Article 26] “On Deck”, “Shipper’s Load and Count”, “Said by Shipper to Contain” and Charges Additional to Freight[제26조] “갑판적재”, “내용물 부지약관” 과 운임에 대한 추가비용 [Article 27] Clean Transport Document[제27조] 무고장 운송서류 [Article 28] Insurance Document and Coverage[제28조] 보험서류와 부보범위 [Article 29] Extension of Expiry Date or Last Day for Presentation[제 29조] 유효기일 또는 최종제시일의 연장 [Article 30] Tolerance in Credit Amount, Quantity and Unit Prices[제30조] 신용장 금액, 수량 그리고 단가의 허용치 [Article 31] Partial Drawings or Shipments[제31조] 분할청구 또는 분할선적 [Article 32] Instalment Drawings or Shipments[제32조] 할부청구 또는 할부선적 [Article 33] Hours of Presentation[제33조] 제시시간 [Article 34] Disclaimer on Effectiveness of Documents[제34조] 서류의 효력에 대한 면책 [Article 35] Disclaimer on Transmission and Translation[제35조] 전송과 번역에 대한 면책 [Article 36] Force Majeure[제36조] 불가항력 [Article 37] Disclaimer for Acts of an Instructed Party[제37조] 지시받은 당사자의 행위에 대한 면책 [Article 38] Transferable Credits[제38조] 양도가능신용장 [Article 39] Assignment of Proceeds[제39조] 대금의 양도","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Foreign Exchange","slug":"Finance/Foreign-Exchange","permalink":"http://melomance.github.io/categories/Finance/Foreign-Exchange/"}],"tags":[{"name":"외국환","slug":"외국환","permalink":"http://melomance.github.io/tags/외국환/"}]},{"title":"수출입대금 결제방식","slug":"[FX] 수출입대금결제방식","date":"2017-11-05T02:46:00.000Z","updated":"2018-06-26T14:43:57.722Z","comments":true,"path":"2017/11/05/[FX] 수출입대금결제방식/","link":"","permalink":"http://melomance.github.io/2017/11/05/[FX] 수출입대금결제방식/","excerpt":"","text":"송금방식(Remittance)송금방식 결제는 수출입계약 당사자들 간의 상호 신뢰에 따라 수출입대금을 지급하고 영수하는 방식이다. 대금 지급 및 영수시점에 따라 사전송금방식과 사후송금방식으로 구분할 수 있다. 사전송금 구분 장점 단점 수출기업 신용장/무신용장 거래대비 수수료 부담↓수입상의 물품 미결제위험 無 - 수입기업 신용장/무신용장 거래대비 수수료 부담↓ 물품수령 전 결제 물품을 이전 받지 못하는 위험 有 거래은행 물품대금에 대한 결제책임 無 신용장/무신용장 거래대비 은행수익↓은행수익은 당/타발송금정리수수료 사후송금 구분 장점 단점 수출기업 신용장/무신용장 거래대비 수수료 부담↓ 수입상의 물품 미결제위험 有수출기업에 가장 불리한 결제방식 수입기업 신용장/무신용장 거래대비 수수료 부담↓물품 수령 후 결제계약이행여부 확인 가능 - 거래은행 물품대금에 대한 결제책임 無 신용장/무신용장 거래대비 은행수익↓ 물품인도결제방식(COD: Cash on Delivery)수출기업이 물품을 선적하고 물품과 관련한 선적서류를 수입지에 소재하는 수출기업의 지사 또는 해외지사 등에게 선적서류를 송부하고 물품이 수입지에 도착하면 수입기업이 물품의 품질 등을 검사하여 계약조건을 충족하면 수입대금의 결제와 함께 물품을 수령하는 방식이다. 귀금속 등의 물품을 항공기로 운송할 때 주로 사용하는 결제방식이다. 서류인도결제방식(CAD: Cash against Documents)수출기업이 물품을 선적하고 물품과 관련한 선적서류를 수출지에 소재하는 수입기업의 지사 또는 대리인에게 선적서류를 제시하여 수입기업이 결제와 함께 제시된 선적서류를 수령하는 조건이다. 국제적으로 사후송금방식을 OA(Open Account)라고 한다. 추심방식(Collection)무신용장방식으로 수출기업이 물품을 선적한 후에 환어음(필수는 아님)과 물품 관련 선적서류를 수출기업의 거래은행(추심의뢰은행)과 수입기업의 거래은행(추심은행)을 통하여 수입기업에 수출대금을 추심하는 방식이다. 추심방식은 지급인도방식인 D/P(Documents against Payment)방식과 인수인도방식인 D/A(Documents against Acceptance)방식이 있다. 지급인도방식(D/P) 구분 장점 단점 수출기업 신용장 거래대비 수수료 부담↓대금미결제시 추심은행은 선적서류 인도X송금거래에 비해 거래의 안정성↑ 송금방식에 비해 수수료 부담↑은행의 지급확약이 無선적후 수출금융을 지원받기 難 수입기업 신용장 거래대비 수수료 부담↓은행이 선적서류를 관리/교부송금방식에 비해 거래의 안정성↑ 송금방식에 비해 수수료 부담↑ 거래은행 물품대금에 대한 결제책임 無송금거래에 비해 은행수익↑ 신용장 거래대비 은행수익↓ 인수인도방식(D/A) 구분 장점 단점 수출기업 신용장 거래대비 수수료 부담↓송금거래에 비해 거래의 안정성↑환어음법에 따라 보호받을 수 있음 송금방식에 비해 수수료 부담↑은행의 지급확약이 無선적후 수출금융을 지원받기 難 수입기업 신용장 거래대비 수수료 부담↓은행이 선적서류를 관리/교부송금방식에 비해 거래의 안정성↑ 송금방식에 비해 수수료 부담↑ 거래은행 물품대금에 대한 결제책임 無송금거래에 비해 은행수익↑ 신용장 거래대비 은행수익↓ 추심거래의 당사자추심의뢰인(Principal)거래은행에 수출대금의 추심을 의뢰하는 당사자로 수출기업이다. 추심의뢰은행(Remitting Bank)수출기업으로부터 추심을 의뢰받은 은행이다. 추심은행(Collecting Bank)추심의뢰은행으로부터 최초로 선적서류를 수취하는 수입지의 은행이다. 제시은행(Presenting Bank)수입기업에게 선적서류를 제시하는 은행이다. 추심은행이 수입기업의 거래은행이면 추심은행이 제시은행이 된다. 지급인(Drawee)추심지시서에 따라 환어음의 제시를 받게 되는 자로 수입기업이다. 신용장방식(Letter of Credit/Documentary Credit/Credit)수출입거래에 있어 신용도가 우수한 제3자인 은행이 물품대금의 지급을 확약하는 방식으로, 신용장을 발행한 개설은행이 수익자가 하자 없는 제시를 하는 경우에만 지급의무가 있는 보증이다. 신용장방식(L/C) 구분 장점 단점 수출기업 수출품목에 대한 대금회수 확실 다른 방식에 비해 수수료 부담↑일치하는 제시를 못하면 개설은행의 결제확약 보장이 難 수입기업 선적기간 명시를 통해 물품도착시기 통제(기한부신용장) 수입물품의 판매대금으로 수입대금 결제가능 다른 방식에 비해 수수료 부담↑수출기업의 계약 미이행시에도 결제대금 상환해야 하는 위험 有 수출기업거래은행 개설은행의 결제확약 有수출기업에 수출금융 제공 가능다른 결제방식에 비해 수수료 수익↑ 개설은행 파산시 수출금융 금액 상환이 難 수입기업거래은행 다른 결제방식에 비해 수수료 수익↑ 서류심사를 소홀히 하는 경우 책임부담","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Foreign Exchange","slug":"Finance/Foreign-Exchange","permalink":"http://melomance.github.io/categories/Finance/Foreign-Exchange/"}],"tags":[{"name":"외국환","slug":"외국환","permalink":"http://melomance.github.io/tags/외국환/"}]},{"title":"수출입개요","slug":"[FX] 수출입개요","date":"2017-10-28T12:47:00.000Z","updated":"2018-08-30T15:48:29.540Z","comments":true,"path":"2017/10/28/[FX] 수출입개요/","link":"","permalink":"http://melomance.github.io/2017/10/28/[FX] 수출입개요/","excerpt":"","text":"수출입거래수출의 정의 매매, 교환, 임대차, 사용대차, 증여 등을 원인으로 국내에서 외국으로 물품이 이동 보세판매장에서 외국인에게 국내에서 생산된 물품을 매도 유상으로 외국에서 외국으로 물품을 인도 거주자가 비거주자에게 산업통상자원부장관이 정하여 고시한 방법으로 용역을 제공 거주자가 비거주자에게 정보통신망을 통한 전송과 전자적 형태의 무체물을 인도 (관세법상) 내국물품을 외국으로 반출하는 것을 말한다. 수입의 정의 (관세법상) 외국물품을 우리나라에 반입하거나 우리나라에서 소비 또는 사용 거래대상 물품, 용역(혹은 서비스), 정보통신망을 통한 전송 및 전자적 형태의 무체물 무상으로 외국에서 외국으로 물품을 인수받는 것은 대외무역법상 수입거래가 아니다. 거래주체 개인과 법인 모두 수출입거래를 할 수 있다. 무역거래자: 일반무역업자, 무역대리업자 무역업고유번호를 부여 받을 수 있으나 무역업을 하는데 있어 필수는 아니다. 수출입거래 특징언어 이슈수출입계약 관련 서류 작성시 어느 언어를 기준으로 할지 통화결정 이슈어느 통화를 결제통화로 할지 통관 이슈수출국 및 수입국 세관에서의 통관절차 필요 국제운송 이슈복합운송, 해상운송, 항공운송 법적 이슈무역클레임이 발생하여 이를 소송으로 해결시 다음의 이슈가 발생 준거법(Governing law): 어느 국가의 법률로 해석할 것인지? 재판관할권(Jurisdiction): 소송이 진행될 법정은 어디인지? 수출입거래 관련 주요 서류상업송장(Commercial Invoice)매매 또는 위탁계약에 의한 물품의 수도가 멀리 떨어진 지역 사이에서 행하여지는 경우에 그 물품의 송하인으로부터 그 수하인에게 송화의 특성, 그 내용 명세, 그 계산관계를 상세하고 정확하게 통지하기 위하여 작성되는 상용문서이다. 운송서류(Transport Document)무역품의 재산권을 완전히 나타낸 것으로서 국제무역계에서 인정되고 있는 상용 서류이다. 종래의 무역 운송수단은 대부분 해상운송에 의존하였으나 운송수단의 급속한 발달로 항공, 복합운송수단 등으로 선적이 이루어짐으로써 선적서류(shipping documents)란 용어가 운송서류로 변경되었다. 포장명세서(Packing List)포장에 관한 사항을 상세히 기재한 서류를 말한다. 포장 내의 수량과 순중량·총중량·용적·화인·포장의 일련번호 등을 기재하는 것으로, 패킹리스트라고도 한다. 원산지증명서(Certificate of Origin)당해 물품이 확실하게 그 국가에서 생산되거나 제조된 것이라는 것을 증명하는 공문서로서 통상은 수출국에 주재하는 수입국 영사가 발급한다. 환어음(Draft, Exchange of Bill)어음 작성자(발행인)가 제3자(지급인)에 대하여 어음에 기재된 금액을 일정한 기일에 어음상의 권리자(수취인 또는 지시인)에게 지급할 것을 무조건으로 위탁하는 증권이다. 보험서류 등(Insurance Document) 수출입거래의 위험요인 및 위험 관리 방안신용위험 및 국가위험선수금방식 수출, 신용장, 무보 단기수출보험 국제운송 관련 위험적하보험 법률적 위험상시중재제도 활용, 법무법인, 관세법인 등 업계전문가 자문 활용 등 환위험환리스크 관리기법 활용(선물환거래, 통화옵션, 통화스왑, 결제시기 의도적 조정) 물품 품질에 대한 위험검사증명서, 독립적이고 국제적인 검사기관 등 수출입기업 관련수출기업의 의무 물품에 대한 소유권 이전 의무 물품인도 의무 물품에 대한 서류교부 의무 물품에 대한 계약적합 의무 수입기업의 의무 대금지급 의무 물품인도에 대한 수령 의무 물품검사 의무 물품의 부적합에 대한 통지 의무 수출기업의 장점 수출하는 재화나 용역에 대하여는 부가가치세 영세율이 적용됨. 관세환급제도 수혜 수입기업의 장점 해당 물품을 국내에 공급하여 매출증대와 영업이익 창출. 수출입통관수출통관 통관절차: 수출하고자 하는 물품을 세관에 수출신고를 한 후 신고수리를 받아 물품을 우리나라와 외국 간을 왕래하는 운송수단에 적재하기까지의 절차이다. 수출신고: 수출물품 소유자나 관세사가 관세청 통관시스템에 전송하는 방법이다. 수출신고필증: 세관에서 수출신고가 수리된 때 수출신고필증이 교부 된다. 수입통관 통관절차: 수입하고자 하는 물품을 세관에 수입신고를 한 후 신고수리를 받아 수입물품이 반출될 수 있도록 하는 일련의 과정이다. 수입신고: 관세사나 일정한 요건을 갖춘 수입화주가 할 수 있다. 수입신고필증: 세관에서 수입신고가 수리된 때 수입신고필증이 교부 된다. 수입신고시기:① 출항 전 신고② 입항 전 신고③ 보세구역 도착전 신고④ 보세구역에 장치 후 신고 외국환거래 약정거래기업이 은행과 수출입금융 거래(신용장 개설, 수출환어음 매입 등)를 하려면 기본적으로 외국환거래 약정 체결 필요하다. 수입신용장 발행은 직무전결 규정에서 정하는 여신전결권자의 승인을 받아야 한다. 은행은 외국환거래 약정서가 특별히 변경되지 않는 한 수출거래나 수입거래를 최초로 거래하는 경우에 징구하면 된다. 외화환전, 수입대금 송금거래, 수출대금 영수거래는 외국환거래 약정서의 적용범위에 포함되지 않는다. 무역거래에 관한 정형거래 조건(INCOTERMS2010)운송 방식별 분류 모든 운송방식에 사용가능 조건 EXW, FCA, CPT, CIP, DAP, DAT, DDP 해상운송(내수로 운송)에만 사용되는 조건 FAS, FOB, CFR, CIF 운임 부담자별 분류 매도인(수출상)이 운임을 부담하는 조건 CFR, CPT, CIF, CIP, DAP, DAT, DDP 매수인(수입상)이 운임을 부담하는 조건 EXW, FCA, FAS, FOB 보험 가입자별 분류 매도인(수출상)이 부보하는 조건 CIF, CIP 매수인(수입상)이 부보하는 조건 EXW, FCA, FAS, FOB, CFR, CPT 위험이전 분기점별 분류 매도인(수출상)의 위험부담이 수출지에서 종료되는 조건 EXW, FCA, FAS, FOB, CFR, CPT, CIF, CIP 매도인(수출상)의 위험부담이 수입지에서 종료되는 조건 DAP, DAT, DDP 특정거래 형태의 수출입위탁판매수출국내 수출기업이 해외 수입기업에게 소유권을 이전하지 않은 상태에서 물품 등을 무환으로 수출하고 해당 물품이 판매된 범위 안에서 대금을 결제받는 계약에 의한 수출 수탁판매수입해외 수출기업(위탁자)으로부터 국내 수입기업(수탁자)이 소유권을 이전받지 않은 상태에서 물품 등을 무환으로 수입하여 해당 물품이 판매된 범위 안에서 대금을 결제하는 계약에 의한 수입 위탁가공무역외국에서 가공할 원료의 전부 또는 일부를 거래 상대방에게 수출하거나 외국에서 조달하여 이를 가공한 후 가공물품 등을 수입하거나 외국으로 인도하는 수출입 수탁가공무역가득액을 영수하기 위하여 원자재의 전부 또는 일부를 거래 상대방의 위탁에 의하여 수입하여 이를 가공한 후 위탁자 또는 그가 지정하는 자에게 가공물품 등을 수출하는 수출입 임대수출임대계약에 의하여 물품 등을 수출하여 일정기간 후 다시 수입하거나 그 기간의 만료 전 또는 만료 후 해당 물품 등의 소유권을 이전하는 수출 임차수입임차계약에 의하여 물품 등을 수입하여 일정기간 후 다시 수출하거나 그 기간의 만료 전 또는 만료 후 해당 물품의 소유권을 이전받는 수입 연계무역물물교환, 구상무역, 대응구매, 제품환매 등의 형태로 수출과 수입이 연계되어 이루어지는 수출입 중계무역수출을 목적으로 물품 등을 수입하여 국내에 반입하지 않고 수출하는 수입 [해외수입업체] ←수입$\\rightarrow$ [중계상] ←수출$\\rightarrow$ [최종공급업체] (신용장 개설방법#1) 해외수입업체의 요청에 의해 중계상 앞으로 master L/C 개설 (신용장 개설방법#2) 중계상의 요청에 의해 master L/C를 최종공급업체 앞으로 양도 외국인수수입수입대금은 국내에서 지급되지만 수입 물품 등은 외국에서 인수하거나 제공받는 수입 외국인도수출수출대금은 국내에서 영수하지만 국내에서 통관되지 아니한 수출 물품 등을 외국으로 인도하거나 제공하는 수출 무환수출입외국환 거래가 수반되지 아니하는 물품 등의 수출수입","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Foreign Exchange","slug":"Finance/Foreign-Exchange","permalink":"http://melomance.github.io/categories/Finance/Foreign-Exchange/"}],"tags":[{"name":"외국환","slug":"외국환","permalink":"http://melomance.github.io/tags/외국환/"}]},{"title":"네트워크 기본 기술","slug":"[NE] 네트워크 기본기술","date":"2016-06-15T06:21:33.000Z","updated":"2018-08-18T15:35:53.611Z","comments":true,"path":"2016/06/15/[NE] 네트워크 기본기술/","link":"","permalink":"http://melomance.github.io/2016/06/15/[NE] 네트워크 기본기술/","excerpt":"","text":"네트워크네트워크란 컴퓨터나 정보기기를 이용하여 송신자와 수신자 간에 정보를 전달하는 것이다. 네트워크 구성시 고려사항 성능 확장성 유연성 보안성 가용성(24/365) 통신신호 종류네트워크에서 통신을 하는 방식에 따라 다음과 같이 구분된다. 유니캐스트: One to One 로컬 랜 상에 있는(=Broadcast Domain) 하나의 네트워크 장비에게 보내는 통신이다. 전송되는 Frame 안에는 출발지와 목적지의 MAC 주소가 들어 있으며, 목적지의 MAC 주소를 가진 PC만 수신한다. 브로드캐스트: One to All 로컬 랜 상에 있는(=Broadcast Domain) 모든 네트워크 장비들에게 보내는 통신이다. 브로드캐스트의 MAC 주소: FFFF.FFFF.FFFF (16진수, 12자리) 기본적으로 Frame안의 목적지 MAC 주소(물리적 주소)가 내 주소가 아니면 버리지만 브로드캐스트는 예외이다. 멀티캐스트: One to Group 100대의 PC가 있는 네트워크에서 80대의 PC에게만 보내 메시지를 보내는 통신이다. 라우터나 스위치에서 멀티캐스트를 지원해야 사용 가능하다. 네트워크 연결장치리피터(Repeater) 원 신호의 세기 증폭, 1계층 장비이다. 허브(Hub) 멀티포트 리피터, 1계층 장비이다. 단, 통신을 하기 위해서는 다른 누군가의 통신이 끝날때까지 기다려야 하는 단점이 있다. 브릿지(Bridge) 2계층 장비이다. (소프트웨어 방식) 허브처럼 생겼으나 4개의 포트를 보유하고 있으며 각 포트별로 Collision Domain이 나뉘므로 허브의 단점을 극복했다. 스위치(Switch) 2계층 장비, L3 or L4 등의 스위치도 존재하지만 태생은 2계층 장비이다. 브릿지를 하드웨어 방식으로 구현했으며(ASIC 칩 방식), 브릿지보다 더 빠른 성능을 보장한다. L3 스위치: 라우팅 기능(IP 주소)을 지원하는 스위치 L4 스위치: 서버 및 방화벽의 앞단에 두고 로드 발란싱 기능을 지원 방화벽 앞단에 L4스위치(outside)를 둬서 외부에서 내부로 들어오는 트래픽들이 방화벽을 거칠 때 이를 분산시켜 처리한다. 내부 인트라넷에서 외부 인터넷으로 나갈 때도 방화벽 앞 L4스위치(inside)를 통해 트래픽을 분산시킨다. 라우터(Router) 3계층 장비로 Mac 주소를 벗기고 IP 주소를 보고 포워딩한다. OSI 7Layer목적기본적인 하드웨어 또는 소프트웨어의 변경 없이 서로 다른 시스템간에 개방 통신 장점복잡함 감소, 인터페이스 표준화, 상호 호환성 확보, 기술 개발 가속화 등 기능각 계층의 프로토콜은 하위 계층 프로토콜의 기능을 이용하여 해당 계층을 실행하고, 그 결과를 상위계층에 제공한다. Protocol Data Unit(이하 PDU)프로토콜 이용자 정보를 실어 나르기 위해 사용한다. 즉, PDU = Control Information + User Data Encapsulation계층별 헤더정보를 추가한다. 각 계층에서는 상위 계층에서 내려온 데이터들 앞에 헤더, 뒤에 트레일러를 붙여서 캡슐화하여 최종 전기신호로 전송된다. De-Encapsulation데이터를 수신하게 되면, 우선 데이터를 받은 물리 계층은 위의 데이터링크 계층으로 넘겨준다. 물리주소와 다른 제어 정보를 읽는다. 다른 제어 정보를 떼어내고 데이터만 추출한다. 그 데이터를 자신의 상위 계층에 넘기게 된다. (L7) Application: 응용 프로그램을 위한 네트워크 서비스 제공 OSI 계층 중 사용자와 가장 연관이 많은 계층으로, 사용자가 이용할 네트워크 서비스를 정의하고 있다. e.g. E-mail, FTP, Telnet, HTTP 등의 통신 S/W 관련 프로토콜: HTTP, telnet, DNS, DHCP 등 PDU: Message or Data Stream (L6) Presentation: 데이터의 표현 Application 계층을 위한 데이터 전송 방법을 협의한다. 다양한 데이터의 포맷 결정, 코드변환, 구문변환, 압축, 암호화 기능 등을 담당한다. PDU: Message or Data Stream (L5) Session: 호스트간의 통신 상호 응용 프로그램 간 세션을 열고, 닫고, 관리하는 기능이다. PDU: Message or Data Stream (L4) Transport: 양단의 연결(End-to-End Connection) 전송 계층은 전송을 위해 정보 데이터들을 쪼개고, 상대편에 도달하여 다시 합치는 과정을 담당한다. 데이터가 상대편 컴퓨터에 전달되는 것을 보장하기 위해 에러제어(Error control)와 흐름제어(Flow Control)로 데이터 전송속도를 조절한다. 상위 계층에 전송 서비스를 제공: 연결형 서비스, 비연결형 서비스 어떤 응용 프로그램으로 넘길지는 Port 번호로 결정한다. 관련 프로토콜: TCP, UDP PDU: Segment (L3) Network: 데이터 전달 호스트간의 경로선택, 논리적 주소(IP)를 이용한 패킷의 라우팅, 데이터 전달을 위한 최적경로를 선택한다. 네트워크 계층은 논리적 주소(IP 주소)를 정하는 계층이다. 관련 프로토콜: IP, ICMP, ARP, RARP PDU: Packet (L2) Datalink: 전송 매체의 접근 물리적인 케이블을 통하여 인접장치간 신뢰성 있는 정보를 교환, MAC을 제어하여 두 시스템간 데이터를 전달한다. 데이터링크 계층은 물리적 주소(MAC 주소)를 정하는 계층이다. LAN기술은 이더넷, 토큰링 등을 사용한다. PDU: Frame (L1) Physical: Bit의 전송 물리계층은 두 시스템간 전기적인, 기계적인 특징과 절차적인 연결을 정의하는 계층이다. e.g. 전기선의 전압은 몇 볼트, 전압 변화 타이밍은 어떻게 정할지, 물리적인 데이터 속도, 최대 연결 거리 등 PDU: Bit LAN (Local Area Network) 구축 기술Ethernet 가장 빠르며 전세계 90% 이상을 차지하며, IEEE 802.3 규약으로 표준화 물리적 토플리지: Bus형, Star형 등 논리적 토플리지: CSMA/CD(Carrier Sense Multiple Access/Collision Detection) 방식을 사용한다.① 네트워크 사용 상태를 확인: Carrier Sense② 충돌 감지시 대기상태로 전환: Collision Detection (재전송은 15번 시도)③ 충돌 없으면 데이터 전송 Standard Ethernet (10 Base T); 10 전송속도, Base 전송방식, T 전송매체 Fast Ethernet (100 Base T) Giga Ethernet (1G ~ 10G) Ethernet Frame D-mac(6Bytes) + S-mac(6Bytes) + Length(2Bytes) + Data(1500Bytes) + FCS(4Bytes) = 1518 Bytes MTU(Maximum Transmission Unit) 1500 Bytes, MTU초과시 Fragmented 해서 송신 MSS(Maximum Segment Size) 1460 Bytes, MTU에서 IP 헤더(20Bytes)와 TCP 헤더(20Bytes) 크기 제외 Token Ring 토큰을 가진 PC만 데이터를 전송할 수 있는 통신 방식이다. 단, 데이터를 보내려면 토큰이 자기에게 올때까지 기다려야 한다. ATM, FDDI 등 Collision Domain vs. Broadcast DomainCollision Domain을 나누는 장비 브릿지(Bridge), 스위치(Switch), 라우터(Router) Broadcast Domain을 나누는 장비 라우터(Router) 구분 리피터(Repeater) 허브(Hub) 브릿지(Bridge) 스위치(Switch) 라우터(Router) Collision Domain 1 1 4+n 4+n 4+n Broadcast Domain 1 1 1 1 4+n Example","categories":[{"name":"Network","slug":"Network","permalink":"http://melomance.github.io/categories/Network/"}],"tags":[{"name":"네트워크","slug":"네트워크","permalink":"http://melomance.github.io/tags/네트워크/"}]},{"title":"채권회수","slug":"[LW] 채권회수","date":"2015-11-21T13:00:00.000Z","updated":"2018-08-30T15:48:29.539Z","comments":true,"path":"2015/11/21/[LW] 채권회수/","link":"","permalink":"http://melomance.github.io/2015/11/21/[LW] 채권회수/","excerpt":"","text":"채권회수 방법임의변제 채무자의 임의변제 제3자의 임의변제 상계강제회수(법적절차) 담보권 실행: 질권, 저당권, 양도담보권 등 강제집행 특수정리절차 참가: 희생, 파산절차 등 부수적 절차 활용: 독촉절차, 보전처분 등 임의회수변제 채무내용인 급부를 실현하여 채권을 소멸시키는 행위 채무자의 임의변제 채무자가 상환기일에 스스로 변제하는 경우 대출금회수는 우선 임의변제에 의하는 것이 가장 바람직하다. 제3자의 변제 연대보증인, 근저당권 설정자, 담보물 제3취득자 등 제3자가 변제하는 경우 이 경우 제3자는 채무자에 대하여 구상권을 취득한다. 상계 상계요건:① 두 개의 채무 존재② 두 개의 채무가 동종의 채무③ 두 개의 채무가 상호 대립적④ 자동 채권의 변제기가 도래 등 상계로서 양 당사자의 채무는 대등액에 관해 소멸 상계적상이 생긴 후에 상계하더라도 채무는 상계적상이 생긴 시점에서 소급하여 소멸 예금채권과 대출채권을 상계(예대상계) 기타 임의적 회수방법 대물변제: 채무자가 채권자의 승낙을 얻어 채무자가 부담한 본래 급부에 갈음하여 다른 급부를 함으로써 채권을 소멸시킨다. 채권양도에 의한 회수 채권자교체에 의한 회수 채무자교체에 의한 회수: 채무자변경의 경개, 면책적 채무인수, 계약인수 담보권 실행임의적 방법에 의한 회수가 여의치 않은 경우에는 미리 설정해놓은 담보권을 실행하게 된다. 담보권 구분 법률상 실행방법 약정상 실행방법 저당권 임의경매(민집 264) 임의처분(근저계7) 질권(동산질) 임의경매(민 338①, 민집 271) 간이변제충당(민 338②)유질(상 59) 유질계약임의처분(근질계 5)정지조건부 대물변제계약 질권(권리질) 직접청구(민 353)강제집행방법(민 354) 평가취득 매각처분(양계7 또는 8)평가취득 강제집행민사집행법에 규정하는 절차에 따라 집행기관(유체동산은 집행관, 기타는 집행법원)이 관장하는 법적 절차이다. 강제집행을 위해서는 미리 집행권원을 갖추고 집행문을 받아서 집행력 있는 정본을 가져야만 강제집행을 신청할 수 있다. 강제집행 절차 신청 $\\rightarrow$ 압류 $\\rightarrow$ 환가 $\\rightarrow$ 배당 보전처분 신청 채무자 등이 신의에 반하여 재산의 처분 또는 도피 할 우려가 있으므로 보전처분 신청 가압류를 신청하여 장차 강제집행의 대상이 될 재산을 처분금지로 묶어둔다. 가압류금전채권에 기한 장래의 강제집행을 보전하기 위하여 미리 집행 가능한 채무자의 재산에 관하여 그 처분권을 빼앗아 두는 것이다. 가압류는금전채권의 집행 보전을 목적으로 하며, 가압류채권자는 심리대상인 가압류의 요건, 즉 피보전권리의 존재와 가압류 필요성을 소명하여야 한다. 부동산에 대한 가압류 집행가압류법원이 그 부동산의 소재지를 관할하는 등기소에 대하여 가압류 결정정본 및 등기 촉탁서를 첨부하여 가압류 사실을 등기부에 기재할 것을 촉탁한다. 유체동산에 대한 가압류 집행가압류하고자하는 유체동산의 소재지를 관할하는 지방법원에 소속되어 있는 집행권자에게 채권자가 서면으로 그 집행을 위임한다. 채권에 대한 가압류 집행가압류명령을 한 법원이 스스로 집행법원이 되어 제3채무자에 대하여 채무자에게 지급하는 것을 금지하는 명령을 제3채무자에게 송달한다. 가처분특정의 목적물에 관한 급부청구권의 집행을 보전하기 위하여, 또는 쟁의 있는 권리나 권리관계에 대한 현재의 위험을 피하기 위하여 임시의 지위를 법원이 정하거나 처분을 금지하는 것을 말한다. 채무자의 처분행위를 금지함으로써 현상의 변경을 방지하고 현재의 위험 또는 손해를 막기 위해 가처분이 존재한다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"양도담보","slug":"[LW] 양도담보","date":"2015-11-21T11:00:00.000Z","updated":"2018-05-20T12:36:43.375Z","comments":true,"path":"2015/11/21/[LW] 양도담보/","link":"","permalink":"http://melomance.github.io/2015/11/21/[LW] 양도담보/","excerpt":"","text":"양도담보 의의양도담보는 채권담보의 목적으로 일정한 재산을 양도하고 채무자가 이행하지 않는 경우에 채권자는 목적물로부터 우선변제를 받게 되나, 채무자가 채무를 이행하는 경우에는 목적물을 반환하는 방법에 의한 담보를 말한다. 양도담보의 특질 경제족 목적은 담보제공이지만, 법률적으로는 목적물의 소유권을 채권자에게 이전하는 형식 채권자는 목적물에 대한 소유권 보유, 채무자는 목적물에 대한 점유권 보유 양도담보의 위험 채무자가 불성실하여 자기가 점유하는 목적물을 제3자에게 양도하여 그 자가 선의취득을 하면 채권자는 담보를 상실한다. 채권자가 담보의 목적으로만 사용할 의무를 위반하여 제3자에게 양도하면 채무자는 그 물건의 소유권을 회복할 수 없다. 양도담보권의 설정양도담보권의 설정은 채권담보의 목적으로 담보목적물의 소유권을 이전하는 물권행위에 의하여 성립한다. 계약의 당사자 양도담보권자: 채권자 (담보를 취득하는 자) 양도담보권설정자: 채무자 또는 제3자 (담보를 제공하는 자) 설정절차 양도담보계약을 체결 (은행에서는 양도담보증서를 받는다) 목적물이 동산인 경우는 인도, 부동산인 경우는 소유권이전등기 필요 양도담보권의 효력본질적 효력: 우선변제권 담보권을 실행하여 다른 채권자에 우선하여 자기채권의 우선변제에 충당 가능하다. 목적물의 범위 채무자가 목적물에 부합시킨 물건과 종물 피담보채권의 범위 제한 없음 양도담보권자의 의무 취득한 권리를 담보의 목적을 넘어서 행사하여서는 아니될 채권적 의무를 부담한다. 변제기 전에는 목적물을 처분하지 못한다. 양도담보권의 행사 및 소멸양도담보권의 행사 채권자는 목적물을 임의로 매각하거나 평가하여 그 대금 또는 평가액을 원본과 이자에 충당하고 잔액이 있으면 이를 채무자에게 반환한다. 만일 부족액이 있으면 이를 채무자에게 청구할 수 있다. 양도담보권의 소멸 양도담보권은 채권이 변제, 기타의 사유로 소멸하거나 목적물이 멸실됨으로써 소멸된다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"저당권","slug":"[LW] 저당권","date":"2015-11-20T02:48:30.000Z","updated":"2018-05-20T12:36:43.371Z","comments":true,"path":"2015/11/20/[LW] 저당권/","link":"","permalink":"http://melomance.github.io/2015/11/20/[LW] 저당권/","excerpt":"","text":"질권의 의의질권은 채권자가 그 채권의 담보로 채무자 또는 제3자로부터 받은 물건을 유치하고 채무의 변제가 없을 때에는 그 물건을 매각하여 그 물건의 대금으로부터 다른 채권자에 우선하여 그의 채권의 변제를 받을 수 있는 권리이다. 질권 vs. 저당권 질권과 저당권은 당사자 간의 계약에 의하여 성립하나, 질권은 목적물의 점유를 담보설정자로부터 빼앗는 데 반하여, 저당권은 점유를 빼앗지 않고 계속하여 담보설정자가 점유하게 된다. 질권의 법률적 성질 목적물의 교환가치를 지배하는 권리 목적물을 유치하는 권리 우선변제 받을 권리 약정담보물권: 질권설정계약 필요 담보물권: 타물권, 수반성, 부종성, 불가분성, 물상대위성 동산질권동산질권의 설정 질권자: 채권자에 한함 질권설정자: 채무자에 한하지 않고 제3자라도 가능 질권자와 질권설정자의 합의와 목적물을 인도함으로써 효력 발생 동산질권의 효력 질권은 원본뿐 아니라 기타 일정 범위의 것에 미친다. 동산질권의 목적물은 질권설정계약에서 합의된 목적물로서 점유가 이전된 것 전부다. 질권자의 권리 동산질권자는 목적물을 유치할 권리가 있고 우션변제를 받을 권리가 있다. 단, 유질계약은 금지 (채무자 보호를 위함) 권리질권채권, 주식 등 양도할 수 있는 재산권은 유체물과 같이 질권의 목적이 될 수 있으며, 이러한 질권을 권리질권이라 한다. 질권 vs. 권리질권 질권은 토지나 건물이 아닌 동산을 대상으로 하는 권리지만, 권리질권의 목적물은 채권, 주식, 무체재사권이다. 권리질권의 성질 법률적 성질은 동산질권과 같다. 권리질권의 객체 양도가능한 재산권일 것 질권의 설정이 부적당하지 않은 권리일 것 유치권의 의의유치권은 타인의 물건을 점유하고 있는 자가 그 물건에 관하여 발생한 채권의 변제를 받을 때까지 그 물건을 유치하고, 채권의 변제를 간접적으로 강제하는 권리이다. 유치권은 법정담보물권으로서 우선변제권과 물상대위권이 없다. 유치권의 법률적 성질 물권 법정담보물권: 타인의 물건을 점유하는 자가 그 물건에 관하여 생긴 채권을 가지고 있으면 당연히 취득하는 권리 우선변제 받을 권리 없음, 물상대위성 없다. 담보물권: 부종성, 수반성, 불가분성 유치권의 성립 채권이 유치권의 목적물에 관하여 생긴 것일 것 채권이 변제기에 있을 것 유치권자는 물건 또는 유가증권의 점유자일 것 타인의 물건 또는 유가증권일 것 점유가 불법행위에 의하여 시작된 것이 아닐 것 등 유치권의 효력 유치권자는 목적물을 유치할 수 있고 과실수치권을 가진다. 유치권자는 유치물에 대해서 지출한 필요비와 유익비를 상환받을 수 있다. 유치권자는 선량한 관리자주의로서 목적물을 점유해야 하며, 소유자의 승낙 없이 유치물을 사용 또는 대여하거나 담보로 제공하지 못한다. 유치권자의 환가권: 경매권, 간이변제충당권 유치권의 소멸 유치물에 대한 점유를 상실할 경우 유치권은 소멸된다. 채무자의 일방적의사표시가 있으면 유치권은 소멸된다. 유치물 소유자는 상당한 담보를 제공하고 유치권의 소멸을 청구할 수 있다. 유치권은 담보물권의 일종이므로 피담보채권이 소멸하면 유치권도 소멸된다. 저당권의 의의저당권은 특정한 부동산을 담보로써 지정하여 둘 뿐, 그 점유를 채권자에게 옮기지 않고 담보제공자의 수중에 그대로 두고 채무자가 변제기에 채무를 변제하지 않으면 그 담보물을 경매하여 그 대금으로부터 다른 채권자에 우선하여 변제받을 수 있는 권리이다. 저당권의 특색 공시의 원칙: 저당권의 존재는 반드시 등기에 의하여 표시되지 않으면 안된다. 순위확정의 원칙: 동일한 목적물상의 여러 저당권들은 각각 확정된 순위를 보유하고 서로 침범하지 못한다. 순위승진의 원칙: 선순위 저당권 소멸시 후순위 저당권은 그 순위가 상승된다. 저당권의 법률적 성질 가치권으로서의 저당권: 저당권은 목적물이 지니는 교환가치를 배타적으로 지배하는 권리 약정담보물권: 저당권설정계약 필요 담보물권: 타물권, 부종성, 수반성, 불가분성, 물상대위성 저당권의 설정저당권은 부동산소유자와 채권자 사이의 저당권을 설정하기로 하는 계약(저당권설정계약)과 저당권 설정등기에 의하여 설정된다. 계약의 당사자 저당권자: 통상 채권자 저당권설정자: 채무자 또는 제3자(물상보증인)로 자신의 부동산을 담보로 제공, 그 위에 저당권이 설정되게 하는 사람 물상보증인: 채무자가아닌 저당권설정자로 물적 유한책임만을 진다. 저당권설정등기 등기는 저당권의 성립요건이다. 저당권의 목적물 등기 등록되는 것에 대해서만 설정 가능 부동산, 지상권, 전세권, 등기선박, 각종의 재단 등 저당권의 효력본질적 효력: 우선변제권 저당권의 우선변제권 행사방법은 담보권실행 경매다. 저당권의 목적물에 대하여 다른 채권자가 경매를 개시한 경우에는 저당권자는 우션변제권을 행사 할 수 있다. 효력 범위 목적부동산의 부합물과 종물, 종된 권리, 과실 피담보채권의 범위 원본과 이자, 채무불이행으로 인한 손해배상, 위약금, 저당권실행비용 등 근저당권계속적인 거래관계로부터 발생하여 증감변동하는 다수불특정의 채권을 장래의 결산기에 있어서 일정한 한도까지 담보하는 저당권이다. 근저당권 vs. 저당권 보통저당권은 피담보채권이 유효하게 존재하여야만 하는 등 부종성이 엄격한 반면 근저당권은 부종성이 완화 즉, 근저당권은 피담보채권이 확정되기 전까지는 피담보채권이 성립하지 않거나 소멸하더라도 근저당권의 효력에는 영향 없으며, 증감변동하는 채권을 일정한 한도, 즉 채권 최고액까지 담보한다. 근저당권의 유형 포괄근저당권 한정근저당 특정근저당 근저당권의 설정근저당권의 설정도 부동산물권변동의 일반원칙에 따라서 설정에 관한 합의(근저당권설정계약)와 등기에 의하여 이루어진다. 계약의 당사자 근저당권자: 채권자 근저당권설정자: 채무자 또는 제3자로 자신의 부동산을 담보로 제공 근저당권설정등기 등기절차는 보통저당권과 등기절차에 따르면 된다. 등기원인을 기재함에 있어 보통저당권과 구별하여 특히 근저당권임을 표시한다. 담보할 채권의 최고액을 반드시 등기한다. 근저당권의 효력본질적 효력: 우선변제권 (보통저당권과 같음) 임의경매신청을 함으로써 근저당권 실행 피담보채권의 확정시기는 근저당권자가 스스로 경매를 신청한 경우에는 다른 채권자 등이 경매신청을 한 경우와는 달리 경매신청시에 피담보채권이 확정된다. 효력 범위 목적부동산의 부합물과 종물, 종된 권리, 과실 피담보채권의 범위 확정된 피담보채권액이 최고액(설정액)을 넘는 경우에는 그 최고액까지 우선변제를 받을 수 있고, 반대로 최고액에 미달하고 있을 때에는 구체적인 확정액에 한하여 받을 수 있다. 결산기가 도래할 때까지의 사이에 일시적으로 채권액이 최고액을 초과하였어도 무방하고, 반대로 개개의 채권이 모두 소멸하여 채권이 일시적으로 0이 되는 일이있어도 근저당권은 소멸하지 않으며, 그 후에 새로 발생하는 개개의 채권의 총계를 최고액까지 담보한다. 공동저당공동저당은 부동산 위에 설정된 수개의 저당권을 통해서 피담보채권 전액을 우선하여 변제받을 수 있는 특수한 저당이다. 공동저당권은 수개의 부동산을 일괄하여 공동저당을 설정할 수 있는 담보채권의 결속기능과 그 부동산 중의 일부에 하자가 발생하였을 경우 다른 부동산으로부터 변제를 받을 수 있는 위험의 분산기능을 가지고 있다. 공동저당권의 설정 동일한 채권을 담보하기 위하여 수개의 부동산에 각각 저당권설정계약을 체결하고 등기를 함으로써 성립한다. 공동저당의 성립 수개의 목적물 위에 반드시 ‘동시에’ 설정될 필요는 없다. 공동저당의 목적물이 되는 수개의 저당권이 모두 채무자의 소유일 필요는 없다. 각 공동저당 목적물에 있어서 공동저당권의 순위가 모두 같아야 할 필요는 없다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"질권, 유치권","slug":"[LW] 질권-유치권","date":"2015-11-08T02:48:30.000Z","updated":"2018-05-20T12:36:43.372Z","comments":true,"path":"2015/11/08/[LW] 질권-유치권/","link":"","permalink":"http://melomance.github.io/2015/11/08/[LW] 질권-유치권/","excerpt":"","text":"질권의 의의질권은 채권자가 그 채권의 담보로 채무자 또는 제3자로부터 받은 물건을 유치하고 채무의 변제가 없을 때에는 그 물건을 매각하여 그 물건의 대금으로부터 다른 채권자에 우선하여 그의 채권의 변제를 받을 수 있는 권리이다. 질권 vs. 저당권 질권과 저당권은 당사자 간의 계약에 의하여 성립하나, 질권은 목적물의 점유를 담보설정자로부터 빼앗는 데 반하여, 저당권은 점유를 빼앗지 않고 계속하여 담보설정자가 점유하게 된다. 질권의 법률적 성질 목적물의 교환가치를 지배하는 권리 목적물을 유치하는 권리 우선변제 받을 권리 약정담보물권: 질권설정계약 필요 담보물권: 타물권, 수반성, 부종성, 불가분성, 물상대위성 동산질권동산질권의 설정 질권자: 채권자에 한함 질권설정자: 채무자에 한하지 않고 제3자라도 가능 질권자와 질권설정자의 합의와 목적물을 인도함으로써 효력 발생 동산질권의 효력 질권은 원본뿐 아니라 기타 일정 범위의 것에 미친다. 동산질권의 목적물은 질권설정계약에서 합의된 목적물로서 점유가 이전된 것 전부다. 질권자의 권리 동산질권자는 목적물을 유치할 권리가 있고 우션변제를 받을 권리가 있다. 단, 유질계약은 금지 (채무자 보호를 위함) 권리질권채권, 주식 등 양도할 수 있는 재산권은 유체물과 같이 질권의 목적이 될 수 있으며, 이러한 질권을 권리질권이라 한다. 질권 vs. 권리질권 질권은 토지나 건물이 아닌 동산을 대상으로 하는 권리지만, 권리질권의 목적물은 채권, 주식, 무체재사권이다. 권리질권의 성질 법률적 성질은 동산질권과 같다. 권리질권의 객체 양도가능한 재산권일 것 질권의 설정이 부적당하지 않은 권리일 것 유치권의 의의유치권은 타인의 물건을 점유하고 있는 자가 그 물건에 관하여 발생한 채권의 변제를 받을 때까지 그 물건을 유치하고, 채권의 변제를 간접적으로 강제하는 권리이다. 유치권은 법정담보물권으로서 우선변제권과 물상대위권이 없다. 유치권의 법률적 성질 물권 법정담보물권: 타인의 물건을 점유하는 자가 그 물건에 관하여 생긴 채권을 가지고 있으면 당연히 취득하는 권리 우선변제 받을 권리 없음, 물상대위성 없다. 담보물권: 부종성, 수반성, 불가분성 유치권의 성립 채권이 유치권의 목적물에 관하여 생긴 것일 것 채권이 변제기에 있을 것 유치권자는 물건 또는 유가증권의 점유자일 것 타인의 물건 또는 유가증권일 것 점유가 불법행위에 의하여 시작된 것이 아닐 것 등 유치권의 효력 유치권자는 목적물을 유치할 수 있고 과실수치권을 가진다. 유치권자는 유치물에 대해서 지출한 필요비와 유익비를 상환받을 수 있다. 유치권자는 선량한 관리자주의로서 목적물을 점유해야 하며, 소유자의 승낙 없이 유치물을 사용 또는 대여하거나 담보로 제공하지 못한다. 유치권자의 환가권: 경매권, 간이변제충당권 유치권의 소멸 유치물에 대한 점유를 상실할 경우 유치권은 소멸된다. 채무자의 일방적의사표시가 있으면 유치권은 소멸된다. 유치물 소유자는 상당한 담보를 제공하고 유치권의 소멸을 청구할 수 있다. 유치권은 담보물권의 일종이므로 피담보채권이 소멸하면 유치권도 소멸된다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"담보 및 보증","slug":"[LW] 담보 및 보증","date":"2015-11-07T13:00:00.000Z","updated":"2018-06-04T14:24:49.205Z","comments":true,"path":"2015/11/07/[LW] 담보 및 보증/","link":"","permalink":"http://melomance.github.io/2015/11/07/[LW] 담보 및 보증/","excerpt":"","text":"담보의 의의담보는 금전채권자는 금전채권의 일반적 효력으로는 만족하지 않고, 그것을 더 보강해서 채권의 실현을 확보하기 위한 수단이다. 즉, 채무자의 불이행이 있는 경우, 채권자평등의 원칙을 깨뜨려서 책임재산을 이루고 있는 재화 중 특정한 것의 교환가치로부터 다른 채권자에 우선하여 변제를 받거나, 책임재산(채무자의 전재산)의 범위를 채무자의 그것뿐만 아니라 다른 제3자의 그것까지 확대하여 제3자의 재산에 대하여도 강제집행을 할 수 있도록 하는 것이 담보이다. 채권자평등의 원칙 채권자가 여러 사람인 경우, 채무자의 재산을 경매하여 그 대금으로부터 모든 채권자의 채권 전액을 변제 그렇지 못한 경우 채권의 발생원인, 발생시기의 선후, 금액의 다소룰 불문하고 모두 평등하게 다룬다. 어느 한 채권자가 먼저 강제집행을 하여도 다른 채권자가 나타나서 배당요구를 하게 되면, 각 채권자의 채권액에 비례해서 분배하게 된다. (안분비례) 물적담보 책임재산을 이루고 있는 재화 중 어느 특정의 것을 가지고 채권의 담보에 충당하는 제도 물상보증인: 담보물이 채무자가 아닌 제3자 소유인 경우 그 담보 제공인 인적담보 채무자의 책임재산뿐만 아니라 다른 제3자의 책임재산도 추가하는 방법에 의한 담보제도 물적담보의 종류유치권 그 물건에 관하여 생긴 채권을 회수하기 위하여 그 물건을 유치하는 권리 법정담보물권 질권 약정담보물권 저당권 약정담보물권 양도담보 담보로 제공하려는 물건의 소유권 자체를 채무자로부터 채권자에게 이전 인적담보의 종류연대채무 수인의 채무자가 동일한 내용의 급부에 관하여 각각 독립해서 전부급부를 하여야 할 채무를 부담하고, 그 가운데 한 사람의 채무자가 전부급부를 하면 모든 채무자의 채무가 소멸하는 다수 당사자의 채무이다. 보증채무 주된 채무자 이외에 동일한 채무를 부담하는 종된 채무자를 두어서 주채무자의 채무를 담보한다. 보증인은 주채무자가 채무를 이행하지 못하는 경우 이를 대신 이행한다. (제2차적 책임) 보증인은 최고·검색의 항변권이 있다. 연대보증 보증인이 주채무자와 연대하여 보증채무를 지는 경우다. 연대보증인은 최고·검색의 항변권이 없다. (보충성 없음) 연대보증인은 주채무자와 같이 1차적 책임을 진다. 공동보증 동일 채무에 대하여 수인의 보증인이 있다. 각 보증인은 주채무액을 분할하여 각자 그 부담부분에 대하여서만 보증 채무를 진다. 근보증 계속적 거래관계에서 발생하는 증감변동하는 채권을 결산기에서 일정한도액까지 보증한다. 어음보증 어음의 발행인, 인수인, 배서인 등 어음상의 채무자를 위하여 보증하는 행위다. 부보증 보증채무를 다시 보증하는 것이다. 구상보증 주채무자는 보증인이 보증채무를 이행하고 구상권을 행사하면 이에 응해야 하는데, 이러한 구상권에 응할 채무에 대하여 보증하는 것이다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"채권의 양도 및 인수","slug":"[LW] 채권의 양도 및 인수","date":"2015-11-01T13:48:29.000Z","updated":"2018-05-20T12:36:43.373Z","comments":true,"path":"2015/11/01/[LW] 채권의 양도 및 인수/","link":"","permalink":"http://melomance.github.io/2015/11/01/[LW] 채권의 양도 및 인수/","excerpt":"","text":"채권양도채권양도란 채권을 그 내용의 동일성을 유지하면서 이전하는 계약을 말한다. 채권양도의 원인 대위로 인한 채권이전 (연대보증인 대위변제, 대출채권은 은행으로부터 보증인에게 이전) 법원명령에 의한 채권이전 유언으로 인한 채권이전 채권양도계약에 의한 채권이전 양도채권의 종류 지명채권: 채권자가 특정되어있는 채권 (예금채권 등) 지시채권: 증권상에 기명된 자, 또는 그가 배서에 의하여 지시하는 자가 채권자가 되는 채권 (어음, 기명주식 등) 무기명채권: 증권의 정당소지인이 채권자가 되는 채권 (자기앞수표, 당좌수표, 무기명주식 등) 채권양도의 제한 채권의 성질에 의한 제한 (고용계약상의 사용자의 채권 등) 당사자 간의 특약에 의한 제한 법률에 의한 제한 (각종 연금청구권, 보험금청구권 등) 지명채권양도 대항요건지명채권의 양도는 당사자 간의 합의로 효력이 발생하지만, 채무자나 제3자는 이를 모르고 있으므로 이들에게 채권양도를 대항하자면 일정한 대항요건이 필요하다. 채무자에 대한 대항요건 양도인의 통지 (양수인의 통지는 안됨) 채무자 자신의 승낙 (양도인 혹은 양수인 누구에게 해도 가능) 채무자 이외의 제3자에 대한 대항요건 서면으로 한 확정일자가 있는 통지 또는 승낙 채권 이중양도에서 적법한 양수인 채무자에 대한 확정일자 있는 증서에 의한 통지의 도달 선후에 의해서 판단한다. 먼저 제3자에 대한 대항요건을 취득한 양수인이 진정한 채권자 증권적 채권(지시채권, 무기명채권)의 양도지시채권 양도방법: 양도인이 증권에 배서하여 양수인에게 교부 대항요건은 따로 없고, 증권의 배서 교부가 곧 대항요건 무기명증권 양도방법: 양수인 앞으로 증권을 교부 대항요건은 따로 없고, 증권의 점유가 곧 대항요건 채무자 변경제도채무인수 채무의 그 동일성을 유지하면서 인수인에게 이전하는 것을 목적으로 하는 계약 면책적 채무인수 (종전채무자는 채무를 면하고 인수인만이 채무를 부담) 유효한 채무의 존재를 전제로 한다. 채권자·채무자인수인간의 3면계약, 채권자와 인수인간의 계약, 채무자와 인수인간의 계약이다. 인수인은 전채무자의 항변할 수 있는 사유로 채권자에게 항변 가능하다. 계약인수 계약관계의 동일성을 유지한 채 계약당사자 중 일방이 계약관계에서 발생한 권리·의무를 포함하여, 포괄적인 당사자의 지위를 제3자에게 이전하여 계약관계로부터 탈퇴하고, 그 제3자가 당사자의 지위를 승계하는 것을 목적으로 하는 계약이다. 이행인수 채무자의 채무를 이행할 것을 약정하는 채무자·인수인 사이의 계약이다. 인수인은 채무자에 대해서만 채무를 부담한다. 채권자는 인수인에 대해 채무의 이행을 청구할 수 있는 권리를 가지지 않는다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"노무이용 및 기타계약","slug":"[LW] 노무이용 및 기타계약","date":"2015-11-01T13:45:23.000Z","updated":"2018-05-20T12:36:43.361Z","comments":true,"path":"2015/11/01/[LW] 노무이용 및 기타계약/","link":"","permalink":"http://melomance.github.io/2015/11/01/[LW] 노무이용 및 기타계약/","excerpt":"","text":"임치임치는 당사자 일방이 상대방에 대하여 금전이나 유가증권, 기타 물건의 보관을 위탁하고, 상대방이 이를 승낙함으로써 성립하는 계약이다. 법적 성질 낙성계약, 편무계약, 무상계약, 불요식계약 (특약시 보수 청구 가능 : 쌍무계약, 유상계약) 소비임치소비임치는 수치인이 임치물을 소비하고 나중에 그것과 동종·동등·동량의 물건을 반환할 것을 목적으로 하는 임치를 말한다. 소비임치의 대표적인 예가 예금계약이다. 예금계약 예금자가 은행·기타 금융기관에 대하여 금전의 보관을 위임하고, 금융기관은 예입금의 소유권을 취득하여 이를 소비한 후 반환시기에 그와 동 금액을 반환한다. 위임위임은 위임인의 위탁에 의해 수임인이 위임사무를 처리해주는 것을 내용으로 하는 계약이다. 법적 성질 유상계약, 쌍무계약 (무보수 : 무상계약, 편무계약) 사무의 처리 수임인은 위임의 본지에 따라 선량한 관리자의 주의로써 위임사무를 처리해야 한다. 복임권의 제한 수임인은 위임인의 승낙이나 부득이한 사유 없이는 제3자로 하여금 자기에 갈음하여 위임사무를 처리하게 하지 못한다. 수임인 의무 보고의무 취득물 등의 인도·이전의무 손해배상책임 위임의 해지 각 당사자가 언제든지 해지 가능 당사자 일방이 부득이한 사유 없이 상대방이 불리한 시기에 계약을 해지한 때에는 그 손해를 배상하여야 한다. 도급도급이란 당사자 일방이 어떤 일을 완성할 것을 약정하고, 상대방이 그 일의 결과에 대하여 보수를 지급할 것을 약정함으로써 성립하는 계약이다. 법적 성질 유상계약, 쌍무계약 고용고용은 당사자 일방이 상대방에 대하여 노무를 제공할 것을 약정하고, 상대방이 이에 대하여 보수를 지급할 것을 약정함으로써 효력이 발생하는 계약이다. 법적 성질 낙성계약, 쌍무계약, 유상계약, 불요식계약 화해화해는 당사자가 서로 양보하여 당사자 사이의 분쟁을 중지할 것을 약정함으로써 성립하는 계약이다. 화해의 성립요건 당사자 사이의 분쟁 존재 당사자의 양보와 다툼을 그만두는 합의가 필요하다. 화해의 효과 당사자 사이에서 다투어졌던 법률관계는 확정된다. 당사자는 화해계약의 내용에 따라 의무를 부담하고 권리를 승인한다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"재산권 이전·이용계약","slug":"[LW] 재산권 이전 이용계약","date":"2015-11-01T07:41:00.000Z","updated":"2018-05-20T12:36:43.371Z","comments":true,"path":"2015/11/01/[LW] 재산권 이전 이용계약/","link":"","permalink":"http://melomance.github.io/2015/11/01/[LW] 재산권 이전 이용계약/","excerpt":"","text":"계약계약이란 두 사람이 하나 또는 다수의 채권 채무를 발생시킬 것을 약속으로 하는 합의이다. 계약성립 청약과 승낙의 합치 필요 침묵은 특별한 사정이 없는 한 거절로 해석된다 (상사계약에서는 승낙으로 해석되는 경우도 있다.) 보통거래약관 불특정 다수와의 계약관계를 전형적이고도 및 간편하게 처리하기 위함이다. 동 약관을 작성하여 이에 따라 계약을 체결한다 약관의 해석 객관적 합리적 해석의 원칙 작성자 불리의 원칙 (불명확조항 해석의 원칙) 제한적 해석의 원칙 (축소해석의 원칙) 개별약정우선의 원칙 증여증여는 당사자 일방이 자기 재산을 무상으로 상대방에게 수여하는 의사를 표시하고, 상대방이 그것을 승인함으로써 효력이 발생하는 계약을 말한다. 법적 성질 무상의 양도계약, 낙성계약, 불요식계약 증여의 종류 정기증여: 일정 시기마다 무상으로 일정한 급부를 하는 증여 부담부 증여: 수증자가 증여를 받는 동시에 일정한 급부를 할 채무를 부담하는 것을 조건으로 하는 증여 사인증여: 증여자의 사망으로 효력이 발생하는 증여 매매매매는 당사자 일방이 재산권을 상대방에게 이전할 것을 약정하고, 상대방이 그 대금을 지급할 것을 약정함으로써 효력이 생기는 계약을 말한다. 법적 성질 낙성계약, 유상계약, 쌍무계약, 불요식계약 매도인의 의무 소유권이전을 위한 등기 인도 부담 없는 소유권의 이전: 이전하여야 할 소유권은 제한물권이나 임차권의 부담이 없는 완전한 것이어야 한다. 타인소유물 매매의 경우: 이행기까지 목적물의 소유권을 취득하여 매수인에게 이전해주면 된다. 목적물 인도의무 부수의무: 물건 인도시까지 선량한 관리자의 주의로 보존할 의무 등 매수인의 의무 대금지급의무 대금의 이자 목적물 인수의무 매도인의 담보책임 매수인이 취득한 권리 또는 물건에 하자가 있는 경우에 매도인이 매수인에 대하여 부담하는 책임을 말한다. 대금감액청구권 계약해제권 손해배상청구권 경매에서의 담보책임 : 물건의 하자는 불인정, 권리의 하자에 대해서만 인정한다. 환매권 매도인이 매매계약과 동시에 환매할 권리를 보유한 때, 그 영수한 대금 및 매수인이 부담한 매매비용을 반환하고 그 목적물을 환매할 수 있다. 소비대차소비대차는 당사자 일방이 금전·기타의 대체물의 소유권을 상대방에게 이전할 것을 약정하고, 상대방은 동종·동질·동량의 물건을 반환할 것을 약정함으로써 성립하는 계약이다. 사용대차사용대차는 당사자 일방이 상대방에게 무상으로 사용·수익하게 하기 위하여 목적물을 인도할 것을 약정하고, 상대방은 이를 사용·수익한 후 그 물건을 반환할 것을 약정함으로써 성립하는 계약이다. 법적 성질 무상계약, 편무계약, 낙성계약 임대차임대차는 당사자 일방이 상대방에게 목적물을 사용·수익하게 할 것을 약정하고, 상대방이 이에 대하여 차임을 지급할 것을 약정함으로써 성립하는 계약이다. 법적 성질 쌍무계약, 낙성계약, 유상계약, 불요식계약 임대인 의무 목적물인도 의무 상태유지의무 담보책임 부담 등기협력 의무 안전배려의무 등 임차인 의무 차임지급의무 임차물의 보관·반환 의무 하자통지의무 등 대항력 대항력 있는 임차권: 대항력 취득요건을 갖춤으로써 제3자에 대한 효력을 인정받는 임차권 주택임대차는 미등기시라도 임차인이 주택의 인도와 주민등록을 마친 때, 그 다음날부터 제 3자에 대한 효력이 생긴다. 주택임차권의 보호 요건 주택임대차가 유요하게 존재 주택인도가 행해졌을 것 주민등록 또는 전입신고가 있을 것 임대차계약서에 확정일자를 갖출 것 등 임대차 존속기간 기간약정: 최장기의 제한은 없으나, 임대차의 존속기간을 영구·무한으로 약정하는 것은 안된다. 기간미약정: 임차인의 지위 보호를 위하여 최단기 2년 보장 임대차 종료 종료원인: 존속기간 만료, 해지통고, 해지 등 임대차기간의 약정이 없는 경우, 임대인 혹은 임차인 모두 계약 해지 통고 가능 임대인 해지: 해지통고시부터 6월 경과 후 효력 발생 임차인 해지: 해지통고시부터 1월 경과 후 효력 발생 동산: 누가 해지통고를 하든 5일 경과후 효력 발생","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"자연인의 변동","slug":"[LW] 자연인의 변동","date":"2015-10-20T16:04:02.000Z","updated":"2018-05-20T12:36:43.371Z","comments":true,"path":"2015/10/21/[LW] 자연인의 변동/","link":"","permalink":"http://melomance.github.io/2015/10/21/[LW] 자연인의 변동/","excerpt":"","text":"법정상속제도상속이란 사람이 사망한 때 피상속인(사망자)의 재산상 권리의무가 상속인에게 포괄승계되는 제도를 말한다. 상속개시의 원인 자연사망 인정사망 실종선고 상속개시의 장소 피상속인의 주소지 (재판관할 확정시 필요) 재산상속인상속인의 범위와 순위 (제1순위) 피상속인의 직계비속과 배우자 (제2순위) 피상속인의 직계존속과 배우자 (제3순위) 피상속인의 형제자매 (제4순위) 피상속인의 4촌 안의 방계혈족 대습상속제도 상속인이 될 직계비속 또는 형제자매가 상속개시 전에 사망하거나 상속결격자가 된 경우, 그에게 직계비속이 있으면 이들이 그에 갈음해서 상속인이 된다. e.g. A가 사망 A에게는 처 B와 아들 C, D 있음. 장남 C는 처 E와 딸 F를 남기고 사망 이 경우 C를 대신하여 E와 F가 상속받는 것이 대습상속 상속분 공동상속인 사이에 상속재산에 대한 각자의 배당률 지정상속분 피상속인의 유언에 따라 정해지는 상속분 유류분제도: 지정상속분을 제한하는 제도 (유족인 상속인에게 확보되어야 할 최소한의 상속분)피상속인의 직계비속과 배우자: 법정상속분의 1/2피상속인의 직계존속 및 형제자매: 법정상속분의 1/3 법정상속분 피상속인이 유언으로 상속분을 지정하지 않았을 때 법률의 규정에 따라 정해지는 상속분 원칙: 동 순위의 상속인이 여럿 있을 때 그 상속분은 같음 예외: 피상속인의 배우자의 상속분은 직계비속/존속과 함께 상속시 직계비속/존속 상속분에 5할을 가산 상속재산의 분할 방법 유언분할 협의분할 재판분할 조정분할 심판분할 상속의 효과포괄승계적 효과 피상속인의 재산에 관한 모든 권리의무를 상속인이 모두 승계한다. 적극재산 (부동산, 동산, 채권 등) ＋ 소극재산 (다른 사람에 대한 채무) 포괄승계 예외 포괄승계시 상속인에게 불리한 결과를 초래하는 경우 한정승인: 상속인이 상속재산을 한도로 소극재산을 책임지도록 한 제도 상속인은 상속으로 취득한 재산의 범위 내에서 변제책임이 있다. 상속개시를 안 날부터 3개월 내에 해야 한다. 상속포기: 상속재산에 속하는 모든 권리의무의 승계를 포기한다. 상속개시를 안 날부터 3개월 내에 하여야 한다. 상속포기는 소급효가 있다. 유증유증이란 유언에 의한 재산의 증여행위를 말한다. 포괄유증 상속재산의 전부 또는 일정 비율에 따른 유증 포괄수증인은 상속인과 같은 권리의무가 있다. 특정유증 상속재산 가운데 특정한 재산을 목적으로 하는 유증 유증의 목적물은 일단 상속인에게 귀속하며, 특정수증자는 상속인에게 유증의 이행을 청구할 수 있는 권리만을 가진다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"일반거래약관","slug":"[LW] 일반거래약관","date":"2015-10-20T12:49:18.000Z","updated":"2018-05-20T12:36:43.369Z","comments":true,"path":"2015/10/20/[LW] 일반거래약관/","link":"","permalink":"http://melomance.github.io/2015/10/20/[LW] 일반거래약관/","excerpt":"","text":"일반거래약관의 의의기업 또는 개인이 그 사업의 종류에 속하는 다수의 계약을 장차 체결할 때에, 계약에 포함시킬 목적으로 미리 일방적으로 작성한 정형적 계약내용 내지 계약조건을 말한다. 일반거래약관은 보통거래약관이라고도 한다. 약관에 대한 규제약관에 의한 거래에서 상대방은 기업이 작성한 계약내용을 그대로 따를 수 밖에 없으므로, 약관에 의한 거래에서는 이에 대한 규제가 필요하게 되었다. 규제 방법 입법적 규제 행정적 규제 사법적 규제 약관의 계약편입약관의 내용이 계약에 끌어들여져서 계약의 내용을 구성하는 것을 말한다. 약관의 계약편입요건 형식적 요건: 채용의 합의와 인지가능성의 부여 실질적 요건: 약관내용의 공정성 계약편입요건을 갖추지 못한 경우 금융기관은 약관내용을 계약내용으로 주장할 수 없다. 단, 고객이 주장하는 것은 무방하다. 원칙으로 계약 자체를 무효로 만드는 것은 아니다. 무효로 된 약관내용은 민법 등 사법에 의하여 보충 된다. 약관의 해석기본원칙 신의성실의 원칙 파생원칙 객관적 합리적 해석의 원칙 작성자 불리의 원칙 (불명확조항 해석의 원칙) 제한적 해석의 원칙 (축소해석의 원칙) 개별약정우선의 원칙","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"채권","slug":"[LW] 채권","date":"2015-10-19T15:28:00.000Z","updated":"2018-05-20T12:36:43.372Z","comments":true,"path":"2015/10/20/[LW] 채권/","link":"","permalink":"http://melomance.github.io/2015/10/20/[LW] 채권/","excerpt":"","text":"채권의 개요채권이란 특정인이 다른 특정인에 대하여 특정한 행위(지급 급부)를 청구할 수 있는 권리를 말하며, 이 채권에 대응하는 의무를 채무라고 한다. 채권·채무의 목적인 특정의 행위는 보통 이를 ‘급부’ 또는 지급이라고 한다. 여기서 급부란 채권자가 채무자에게 요구할 수 있는 일정한 행위를 말한다. 채권과 물권의 차이점 물권 채권 배타성존재 물건을 직접 지배하는 지배권이므로 배타성 존재 청구권에 지나지 않으므로 배타성 없음 채권성립 같은 물건에 대하여 같은 내용의 물권이 동시에 한 개 이상 성립 불가 (일물일권) 같은 채무자에 대하여 여러개의 채권 성립 가능 양도성 물권법정주의에 의하여 그 종류가 한정되고 등기 인도라는 공시방법 존재 계약자유의 원칙에 의거 당사자가 임의로 정할 수 있음 물권적청구권 물권은 누구에게나 주장할 수 있는 절대권이므로 그것이 침해되면 물권적청구권이 생김 (물권 &gt; 채권) 당사자 간에만 주장할 수 있는 상대권이므로, 그 침해는 불법행위는 되지만 물권적 청구권은 생기지 않음 채권의 목적 채권의 목적인 급부의 내용은 적법한 것이어야 한다. 급부는 사회적 타당성이 있어야 한다. 채권의 목적인 급부의 내용은 실현가능한 것이어야 한다. (불가능한 급부를 목적으로 하는 채권은 무효) 급부의 내용은 채권 성립시에 확정되거나 적어도 채무 이행시까지는 확정될 수 있어야 한다. 채권의 종류 특정물채권특정물의 인도를 목적으로 하는 채권 종류채권일정한 종류에 속하는 물건 중 일정한 수량의 물건의 인도를 목적으로 하는 채권 금전채권일정액의 금전의 지급을 목적으로 하는 채권 이자채권이자의 급부를 목적으로 하는 채권 선택채권여러 급부 중에서 선택에 의하여 정해지는 한 개의 급부를 목적으로 하는 채권 임의채권본래의 목적인 급부에 갈음하여 다른 급부를 할 수 있는 임의 채권 채권의 효력채무와 책임 책임없는 채무: 강제집행을 하지 않는 다는 특약을 한 경우의 채무 채무없는 책임: 물상보증인, 저당부동산의 제3취득자 (채무가 없음에도 책임만 부담) 채무불이행 형태 이행지체, 이행불능, 불완전이행, 채권자지체 채무불이행 규제 강제이행: 채무자의 채무이행이 가능함에도 불구하고 임의로 이행하지 않을 때 국가권력에 의하여 강제적으로 채권내용의 급부를 실현시킨다. 손해배상: 채무불이행이 채무자의 귀책사유로 인하여 채권자에게 손해가 발생한 경우 손해배상을 청구한다. 책임재산의 보전채무자의 일반재산은 채권자의 최후의 담보가 되므로 채무자가 그의 일반재산의 감소를 방치하고 고의로 일반재산을 감소하는 행위를 할 때 채권자는 자기의 채권을 확보하기 위하여 일정한 요건 아래 제3자의 재산에 간섭할 수 있다. 채권자대위권 채권 보전을 위하여 채무자의 권리를 대신하여 행사하는 권리 집행권언이 필요 없고 요건과 절차 등이 비교적 간단하다. e.g. 채무자가 제3자에 대한 채권이 있음에도 불구하고 이것을 받지 않고 채권자에 대한 변제 거부시 행사 채권자취소권 채무자가 채권자를 해함을 알면서 고의로 자기 재산을 감소시켜 채권자에 대한 변제가 불가능하게 된 때, 채권자가 채무자의 행위를 취소하고 원상회복을 법원에 청구할 수 있는 권리 채권자가 취소원인을 안 날로부터 1년, 법률행위 있은 날로부터 5년 내에 제기하여야 한다. e.g. 채무자가 기한이익 상실을 전후하여 자신의 재산을 친인척 앞으로 이전한 경우 다수당사자의 채권관계연대채무 수인의 채무자가 채무 전부를 각각 독립하여 변제할 의무가 있고, 그 채무자 중 한 사람의 변제로 다른 채무자도 변제를 면하게 된다. 연대보증 보증인이 주채무자와 연대하여 채무를 부담함으로써 주채무이행을 담보한다. 보통의 보증과 같으나 연대보증인은 최고·검색의 항변권이 없다. 주채무자가 채권자에 대하여 가지는 항변권과 구상권 등은 가지고 있다. 보증채무 주채무자가 그 채무를 이행하지 않을 때 이행의 책임을 부담하는 종적인 채무다. 즉, 주된 채무를 담보한다. 부종성, 보충성, 구상권을 가진다. 보증인은 최고·검색의 항변권을 가진다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"등기·등록제도","slug":"[LW] 등기등록제도","date":"2015-10-18T15:00:05.000Z","updated":"2018-05-20T12:36:43.365Z","comments":true,"path":"2015/10/19/[LW] 등기등록제도/","link":"","permalink":"http://melomance.github.io/2015/10/19/[LW] 등기등록제도/","excerpt":"","text":"부동산 등기제도등기제도란 국가기관이 법정 절차에 따라 등기부에 부동산에 관한 일정한 권리관계를 적는 일 또는 적어 놓은 것을 말한다. 부동산에 관한 권리 변동의 요건이 된다. 등기부 부동산에 관한 권리관계를 기재하는 공적장부 대장 과세 및 징세를 위한 공적장부 등기사항 부동산등기법상 등기사항 물건은 부동산 중 토지와 건물 등기부에 기재되어야 할 권리 부동산물권, 부동산임차권, 부동산환매권 권리질권, 채권담보권, 동산담보권 등기되어야 할 권리변동 부동산물권에 대한 보존/설정/이전/변경/처분의 제한 및 소멸 등기신청 등기권리자와 등기의무자가 공동으로 신청 저당권 설정: 저당권자(＝등기권리자), 저당권설정자(＝등기의무자) 거짓의 등기가 될 가능성이 없는 등 사정이 있으면 단독신청이 가능 등기효력 종국등기에는 권리변동적 효력, 대항적 효력, 순위확정적 효력, 추정적 효력 등이 인정 가등기에는 순위보전의 효력이 인정 부동산 외의 등기제도부동산물권 말고도 여러 등기나 등록 제도를 두고 있는 것은, 이러한 권리들을 특별히 보호를 하기 위해서 또는 다수 이해관계인이 관여할 가능성이 많아 이를 공시할 필요성도 있기 때문이다. 부동산을 목적으로 청구권의 등기 부동산임차권: 제3자 대항요건 부동산환매권: 제3자 대항요건 의제부동산의 등기·등록 의제부동산이란 물리적 성질은 동산이나 법률상 부동산과 같이 취급하는 것을 말한다(선박, 항공기, 자동차, 건설기계) 선박: 제3자 대항요건 항공기, 자동차, 건설기계: 효력발생요건 재단의 등기 기업경영에 필요한 토지, 건물 등 부동산과 생산설비인 기계, 기구 등의 동산 및 지상권, 임차권, 공업소유권 등의 권리를 포괄하여 하나의 통일적인 재단을 구성한 것이다. (하나의 부동산으로 취급) 효력발생요건 광업권·어업권등록 효력발생요건 상업등기상법의 규정에 의하여 상업등기부상에 하는 등기를 말한다. 상업등기사항 상법 등에서 정한 사항을 등기 종류: 절대적 등기사항, 상대적 등기사항, 창설적 등기사항, 해제적 등기사항 상업등기의 효력 일반적 효력: 소극적 공시력, 적극적 공시력 특수한 효력: 대항적 효력, 창설적 효력, 강화적 효력, 보완적 효력, 해제적 효력 추정력과 부실등기의 공신력이 인정","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"민·상법개요","slug":"[LW] 민상법개요","date":"2015-10-18T14:18:00.000Z","updated":"2018-05-20T12:36:43.367Z","comments":true,"path":"2015/10/18/[LW] 민상법개요/","link":"","permalink":"http://melomance.github.io/2015/10/18/[LW] 민상법개요/","excerpt":"","text":"민·상법의 의의민법은 사법이고, 일반법이며, 또한 실체법이다. 상법은 기업관계를 규율하는 법이며, 사법이며 실체법이지만, 민법의 특별법이다. 민·상법의 법원법원이란 외부에 나타난 법의 존재형식 또는 현상이다. 우리나라는 성문법주의를 택하므로 성문법이 제1차적인 법원이 되며, 불문법도 일부 법원이 된다. 법원의 적용순서 일반법 vs. 특별법: 특별법우선원칙 적용 성문법 vs. 관습법: 성문법우선원칙 적용 상사거래에서는 상사자치법이 가장 우선하는 법원이 된다. 민·상법의 기본원리근대민법의 기본원리 사유재산권 존중의 원칙 사적자치의 원칙 과실책임의 원칙 민법의 기본원리 공공복리를 최고이념으로 한다. 신의성실의 원칙 권리남용 금지의 원칙 거래안전 및 사회질서의 원칙에 의하여 제한되거나 수정되는 범위내 상법의 기본원리 기업의 건전한 발전을 도모한다. 기업 활동의 원활·확실화 기업의 유지·강화를 위한 각종 제도 도입 민·상법의 효력민법의 효력 그 효력이 생긴 때부터 그 이후에 발생한 사실에 대해서만 적용 모든 대한민국 국민에게 적용(대한민국 영토 내에 있는 외국인에게도 적용) 우리나라 전 영토 내에 그 효력이 미친다. 상법의 효력 특별한 규정이 없으면 상법시행 전에 생긴 사항에 대해서도 효력이 미친다. 사람에 대한 적용범위는 민법의 경우와 원칙으로 같다. 다만, 소상인에게는 일부규정의 적용이 배제된다. 장소에 관한 효력은 민법의 경우와 원칙으로 같다. 상법은 기업적 법률관계에 적용한다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Law","slug":"Finance/Law","permalink":"http://melomance.github.io/categories/Finance/Law/"}],"tags":[{"name":"민상법기초","slug":"민상법기초","permalink":"http://melomance.github.io/tags/민상법기초/"}]},{"title":"재무비율 산식 정리","slug":"[AC] 재무비율 산식 정리","date":"2015-07-10T06:09:00.000Z","updated":"2018-10-16T15:20:07.803Z","comments":true,"path":"2015/07/10/[AC] 재무비율 산식 정리/","link":"","permalink":"http://melomance.github.io/2015/07/10/[AC] 재무비율 산식 정리/","excerpt":"","text":"수익성 지표수익성 비율(Profitability Ratio)은 기업이 비용보다 많은 수익을 창출하는 능력, 즉 화폐적 효율성(monetary efficiency)을 의미한다. 매출액이나 투하자본에 대한 이익으로 표시되는데, 기업의 이익창출능력에 관한 정보를 제공한다. 수익성을 나타내는 비율은 기업의 경영성과를 나타내는 동태적인 비율로서 기업의 총괄적인 이익창출능력을 표시하는 지표이기 때문에 가장 중요시되는 비율이다. 매출액총이익률 (매출총이익 / 매출액) × 100 매출액영업이익률 (영업이익 / 매출액) × 100 매출액순이익률 (당기순이익 / 매출액) × 100 EBITDA 대 매출액 (EBITDA / 매출액) × 100 총자산순이익률(ROA) (당기순이익 / 총자산) × 100= 매출액순이익률 × 총자산회전율 자기자본순이익률(ROE) (당기순이익 / 총자본) × 100= 매출액순이익률 × 총자산회전율 × 재무레버리지 총자본세후순영업이익률(ROTC) (세후순영업이익 / 총자본) × 100 투하자본세후순영업이익률(ROIC) (세후순영업이익 / 투하자본) × 100 경제적부가가치(EVA) (ROIC － WACC) × 투하자본 유동성 지표 유동비율 (유동자산 / 유동부채) × 100 당좌비율 (당좌자산 / 유동부채) × 100 현금비율 (현금 및 현금성자산 / 유동부채) × 100 순운전자본 대 총자본 (순운전자본 / 총자본) × 100 재무안정성 지표안전성비율(Safety Ratio)은 기업의 채무상환능력과 타인자본의 의존도를 나타내는 비율이다. 기업의 채무상환능력의 측정과 타인자본의존도를 측정하는 비율로서 기업의 지급능력에 관한 정보를 제공한다. 부채비중 부채 / (부채＋자본) × 100 부채비율 (부채 / 자본) × 100 자기자본비율 자본 / (부채＋자본) × 100 차입금의존도 (총차입금 / 총자산) × 100 금융비용부담율 (금융비용 / 매출액) × 100 차입금평균이자율 (금융비용 / 총차입금) × 100 채무상환능력 지표 이자보상비율 (영업이익 / 금융비용) × 100 부채상환계수 (당기순이익＋비현금비용＋이자비용)/ (기초차입금×상환비율 ＋ 유동성장기부채 상환액×이자비용) 금융비용보상비율 (영업활동현금흐름＋금융비용) / 금융비용 × 100 현금보상비율 (영업활동현금흐름＋금융비용) / (단기차입금＋금융비용) × 100 영업활동 현금흐름 지표 영업활동현금흐름 / 유동부채영업활동현금흐름 / 총부채영업활동현금흐름 / 총차입금 EBITDA 관련 비율 EBITDA / 금융비용(EBITDA－자본적지출) / 금융비용총차입금 / EBITDA총차입금 / (EBITDA－자본적지출) 활동성 지표활동성비율(Activity Ratio)은 기업이 경영활동을 위하여 취득한 재무상태표상의 자산을 얼마나 활발하게 활용하였는지를 나타내주는 비율이다. 매출액을 특정 자산으로 나누어 회전율로 표시되는데, 기업의 자산활용 능력에 관한 정보를 제공한다. 수익성비율이 화폐적 효율성을 측정하는 비율인 반면에 활동성비율은 물리적 효율성을 측정하는 비율이다. 매출채권회전율 매출액 / 매출채권 매출채권회수기간 (매출채권 / 매출액) × 365일 재고자산회전율 매출액(또는 매출원가) / 재고자산 재고자산회전기간 (재고자산 / 매출액(또는 매출원가)) × 365일 매입채무회전율 매출액(또는 매출원가) / 매입채무 매입채무지급기간 (매입채무 / 매출액(또는 매출원가)) × 365일 자본배분 안정성 지표 고정비율 (비유동자산 / 자기자본) × 100 고정장기적합률 (비유동자산 / (자기자본＋비유동부채)) × 100 시장가치 지표시장가치비율(MVR: Market Value Ratio)이란 분석대상기업의 주식이 증권시장에서 어떻게 평가되고 있는지를 나타내는 지표이다. 주가수익률(PER) 주가 / 주당순이익(EPS) 주가장부가치비율(PBR) 주가 / 주당 순자산장부가치 토빈Q비율 주가 / 주당 순자산의 공정가치 배당성향 (배당금총액 / 당기순이익) × 100 배당률 [{(배당금 / 발행주식 총수) 또는 주당배당금} / 주당액면가] × 100 배당수익률 주당배당금 / 주가 주당현금흐름 (Operating Cash Flow－우선주배당금) / 가중평균 주가현금흐름비율(PCR) 평균주가 / 주당현금흐름 배당지급능력배수 영업활동 현금흐름 / 현금배당금 성장성 지표성장성비율(Growth Ratio)은 일정기간동안 기업의 재무상태나 경영성과가 얼마만큼 향상되었는지를 나타내는 비율로서 기업의 향후 수익창출능력, 성장잠재력, 시장에서의 경쟁력 등을 표시해주는 지표이다. 기업의 외형이나 수익면에서 상대적 지위가 향상되는 정도를 나타내므로 기업의 성장잠재력에 관한 정보를 제공한다. 매출액증가율 (매출액증감액 / 전기 매출액) × 100 유형자산증가율 (유형자산증감액 / 전기말 유형자산) × 100 총자산증가율 (총자산증감액 / 전기말 총자산) × 100 자기자본증가율 자기자본증감액 / 전기말 자기자본) × 100 지속가능성장률 (1－배당성향) × ROE기초= 매출액순이익률×총자산회전율×(총자산/기초자본)×내부유보율 생산성 지표 부가가치율 (부가가치 / 매출액) × 100 1인당 부가가치 부가가치 / 종업원수= 부가가치율 × 종업원 1인당 매출액 자본생산성 부가가치율 × 자본회전율 설비투자효율 (부가가치 / (유형자산－건설중인자산)) × 100 기계투자효율 (부가가치 / 기계장치) × 100 노동장비율 (유형자산－건설중인자산) / 종업원수 기계장비율 기계장치 / 종업원수 노동생산성 자본생산성 × 자본집약도설비투자효율 × 노동장비율기계투자효율 × 기계장비율","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"수익과 비용의 인식 및 측정","slug":"[AC] 수익과비용의 인식 및 측정","date":"2015-03-18T15:04:00.000Z","updated":"2018-08-15T13:51:22.286Z","comments":true,"path":"2015/03/19/[AC] 수익과비용의 인식 및 측정/","link":"","permalink":"http://melomance.github.io/2015/03/19/[AC] 수익과비용의 인식 및 측정/","excerpt":"","text":"수익과 비용의 인식방법현금주의현금의 수납이나 지출이 있을 때 관련사건을 인식·기록하는 방법이다. 발생주의경제적 상태에 변화를 주는 사건이나 여건의 변화가 있을 때 인식·기록하는 방법이다. 수익의 분류수익은 기업이 주영업활동에서 발생하는 영업수익과 그렇지 않은 영업외수익으로 나눌 수 있다. 영업수익은 매출이라는 과목을 사용하기도 하는데 영업수익으로 분류할지 여부는 기업의 주 영업목적이 무엇이냐에 따라 다르다. 영업외수익 계정과목 설명 이자수익 $\\quad$ 예금이나 대여금에서 발생하는 이자 배당금수익 $\\quad$ 주식이나 출자금 등의 투자에서 분배받은 이익 임대료 $\\quad$ 부동산 또는 동산을 타인에게 임대하고 받은 대가 단기투자자산처분이익 $\\quad$ 단기투자자산을 처분함에 따라 발생하는 이익 단기투자자산평가이익 $\\quad$ 단기투자자산을 시가로 평가함에 따라 발생하는 이익 외환차익 $\\quad$ 외화자산의 회수나 외화부채의 상환시에 발생하는 이익 외화환산이익 $\\quad$ 외화자산이나 외화부채의 기말평가시에 발생하는 이익 지분법이익 $\\quad$ 지분법적용투자주식의 지분법 평가에서 발새하는 이익 유형자산처분이익 $\\quad$ 유형자산을 처분함에 따라 발생하는 이익 사채상환이익 $\\quad$ 사채를 상환함에 따라 발생하는 이익 잡이익 $\\quad$ 금액적으로 중요하지 않거나 그 항목이 구체적으로 밝혀지지 않은 이익 비용의 분류주영업활동에서 발생되는 수익에 부수되어 발생되는 영업비용(매출원가, 판매비와 관리비)과 그렇지 않은 영업외비용 및 법인세비용으로 나눌 수 있다. 영업외비용 계정과목 설명 이자비용 $\\quad$ 외부에서 조달한 타인자본에 대하여 지급하는 이자와 할인료 기타의 대손상각비 $\\quad$ 영업활동에서 발생하지 아니한 채권에 대한 대손상각비 단기투자자산처분손실 $\\quad$ 단기투자자산을 처분함에 따라 발생하는 손실 단기투자자산평가손실 $\\quad$ 단기투자자산을 시가로 평가함에 따라 발생하는 손실 외환차손 $\\quad$ 외화자산의 회수나 외화부채의 상환시에 발생하는 손실 외환환산손실 $\\quad$ 외화자산이나 외화부채의 기말평가시에 발생하는 손실 지분법손실 $\\quad$ 지분법 적용 투자주식의 지분법 평가에서 발생하는 손실 유형자산처분손실 $\\quad$ 유형자산을 처분함에 따라 발생하는 손실 사채상환손실 $\\quad$ 사채를 상환함에 따라 발생하는 손실 기부금 $\\quad$ 무상으로 증여하는 금전, 기타 자산의 가액 잡손실 $\\quad$ 금액적으로 중요하지 않거나 그 항목이 구체적으로 밝혀지지 않은 손실 이익의 분류이익은 수익에서 비용을 차감한 것을 말하는데, 기업회계에서는 이익을 다양하게 구분하고 있다. 계정과목 설명 매출총이익 $\\quad$ 매출 － 매출원가 영업이익 $\\quad$ (매출총이익 － 판매비와 관리비) or (영업수익 － 영업비용) 법인세비용차감전순이익 $\\quad$ 영업이익 $\\pm$ 영업외수익(비용) 당기순이익 $\\quad$ 법인세비용차감전순이익 － 법인세비용 주당이익(EPS) $\\quad$ 당기순이익 $\\div$ 주식수 외화환산환율변동효과 Flow 효과: 손익계산서 항목에 의해 발생한다. 보유손익효과: 재무상태표의 자산과 부채의 보유에 발생한다. 환율변동에 따른 매출액 증대부분과 실질적인 매출 증대부분을 구분해야 한다. 해당 기업이 보유중인 자산·부채 중 어느 항목이 환리스크에 노출되어 있는지 분석이 필요하다. 외화환산의 방법 화폐성 항목: 환율변동에 영향을 받는 항목이다. (현금, 매출채권, 매입채무 등) 비화폐성 항목: 환율변동에 영향을 받지 않는 항목이다. (화폐성 자산·부채를 제외한 모든 항목) 외화환산시 회계처리 보유중인 외화자산·부채의 장부가액과 기말 환율과의 차이를 외화환산손익으로 처리한다. 장부가액과 결제일의 실제지급액과의 차이는 외환차손익으로 처리한다. Example A기업은 미국에 위치한 B기업에 $100에 해당하는 물건을 2014년 11월 1일에 수출하였으며, 수출대금의 결제일은 2015년 2월 1일이다. 2014.11.01자 환율: USD / KRW = 1000 2014.12.31자 환율: USD / KRW = 1100 2015.02.01자 환율: USD / KRW = 1000 분개 $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ 1. (차) 매출채권 ￦100,000 $\\qquad$ (대) 매출 ￦100,000 2. (차) 매출채권 ￦10,000 $\\qquad$ (대) 외화환산이익 ￦10,000 3. (차) 현금 ￦100,000 $\\qquad$ (대) 매출채권 ￦110,000 (차) 외환차손 ￦10,000 $\\qquad$ $\\qquad$","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"자본","slug":"[AC] 자본","date":"2015-02-09T15:22:33.000Z","updated":"2018-08-15T13:15:16.083Z","comments":true,"path":"2015/02/10/[AC] 자본/","link":"","permalink":"http://melomance.github.io/2015/02/10/[AC] 자본/","excerpt":"","text":"자본의 분류자본은 자산을 구입 또는 투자하기 위한 조달수단이다. 그러므로 총자산과 총자본은 항상 일치한다. 총자본은 타인자본과 자기자본으로 다시 구분할 수 있는데, 외부차입금은 타인자본에 포함된다. 자본 자본금 자본잉여금 주식발행초과금 감자차익 기타자본잉여금 자본조정 자기주식 주식할인발행차금 주식매수선택권 출자전환채무 기타포괄손익누계액 매도가능증권평가손익 현금흐름위험회피 파생상품평가손익 해외사업환산손익 재평가잉여금 이익잉여금 이익준비금 임의적립금 미처분이익잉여금(또는 미처리결손금) 자본금자본금은 발행주식총수의 액면총액으로 표시된다. $$자본금 = \\text{1주당 액면가액} \\times 발행주식 총수$$ 주식의 종류 보통주: 기본적인 권리를 나타내는 주식 회사의 경영에 비례적으로 참가할 권리(의결권) 회사의 손익배분에 비례적으로 참가할 권리(이익분배권) 회사의 청산시에 잔여자산배분에 비례적으로 참가할 권리 분배권(잔여재산 분배권) 회사의 신주발행에 대하여 비례적으로 참가할 권리(주식선매권) 우선주: 특정사항에 관해서 보통주에 대해 우선적인 권리가 부여된 주식 일반적으로 보통주에 앞서 우선적으로 이익배당 경영참가권인 의결권은 일반적으로 배제 자본금의 증가(주식의 발행)회사가 주식을 발행하여 일정의 자본금을 늘리는 것을 증자라고 한다. 주식발행은 유상증자와 무상증자로 구분된다. 유상증자: 실질적 증자 회사주식의 증가와 함께 실질적인 재산의 증가를 가져오는 형태이다. 안정성 비율(부채비율) 및 수익성 비율(ROA) 일시 감소 무상증자: 형식적 증자 사내유보금으로 주식자본을 증가시킨 후 동액만큼의 신주발행을 통하여 주주에게 무상배정한다. 자본항목에만 영향을 미쳐 자기자본의 총액이 변하지 않는다. 기업이 신용에는 아무런 영향을 미치지 않는다. 수권자본제도: 주주총회에서 주식의 총수를 결정하고 그 범위 내에서 이사회의 결의에 주식을 발행 $$주식발행초과금(주식할인발행차금) = 발행가액 - 액면가액$$ 구분 할증발행 할인발행 의의 $\\qquad$ 액면가를 초과하여 발행(일반적) $\\qquad$ 액면가 미만으로 발행 회계처리 $\\qquad$ 액면가 해당 부분은 자본금으로 기록발행가액과 액면가액의 차이는 주식발행 초과금(자본잉여금) $\\qquad$ 좌동발행가액과 액면가액의 차이는 주식할인 발행 차금(자본조정) 주식할인발행차금 $\\qquad$ 관계없음 $\\qquad$ 이익잉여금 처분 항목 주식발행 회계처리 Example A기업은 2013년 1월 1일에 다음과 같은 조건으로 주식을 발행하였다.(액면가 ￦5,000, 보통주 100주, 주당 ￦6,800) B기업은 2013년 7월 1일에 다음과 같은 조건으로 주식을 발행하였다.(액면가 ￦5,000, 우선주 100주, 주당 ￦4,400) 분개(A기업 주식 할증발행(2013.01.01)) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ 1. (차) 현금 ￦680,000 $\\qquad$ (대) 자본금-보통주 ￦500,000 $\\qquad$ (대) 주식발행초과금용 ￦180,000 분개(B기업 주식 할인발행(2013.07.01)) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ 2. (차) 현금 ￦440,000 $\\qquad$ (대) 자본금-보통주 ￦500,000 (차) 주식할인발행차금 ￦60,000 $\\qquad$ $\\quad$ 분개(B기업 할인발행 차금 상각(2013.12.31)) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ 2. (차) 이익잉여금 ￦20,000 $\\qquad$ (대) 주식할인발행차금 ￦20,000 자본금의 감소자본 총액을 줄이는 것을 감자라고 한다. 자본금을 감소시키는 방법에는 유상감자와 무상감자가 있다. 유상감자: 실질적 감자 자본 감소에 대하여 차액만큼의 돈을 지분 비율에 따라 주주들에게 지급 실질적 자산 감소를 초래 채권자에 대한 담보액이 감소하기 때문에 상법상 채권자 동의 필요 무상감자: 형식적 감자 주주들이 어떠한 보상도 받지 못하고 감자 비율만큼의 주식수를 잃는 것 자본금을 줄이지만 주주에게 보상을 하지 않아 실질적 자산감소가 일어나지 않음 채권자에 대한 담보액은 감소하지 않지만 상법상 채권자 동의 필요 유상감자시 기 발행된 주식을 재취득하여야 한다. (감자차익(손) 발생) $$ 감자차익(손) = 재취득가격 － 액면가액 $$ 경우 계정과목 분류 재취득가격 ＜ 액면가액 감자차익 자본잉여금 재취득가격 ＞ 액면가액 감자차손 자본조정후 이익잉여금과 상계 자기주식기업이 이미 발행한 주식을 다시 취득하여 소각이나 재매각하려고 보유중인 주식을 말한다. 경우 계정과목 분류 처분가격 ＜ 취득가액 자기주식처분손실 자본조정후 이익잉여금과 상계 처분가격 &gt; 취득가액 자기주식처분이익 자본잉여금 자본잉여금자본잉여금이란 증자활동이나 감자활동 및 기타 자본과 관련된 거래에서 발생하는 잉여금을 말한다. 자본잉여금의 사용과 처분은 기업회계 이외에도 상법에 의해 엄격한 제한을 받고 원칙적으로 자본금 전입과 이월결손금 보전을 위해서만 사용가능하다. 자본조정자본조정이란 자본잉여금이나 이익잉여금으로 분류하기는 어려우나 성질상 자본에 가감할 항목이다. 기타포괄손익누계액자본거래에서 발생하는 일시적인 성격을 가지고 있는 항목은 자본조정으로 처리하고 있는 반면, 손익거래에서 발생하는 일시적인 성격을 가지고 있는 항목은 기타포괄손익누계액으로 처리하고 있다. 이익잉여금이익잉여금은 이익 창출 활동에 의하여 획득된 이익 중 배당금 등으로 사외에 유출되거나 납입 자본 계정에 대체되지 않고 사내에 유보된 부분이다. $$\\underbrace{이익잉여금 = \\sum_{t=0}^n [(수익-비용) - 사외유출 - 납입자본대체]}_{t = 0: \\text{ 회사설립시점} \\\\ n: \\text{ 이익잉여금 계산시점}}$$","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"부채의 평가","slug":"[AC] 부채의 평가","date":"2015-01-04T15:19:00.000Z","updated":"2018-10-20T15:58:57.886Z","comments":true,"path":"2015/01/05/[AC] 부채의 평가/","link":"","permalink":"http://melomance.github.io/2015/01/05/[AC] 부채의 평가/","excerpt":"","text":"부채의 분류부채는 불확실성의 존재여부에 따라 확정부채와 우발부채로, 채무를 이행하여야 할 시기에 따라 유동부채와 비유동부채로 구분하고 있다. 미지급금: 매입채무와 달리 상거래 이외의 거래에서 발생한 채무 미지급비용: 기간 경과에 의해 이미 발생한 비용으로서 회계연도말 현재 지급하지 않은 금액 선수수익: 수익으로 이미 받은 금액 중 차기 이후의 수익에 속하는 금액 (선수이자, 선수임대료) 예수금: 일시적인 자금을 받아 보관한 것으로서 다시 본인 또는 제3자에게 지급해야 할 금액 (근로소득세) 부채 유동부채 매입채무 선수금 단기차입금 유동성장기차입부채 기타유동부채 미지급금 미지급비용 선수수익 예수금 비유동부채 장기차입부채 사채 장기성지급어음 퇴직급여충당부채 부채의 평가방법미래현금흐름의 현재가치 미래현금흐름의 현재가치란 부채에서 발생하는 현금흐름을 현재가치로 할인하여 평가한 것이다. 유동부채는 그 기간이 짧아 만기상환금액으로 평가한다. 현재가치를 구하는 공식은 다음과 같다. $$\\underbrace{PV_0 = \\sum_{t=1}^n \\frac{CF_t}{(1+r)^t}}_{PV_0: \\text{ 현재시점의 가치} \\\\ CF_t: \\text{ t기의 현금흐름액} \\\\ r: \\text{ 할인율} \\\\ n: \\text{ 내용년수}}$$ 사채사채(bond)란 대중으로부터 자금을 조달할 목적으로 지정된 만기일에 정해진 금액(액면가)을 지급하고 액면가에 일정한 이자율을 곱한 이자를 정기적으로 지급할 것을 약속한 유가증권이다. 사채의 발행가액은 사채의 미래현금흐름을 발행당시 시장이자율로 할인한 현재가치에 의해 결정된다. 액면취득 할증취득 할인취득 액면이자율 = 시장이자율 액면이자율 ＞시장이자율 액면이자율 ＜ 시장이자율 Example A기업은 2013년 1월 1일에 회사채를 다음과 같은 조건으로 발행하였다. (할증발행) 액면가 표시(액면)이자율 만기 취득시 시장이자율 이자지급일 ￦100,000 10% 3년 8% 매년말 취득가액 산정 $$\\frac{10,000}{(1+8\\%)^1} + \\frac{10,000}{(1+8\\%)^2} + \\frac{110,000}{(1+8\\%)^3} = 105,154$$ 상각표 작성 사채이자비용 = 장부금액 $\\times$ 시장이자율(8%) 사채장부금액 = 기초장부금액 $\\pm$ 당기상각액 ($+$ 사채할인비용, $-$ 사채할증발행) 일자 현금이자 (A) 사채이자비용 (B) 당기상각액 (B-A) 사채장부금액 2013.01.01 - - - ￦105,154 2013.12.31 ￦10,000 ￦8,412 ￦1,588 ￦103,567 2014.12.31 ￦10,000 ￦8,285 ￦1,715 ￦101,852 2015.12.31 ￦10,000 ￦8,148 ￦1,852 ￦100,000 사채발행 회계처리 분개(취득시) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 현금 ￦105,154 $\\qquad$ (대) 사채 ￦100,000 $\\qquad$ (대) 사채할증발행차금 ￦5,154 분개(2013.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 사채이자비용 ￦8,412 $\\qquad$ (대) 현금 ￦10,000 (차) 사채할증발행차금 ￦1,588 $\\qquad$ $\\quad$ 분개(2014.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 사채이자비용 ￦8,285 $\\qquad$ (대) 현금 ￦10,000 (차) 사채할증발행차금 ￦1,715 $\\qquad$ $\\quad$ 분개(2015.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 사채이자비용 ￦8,148 $\\qquad$ (대) 현금 ￦10,000 (차) 사채할증발행차금 ￦1,852 $\\qquad$ $\\quad$ 분개(만기일) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 사채 ￦100,000 $\\qquad$ (대) 현금 ￦100,000 퇴직급여충당부채퇴직급여는 회사의 임직원에 대해 퇴직시 지급하는 금액으로, 근로자퇴직급여보장법에서는 의무적으로 한도를 설정하여 지급하도록 요구하고 있다. 퇴직연금제도회사가 퇴직금을 자체적으로 보유하지 않고 퇴직금을 지급할 목적으로 금융기관에 퇴직금을 예치하여 금융기관을 통해 퇴직한 근로자에게 퇴직금을 연금이나 일시금으로 지급하는 제도이다. 확정급여형(DB: Defined Benefit)근로자의 퇴직연금이 사전에 정해지고 기업이 적립금 운용의 책임을 진다. 확정기여형(DC: Defined Contribution)기업의 부담금이 사전에 정해지고 근로자가 적립금 운용의 책임을 진다. 확정급여형 회계처리K-IFRS기준에서는 퇴직율, 미래 임금상승율, 사망률, 할인율 등을 감안한 보험수리적 기법을 사용하여 퇴직급여충당부채를 추정한다. 분개(퇴직급여충당부채 계상시) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 퇴직급여 XXX $\\qquad$ (대) 퇴직급여충당부채 XXX 분개(퇴직금 지급시) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 퇴직급여충당부채 XXX $\\qquad$ (대) 현금 XXX 확정기여형 회계처리당해 회계기간에 대하여 기업이 납부하여야 할 부담금을 퇴직급여(비용)로 인식한다. $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 퇴직급여 XXX $\\qquad$ (대) 현금 XXX $\\qquad$ (대) 미지급비용 XXX 충당부채와 우발부채우발상황을 미래사건의 발생가능성의 정도에 따라 3가지로 구분하고 각각에 대하여 손실금액을 합리적으로 추정할 수 있는지의 여부에 따라 회계방법을 달리한다. 단, 중요한 계류중인 소송사건과 보증제공사항은 의무적으로 주석 공시해야 한다. 미래사건의 발생가능성 신뢰성 있게 추정가능 추정 불가능 가능성이 매우 높음 충당부채 인식 우발부채로 주석공시 가능성이 어느정도 있음 우발부채로 주석공시 우발부채로 주석공시 가능성이 거의 없음 공시하지 않음 공시하지 않음 부외부채부외부채란 재무제표에 계상되지 않은 우발부채로 일반적으로 주석사항에 표시된 우발부채를 말한다. 운용리스 리스란 기업이 자산을 구입하지 않고도 계약관게를 통하여 특정기간 동안 대가를 지불하고 해당 자산을 이용하는 것이다. 금융리스는 장부에 금융리스 차입금이 계상되는 반면 운용리스는 장부에 부채(차입금)로 계상되지 않는다. 운용리스는 임차와 동일하기 때문에 해당 자산을 사용하면서 리스료(임대료)를 지급할 때 비용으로 계상된다. 향후 리스료를 이자율로 할인한 금액을 부채로 계상하여 분석한다. 매출채권의 매각 매출채권의 매각금액 중 만기 미도래 금액을 부외부채로 간주하여 부채에 가산시켜 분석한다. 상환청구권이 있는 매출채권의 매각은 사실상 매각거래가 아닌 차입거래이다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"비유동자산의 평가","slug":"[AC] 비유동자산의 평가","date":"2014-10-10T15:12:00.000Z","updated":"2018-10-20T15:57:43.766Z","comments":true,"path":"2014/10/11/[AC] 비유동자산의 평가/","link":"","permalink":"http://melomance.github.io/2014/10/11/[AC] 비유동자산의 평가/","excerpt":"","text":"자산의 분류기업의 자산은 유동성에 따라 유동자산과 비유동자산으로 구분된다. 비유동자산은 1년 이상의 영업기간 동안에 사용되어지는 자원이기 때문에 비유동자산을 많이 보유하고 있는 기업은 유동성이 취약하게 되고 단기적으로 차입금 상환이 곤란해질 수도 있고 자산가치의 변동에 영향을 많이 받을 수도 있다. 비유동자산은 기업회계기준상 투자자산, 유형자산, 무형자산, 기타 비유동자산으로 분류된다. 자산 유동자산 당좌자산 현금및현금성자산 단기투자자산 매출채권 이연법인세자산 기타의당좌자산(선급금, 선급비용, 미수금, 미수수익) 재고자산 비유동자산 투자자산 유형자산 무형자산 기타비유동자산 투자자산의 의의 및 유가증권의 분류기업은 운전자금을 제외한 여유자금이 있으면 보다 높은 수익을 얻기 위해 이를 활용한다. 이렇게 취득한 자산을 투자자산이라고 하는데, 유가증권, 영업활동에 사용되지 않는 부동산, 설비확장 및 채무상환 등에 사용할 특정목적의 예금을 포함한다. 여기서 유가증권이란 자본시장과 금융투자업에 관한 법률상의 유가증권으로서 자본시장에서 거래되는 지분증권과 채무증권을 의미한다. 유가증권의 종류에 따른 분류 지분증권회사, 조합 또는 기금 등의 순자산에 대한 소유지분(또는 소유지분을 취득(처분)할 수 있는 권리)을 나타내는 유가증권이다. 보통주, 우선주, 수익증권, 자산유동화 출자증권, 옵션 등이 해당된다. 채무증권발행자에 대하여 금전을 청구할 수 있는 권리를 표시하는 유가증권이다. 국채, 공채, 회사채, 자산유동화 채권 등이 해당된다. 유가증권의 취득목적에 따른 분류 단기매매증권단기간 내의 매매차익을 목적으로 취득한 유가증권으로 매수와 매도가 적극적이고 빈번하게 이루어지는 경우 만기보유증권만기가 확정된 채무증권으로 만기까지 보유할 목적과 능력이 있는 경우 매도가능증권만기보유증권이나 단기매매증권으로 분류되지 않는 경우 지분법적용투자주식피투자회사에 유의적인 영향력을 행사할 수 있는 경우※ 유의적인 영향력이란 투자회사가 피투자회사의 재무 또는 영업에 관한 의사결정에 실질적인 영향을 미칠 수 있는 능력을 의미한다. 투자회사가 직·간접적으로 피투자회사의 의결권 있는 주식의 20%이상을 보유하고 있는 경우, 명백한 반증이 있는 경우를 제외하고는 유의적인 영향력이 있는 것으로 본다. 유가증권의 평가방법여느 자산의 평가와 동일하게 유가증권에서도 평가된 가액과 장부금액과의 차이를 회계처리하는게 일반적인데 유가증권을 평가하는 방법에 따라 다음과 같이 세 가지로 구분한다. 원가법취득원가를 평가가액으로 보는 방법이다. 공정가치법시장에서 형성된 가격을 평가가액으로 보는 방법이다. 지분법피투자회사의 순자산가액(=자산-부채)을 평가가액으로 보는 방법이다. 종류 형태 평가방법 평가차이 계상과목 단기매매증권 관계 없음 공정가치법 단기매매증권평가이익(손실) 영업외수익(비용) 매도가능증권 시장성 있음시장성 없음 공정가치법원가법 매도가능증권평가이익(손실)- 기타포괄손익누계액- 만기보유증권 - 원가법 - - 지분법적용투자주식 - 지분법 지분법이익(손실)지분법자본변동 영업외수익(비용)기타포괄손익누계액 공정가치법과 지분법을 사용하게 되면 장부금액과 평가금액간의 차이가 발생하게 되는데, 각각의 평가방법에 따라 평가 계상 과목이 다르다. 지분증권은 아무리 시장성이 있다 하더라도 피투자회사에 재무 또는 영업에 관한 의사결정에 유의적인 영향력을 행사할 수 있는 주식이라면 지분법을 쓴다. 단기매매증권평가이익(손실)과 지분법이익(손실)만이 손익계산서상 영업외수익(비용)으로 계상되기 때문에 당기손익에 영향을 미치지만 매도가능증권평가이익(손실)은 당기손익에는 영향을 미치지 않는다. 유가증권(지분증권, 채무증권)의 평가지분증권의 지분법 평가원가법을 채택하고 있다면 단순히 지분증권으로부터 배당금수익만이 수익으로 발생하게 된다. 그런데 배당금으로만 투자수익을 측정하는 것은 적절하지 않다. 그 이유는 피투자회사에 대해 유의적인 영향력을 행사할 수 있다면, 투자회사가 이익을 부풀리기 위해 피투자회사에 배당을 증대시킬 것을 충분히 요구할 수 있기 때문이다. 따라서 지분증권은 피투자회사의 순자산(자기자본)가액을 공정가치로 보고 순자산가액이 변동할 때 회계처리를 하며, 피투자회사의 자기자본의 원천에 따라 평가차액의 계정과목을 다음과 같이 달리한다. 순자산가액의 변동원천 당기순이익 이익잉여금 자본잉여금 자본조정 회계처리 계정과목 지분법손익(당기손익) 이익잉여금(or 당기손익) 지분법자본변동(기타포괄손익누계액) 지분법자본변동(기타포괄손익누계액) 채무증권의 평가채권에서는 고정된 수익이 발생하고 그 금액을 합리적으로 예측 가능하기 때문에, 채권의 가치는 채권에서 발생하는 미래현금흐름을 시장이자율로 할인하면 채권의 가격이 산출된다. 채권에서 발생하는 미래현금흐름은 채권의 권면액과 액면이자율에 의해 결정되며, 취득시의 액면이자율과 시장이자율의 관계에 따라 다음과 같은 유형이 결정된다. 액면이자율과 시장이자율의 관계에 따른 채권가격 액면이자율로 계산한 금액을 이자수익으로 계산하지 않는다. 시장이자율로 계산한 금액을 이자수익으로 계산하고 있으며, 액면이자율로 계산한 금액과의 차이는 채무증권의 장부금액에서 조정한다. 액면취득 할증취득 할인취득 액면이자율 = 시장이자율 액면이자율 ＞시장이자율 액면이자율 ＜ 시장이자율 Example A기업은 2013년 1월 1일에 사채를 다음과 같은 조건으로 취득하였다. (할인취득) 액면가 표시(액면)이자율 만기 취득시 시장이자율 이자지급일 ￦100,000 10% 3년 12% 매년말 취득가액 산정 $$\\frac{10,000}{(1+12\\%)^1} + \\frac{10,000}{(1+12\\%)^2} + \\frac{110,000}{(1+12\\%)^3} = 95,196$$ 상각표 작성 유효이자수익 = 장부금액 $\\times$ 시장이자율(12%) 채권장부금액 = 기초장부금액 $\\pm$ 당기상각액 ($+$ 할인취득, $-$ 할증취득) 일자 이자수취액 (A) 유효이자수익 (B) 당기상각액 (B-A) 채권장부금액 2013.01.01 - - - ￦95,196 2013.12.31 ￦10,000 ￦11,424 ￦1,424 ￦96,620 2014.12.31 ￦10,000 ￦11,594 ￦1,594 ￦98,214 2015.12.31 ￦10,000 ￦11,786 ￦1,786 ￦100,000 채권매입 회계처리 분개(취득시점, 2013.01.01) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 매도가능증권 ￦95,196 $\\qquad$ (대) 현금 ￦95,196 분개(2013.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 매도가능증권 ￦1,424 $\\qquad$ (차) 현금 ￦10,000 $\\qquad$ (대) 이자수익 ￦11,424 분개(2014.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 매도가능증권 ￦1,594 $\\qquad$ (차) 현금 ￦10,000 $\\qquad$ (대) 이자수익 ￦11,594 분개(2015.12.31) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 매도가능증권 ￦1,786 $\\qquad$ (차) 현금 ￦10,000 $\\qquad$ (대) 이자수익 ￦11,786 분개(만기일) $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ (차) 현금 ￦100,000 $\\qquad$ (대) 매도가능증권 ￦100,000 유형자산유형자산은 물리적인 실체를 가지며 영업활동에 사용하기 위한 자산으로 장기간에 걸처 사용하기 위한 자산이다. 감가상각 대상자산, 비감가상각 대상자산으로 구분한다. 유형자산의 취득시 부대비용과 함께 구입가격을 취득원가에 포함시켜 회계처리한다. 무형자산무형자산은 물리적 형체가 없는 자산으로 미래의 기간에 걸쳐서 회사의 수익창출에 기여할 것으로 예상되는 자산이다. 영업권, 산업재산권, 광업권, 어업권, 개발비 등이 해당된다. 무형자산은 평가시 직접차감법을 사용한다. 투자자산 분석시 유의사항투자활동의 결과와 영업활동의 결과 구분 투자자산은 기업의 생존을 위하여 필수적으로 보유하고 있는 영업용 자산과는 거리가 멀다. 분석대상기업이 핵심적인 사업으로부터의 성과와 투자활동의 구분해야 한다. 투자결과의 평가 투자활동으로 인해 보고된 이익은 영업추세를 왜곡할 수 있다. 영업이익에는 투자활동의 결과가 포함되지 않은 순수한 영업상의 이익만 포함한다. 당기순이익에는 투자활동의 결과인 처분이익과 평가이익이 포함되어 있다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"요구사항 분석","slug":"[SE] 요구사항분석","date":"2014-09-26T14:17:00.000Z","updated":"2018-10-20T02:44:04.975Z","comments":true,"path":"2014/09/26/[SE] 요구사항분석/","link":"","permalink":"http://melomance.github.io/2014/09/26/[SE] 요구사항분석/","excerpt":"","text":"요구사항의 정의IEEE 정의 어떤 문제를 해결하거나 목적을 달성하기 위해 사용자가 필요로 하는 조건이나 능력이다. 기타 정의 시스템이 어떻게 작동해야 하는지에 대한 언급 없이 무엇을 할지를 완전하게 기술해 놓는 것이다. 소프트웨어가 어떻게(How) 구현되는지에 대한 세부사항보다는 고객이 원하는 것이 무엇(What)인가에 초점을 맞춘다. 시스템이 무엇을 해야 하는지 고객, PM, 분석자, 설계자, 개발자 등 모든 이해당사자들이 공통되게 동일한 생각을 가지고 프로젝트를 진행한다는 의미이다. 요구사항의 유형기능적 요구사항 시스템이 무엇을 수행하는지에 대한 내용을 담고 있는 요구사항 비즈니스 요구사항 사용자 요구사항 비즈니스 규칙 등 비기능적 요구사항 시스템을 기동시키거나 운영하는데 필요한 환경적인 요소들에 대한 요구사항 실행시 고려해야 하는 다양한 제약사항 (법 조항 등) 데이터 처리 용량 보안관련 준수사항 외부 시스템과 연결 등 비기능이 잘못되면 소프트웨어의 기본부터 완전히 뒤집어야 하는 경우가 발생한다. 요구사항의 중요성요구사항은 소프트웨어 개발이라는 프로젝트에 있어 가이드 역할을 하며, 프로젝트 실패 원인 대부분이 요구사항과 관련이 있다. 요구사항 관리가 어려운 이유 고객이나 사용자들도 그들의 원하는 것을 정확하게 모르는 경우가 많기 때문이다. IT관련 인원들이 요구사항을 서술하는 스타일과 고객의 서술 스타일이 다르기 때문이다. 요구사항은 언제나 불명확하기 때문이다. 요구사항은 다양한 소스로부터 도출되기 때문이다. 요구사항은 단어로 정확하게 표현하기가 쉽지 않기 때문이다. 요구사항은 다른 요건들 및 다른 개발 산출물들과 관련이 많기 때문이다. 요구사항은 변화되기 때문이다. 좋은 요구사항의 특성 검증이 가능해야 한다. 만들어진 시스템을 동작할 때 고객의 요구사항이 만족되었는지 확인할 수 있도록 구체적이어야 한다. 한정된 자원을 감안하여 우선순위가 있어야 한다.’언제까지’라는 기간과, ‘얼마의 금액 한도 안에서’ 라는 비용의 한계를 감안해야 한다. 진행 정도를 확인할 수 있는 상태값을 가져야 한다. 첫번째 특성과 마찬가지로, 소프트웨어 개발 진행정도를 확인할 수 있는 상태값을 가지고 있어야 한다. 전체 프로젝트에 걸쳐서 변경에 대한 관리가 되어야 한다. 요구사항은 전 프로젝트에 걸쳐서 다듬어지고, 구체화되고, 심지어 없어지거나 변경되기 때문에 변경을 대비하여 관리되어야 한다. 요구사항 검증 질문 요구사항이 이해하기 쉽게 정의 되었는가? 요구사항이 정확한가? 요구사항이 고객의 필요를 충족하는가? 요구사항이 애매모호하지 않은가? 요구사항이 정말로 필요한가? 요구공학요구공학의 정의 요구공학이란 요구 분석 단계에서 행해졌던 요구사항 분석 및 서술뿐 아니라 이들의 추출, 관리, 검증, 유지 등을 포함하여 요구사항에 관계되는 모든 활동과 원칙들에 대한 공학적인 접근이다. 요구사항을 고객들로부터 추출하여 분석한 후, 이를 명세화하고 검증을 거쳐 유지, 보수까지 하는 일련의 모든 공정을 총칭한다. 요구공학의 목적 프로젝트의 이해관계자들 사이에서 커뮤니케이션의 창구를 제공하고 요구사항에 대한 공감대 형성을 지원한다. 업무적 관심사와 문제점을 찾아내어 고객의 정확한 요구와 기대사항을 파악한다. 요구사항이 누락되지 않도록 불필요한 비용 증가를 통제한다. 요구사항을 구조화하여 요구사항이 변경되었을 때 정확히 추적한다. 요구공학의 구성 요구사항 개발 기능 요구사항과 비즈니스 목표를 달성할 수 있는 제품특성을 식별하는 과정이다. 요구사항 도출, 요구사항 분석, 요구사항 명세화, 요구사항 검증. 요구사항 관리 고객과 요구사항에 대해 합의하고 이를 유지하며 관리하는 활동이다. 요구사항 협상, 요구사항 베이스라인, 요구사항 변경관리, 요구사항 확인수행.","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"컴포넌트 기반 개발(CBD)","slug":"[SE] 컴포넌트기반 개발(CBD)","date":"2014-09-14T14:49:00.000Z","updated":"2018-10-20T02:44:04.975Z","comments":true,"path":"2014/09/14/[SE] 컴포넌트기반 개발(CBD)/","link":"","permalink":"http://melomance.github.io/2014/09/14/[SE] 컴포넌트기반 개발(CBD)/","excerpt":"","text":"컴포넌트 기반 개발(CBD) 방법론 개념컴포넌트는 어떤 사물을 구성하는 부품으로, 소프트웨어공학에서의 컴포넌트는 기존에 존재하거나 새로 만든 컴포넌트들을 잘 조합하여 하나의 새로운 소프트웨어를 만드는 개발 방법이다. 컴포넌트 호출 컴포넌트의 호출은 인터페이스를 통하며 이는 객체지향의 캡슐화와 동일한 원리이다. 재사용 단위 컴포넌트 기반 개발에서 재사용 단위는 컴포넌트 단위이다. 설계 전략 재사용성을 높이기 위해서는 결합도를 낮추고 응집도를 높이는 설계 전략이 요구된다. 컴포넌트 기반 개발(CBD) 관련용어모듈화 분할정복법을 이용하여 복잡한 프로그램을 여러 작은 프로그램으로 나누어 해결해 나가는 기법이다. 결합도 소프트웨어 구조 내에서 모듈들 간의 관련성을 측정하는 척도이다. 응집도 하나의 모듈 내부의 처리 요소들간의 기능적 연관성을 측정하는 척도이다. 소프트웨어 컴포넌트 모듈이라고 불리우는 작은 단위의 프로그램이다. 소프트웨어 컴포넌트 자체로서 하나의 독립성이 보장되어야 한다. 각 컴포넌트 사이의 연결을 위한 경계면이나 접촉 영역이다. 인터페이스 컴포넌트 각각의 소프트웨어 컴포넌트가 표준화된 인터페이스를 가지고 있어야 한다. 소프트웨어 컴포넌트도 컴포넌트와 인터페이스에 대한 명세서가 필요하다. 컴포넌트 기반 개발(CBD) 방법론의 특징재사용성 생산성 $\\leftrightarrow$ 품질: 높은 생산성을 얻기 위해서는 품질이 희생, 높은 품질을 얻기 위해서는 생산성이 희생된다. 재사용성으로 생산성과 품질을 모두 획득할 수 있다. 재사용되어 생산된 소프트웨어는 높은 품질을 제공한다. (이미 그 품질이 검증되었기 때문) 역할분담 컴포넌트 개발자: 기술적으로 뛰어난 사람들이 컴포넌트들을 개발한다. 어플리케이션 개발자: 문제 영역에 밝은 사람들이 이를 조립하여 애플리케이션을 개발한다. 개발 비용 분산: 상대적으로 뛰어난 개발자들을 컴포넌트 개발에 집중 투입한다. 개발 시간 단축: 개발된 고품질의 컴포넌트들을 단순히 조립함으로써 빠른 시간에 소프트웨어를 개발한다.","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"객체지향의 이해","slug":"[SE] 객체지향의 이해","date":"2014-09-14T14:19:00.000Z","updated":"2018-10-20T02:44:14.811Z","comments":true,"path":"2014/09/14/[SE] 객체지향의 이해/","link":"","permalink":"http://melomance.github.io/2014/09/14/[SE] 객체지향의 이해/","excerpt":"","text":"객체 및 객체지향의 개념 객체의 개념 객체는 실세계에서 어떤 구체적 의미를 구성하는 하나의 실체 단위로서 특정 사물 및 개념을 말한다. 어플리케이션 관점에서는 필요로 하는 데이터와 그 위에 수행되는 메소드를 가진 작은 소프트웨어 모듈이다. 객체지향의 개념 객체지향이란 실세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체로(Object)로 표현하는 개념이다. 객체의 구조 및 특성객체 = 데이터(Data) ＋ 메소드(Method) 다른 객체와 메시지 전달 방식으로 통신을 한다. 객체지향 세계에서는 객체와 메시지만 존재한다. 객체의 특성 상태(State)를 갖고 있다. (e.g. 자동차 객체는 ‘정지’, ‘이동’ 등의 상태 존재) 행위의 특징을 나타낼 수 있다. (e.g. 자동차 객체는 가속페달을 밟으면 가속) 식별성을 갖고 있다. (e.g. 자동차 번호판으로써 다른 자동차 객체와 식별성을 가짐) 기억장소를 갖고 있다. (e.g. 자동차는 도로 위에 있거나, 차고에 있거나, 항상 어떤 물리적 공간을 차지) 객체지향의 요소객체(Object) 문제 영역에서 잘 정의된 역할을 갖고 있는 각각에 대해 구별 할 수 있는 단위 클래스(Class) 객체의 타입을 정의하는 템플릿(Template) 메시지(Message) 수신자 객체(Receiver)의 이름과 수신자가 수행할 메소드(Method)의 이름, 메소드 수행시 전달되는 인자(Argument)로 구성 객체지향의 특징캡슐화(Encapsulation) 필요하지 않은 정보는 캡슐화하여 정보를 은닉하고 오직 메시지만으로 객체와 상호작용을 하게 하는 것이다. 정보에 대한 접근을 오직 메시지만으로 가능토록 한다. 객체의 내부 구조와 실체를 분리하여 내부의 변경이 어플리케이션에 미치는 영향을 최소화 한다. 추상화(Abstraction) 현실 세계의 사실을 객체로 표현하기 보다는 문제 영역의 중요한 측면을 주목하여 상세내역을 없애 나가는 과정이다. 복잡한 프로그램을 간단하게 하고 분석의 초점을 명확히 할 수 있다. 상속성(Inheritance) 클래스 계층을 기초로 클래스 내의 데이터와 메소드를 물려받아 새로운 객체를 생성하는 메커니즘이다. 클래스를 체계화하며 기존의 클래스로부터 확장이 용이하다. 중복코드의 감소 및 소프트웨어의 재사용성이 증대된다. 다형성(Polymorphism) 하나의 객체가 다수의 유형을 가질 수 있도록 지원하는 능력이다. 동일한 이름의 오퍼레이션이라도 오퍼레이션이 일어나는 클래스에 따라 각기 다른 행동을 수행한다. 하나의 함수 이름이나 심볼이 여러가지 목적으로 사용되는 경우를 의미한다. 관계성(Relationship) 객체 간의 상호참조하는 관계를 표현하는 방식이다. is member of: 연관성(Association), 참조 및 이용관계 is part of: 집단화(Aggregation), 객체 간의 구조적인 집약 관계 is a: 일반화(Generalization), 특수화 (Specialization), 클래스 간의 개념적인 포함 관계","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"소프트웨어 개발방법론","slug":"[SE] 소프트웨어 개발방법론","date":"2014-09-13T14:50:00.000Z","updated":"2018-10-20T03:46:08.525Z","comments":true,"path":"2014/09/13/[SE] 소프트웨어 개발방법론/","link":"","permalink":"http://melomance.github.io/2014/09/13/[SE] 소프트웨어 개발방법론/","excerpt":"","text":"소프트웨어 개발방법론 출현배경소프트웨어 위기인식에 따른 소프트웨어공학의 발전 소프트웨어의 수요는 그 규모와 복잡성으로 인해 기하급수적으로 증가했다. 반면 개발인력의 공급한계 및 유지보수 대상과 신규 개발 요구의 급격한 증가로 총체적 위기의식이 고조되었다. 1968년 NATO과학위원회의 국제회의에서 소프트웨어 위기라는 용어를 처음 사용했다. 소프트웨어 이용범위의 확대 사용자들의 정보시스템에 대한 이해도가 확대되었다. 이용범위도 실무자 중심에서 관리자와 경영층으로 점차 확대되었다. 소프트웨어 프로젝트의 대형화 소프트웨어 개발 시 프로젝트의 규모 및 복잡도가 증가함에 따라 개발에 참여하는 인력을 대규모로 구성한다. 소프트웨어 프로젝트가 대형화되면서 개발기간의 장기화로 예산/기간/품질상의 복합적인 문제가 대두되었다. 소프트웨어 개발방법론의 이해소프트웨어 개발방법론이란 소프트웨어공학원리를 소프트웨어 개발 생명주기에 적용한 개념으로 정보시스템을 개발하기 위한 작업활동, 절차, 산출물, 기법 등을 체계적으로 정리한 것이다. 소프트웨어 개발방법론의 특징 개발단계를 정의하고 활동, 제품, 검증절차, 각 단계의 종결기준 등을 상술한다. 소프트웨어 개발에 관한 계획, 분석, 설계 및 구축에 대하여 정형화된 방법과 절차, 도구 등을 공학적인 기법으로 정리한다. 소프트웨어 개발 방법 및 절차, 도구 등이 실무적인 관점에서 하나의 체계로 묶인다. 소프트웨어 개발방법론의 필요성 개발경험을 축적 및 재활용을 통한 개발 생산성을 향상시킨다. (작업의 표준화/모듈화) 효과적인 프로젝트 관리가 가능하다. 정형화된 절차와 표준용어를 제공하여 의사소통 수단을 제공한다. 각 단계별 검증과 종결승인을 통해 일정 수준의 품질을 보증한다. 구조적 방법론개요 데이터 중심의 방법론 기본원리 추상화 구조화 단계적 상세화 모듈화 특징 분할과 정복의 원칙 프로그램 로직 중심 컨트롤 가능한 모듈로 구조화 단계별주요산출물 (계획) 도메인 분석서, 프로젝트 계획서 (분석) Data Flow Diagram (설계) Structure Chart, 프로그램 사양서 정보공학 방법론개요 데이터 중심의 방법론 기본원리 정보전략계획 업무영역분석 업무시스템설계 시스템구축 특징 기업 업무지원 시스템 지원 방법론 Data Model 중시 프로그램 로직은 데이터 구조에 종속(CRUD) 전사적 통합 데이터모델 단계별주요산출물 (계획) 도메인 분석서, 프로젝트 계획서 (분석) E-R Diagram, 기능차트, Event모델 (설계) 어플리케이션 구조도, 프로그램사양서, Table 정의서/목록 객체지향 방법론개요 객체, 클래스 및 이들간의 관계를 식별하여 설계모델로 변환하는 방법론 기본원리 요건정의 객체지향분석: 객체모델링 $\\rightarrow$ 동적 모델링 $\\rightarrow$ 기능 모델링 객체지향설계: 시스템설계 $\\rightarrow$ 객체설계 $\\rightarrow$ 구현 테스트/배포: 테스트 $\\rightarrow$ 패키지 $\\rightarrow$ 프로젝트평가 특징 프로그램의 원소는 객체 데이터와 로직 통합(객체) 고도의 모듈화 상속에 의한 재사용(White Box Reuse) 분석-설계간 Gap없음 단계별주요산출물 (계획) Biz Process/Concept Model, 프로젝트 계획서 (분석) Use Case Diagram, Sequence Diagram, Class Diagram (설계) Sequence Diagram, Class Diagram, Component Diagram, Deployment Diagram 컴포넌트기반 방법론개요 재사용이 가능한 컴포넌트의 개발 또는 상용 컴포넌트들을 조합하는 방법론 기본원리 요구분석 분석: 아키텍처 정의, UseCase 모델링 설계: UI설계, 컴포넌트 정의/설계, DB ,컨버젼, 테스트 설계 개발: 코딩, 테스트 구현: 릴리즈, 교육 특징 객체방법론의 진화된 형태 Interface중시 인터페이스의 구현이 컴포넌트 Black Box Reuse 지향 단계별주요산출물 (계획) Biz Process/Concept Model, 프로젝트 계획서 (분석) Use Case Diagram, Component Diagram, 재사용 계획서 (설계) Sequence Diagram, Class Diagram, Component Diagram 소프트웨어 개발방법론 선택기준 프로젝트 환경 (응용분야, 시스템규모, 복잡도, 성격 등) 수작업 최소화와 자동화 정도가 높을수록 좋다. (시간과 비용 절감) 개발자들의 공감하에 적절히 이용할 수 있어야 한다. (방법과 도구, 경험) 프로젝트 진행과정의 활동과 절차 수행에 필요한 기법과 표준제공 여부 작업수행자의 책임과 역할 정의의 구체성 및 산출물 템플릿 제공 여부 프로젝트 진행의 일관성, 개발생산성, 산출물의 품질보증 등 성공확신 정도","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"소프트웨어 개발단계","slug":"[SE] 소프트웨어 개발단계","date":"2014-09-09T04:43:00.000Z","updated":"2018-10-20T02:44:20.883Z","comments":true,"path":"2014/09/09/[SE] 소프트웨어 개발단계/","link":"","permalink":"http://melomance.github.io/2014/09/09/[SE] 소프트웨어 개발단계/","excerpt":"","text":"소프트웨어 개발단계 개요소프트웨어 개발 단계는 소프트웨어 제품을 생산하기 위한 다양한 태스크(Task)와 이들 결과물의 집합으로, 대부분의 활동은 소프트웨어 엔지니어에 의해 수행된다. 공정 소프트웨어를 개발하기 위해서는 어떠한 순서로 개발할 것인지를 결정해야 하는데, 이러한 개발 순서를 명시한 것을 공정이라 한다. 공정의 각 단계는 태스크라는 작업 활동으로 구성된다. 보호활동 소프트웨어 개발 단계(정의 $\\rightarrow$ 개발 $\\rightarrow$ 유지보수)에는 보호활동이라고 할 수 있는 다양한 활동들이 존재한다. 주요 태스크로는 프로젝트의 추적 및 제어, 품질보증, 형상관리, 문서화, 측정, 위험관리 등이 있다. 프로젝트에 대한 전반적인 계획인 프로젝트의 범위, 자원, 위험, 비용, 일정을 개발 계획서에 명시하여 프로젝트 관리자와 기술진, 고객에게 상호 협의할 수 있는 윤곽을 제시한다. 그 밖에도 위험에 대한 대책, 품질보장에 대한 방법 및 변경관리에 대한 활동들이 보호 활동에 속한다. 소프트웨어 정의단계 세부 절차소프트웨어 개발에 있어서 가장 어려운 부분으로 무엇을 개발할 것인가를 정확히 결정하는 것이다. 사용자가 무엇을 원하는지, 무엇이 문제인가를 알아내야 한다. 즉, 핵심적인 요구사항을 식별하는 단계로 기능적인 요구사항은 반드시 식별해야 한다. 주요 태스크에는 요구사항 분석이 있고, 요구사항 분석 후 요구사항 명세서가 도출 된다. 요구사항 분석 현재의 상태파악 및 문제정의 $\\rightarrow$ 문제 해결과 구현될 시스템의 목표를 도출한다. 요구사항 명세서 작성 완성될 소프트웨어가 어떤 기능을 가져야 하는가를 정확히 기술한다. 소프트웨어 개발단계 세부 절차주요 태스크로는 아키텍쳐 수립, 소프트웨어 설계, 코드 생성(구현), 소프트웨어 테스트 등이 있다. 설계 개발될 소프트웨어에 대한 요구사항이 분석된 후에 수행되는 단계로, 소프트웨어의 내부구조를 설계하고 자료구조를 설계한다. 소프트웨어는 요구사항 명세서에 기술된 기능을 수행하도록 설계되어야 한다.철저한 요구사항 분석 $\\rightarrow$ 성공적인 설계 수행 (분석 단계의 산출물 = 설계 단계의 입력물) 구현 설계 단계의 산출물들을 프로그래밍 언어로 변환하는 작업이다. 테스트 구현 단계에서 얻어진 코드들이 올바로 동작하는지 검사한다. 단위 테스트 하나의 클래스가 올바로 동작하는지를 검사하는 과정으로 흔히 개발과정에서 병행되어 수행된다. 검사할 대상이 되는 클래스가 구동하기 위해서 다른 클래스를 필요로 하는 경우가 많다. (간략한 Stub 클래스 개발) 단, 의존하고 있는 클래스가 적은 것부터 의존하고 있는 클래스가 많은 순서로 구현한다. 통합 테스트 단위 테스트를 통과한 클래스들을 하나의 시스템으로 통합하는 과정에서 서로 올바르게 상호작용하는지 검사한다. 여러 클래스들이 상호 동작하여 기능을 올바르게 제공하는지에 집중하여 검사를 수행한다. 시스템 테스트 제한된 자원에서 적절히 동작하는지 검사한다. 과도한 입력에 대해서도 올바르게 동작하는지 검사한다. 소프트웨어 유지보수단계 세부 절차변경에 초점을 맞춰 오류 수정, 환경변화에 따른 적응, 기능 향상에 따른 요구사항의 변경 등을 고려한다. 기존 소프트웨어 이해 효율적인 소프트웨어 유지보수의 근본이 되는 것은 기존 소프트웨어를 이해하는 것이다. 변경 요구 분석 요구 분석 변경이 불가피한 이유와 요구를 잘 분석하여 이해해야 한다. 변경 및 효과 예측 실제 변경을 수행하기 전에 변경으로 인한 범위와 그 영향에 대해서 점검한다. 분석 결과에 따라서 수정해야 하는 작업의 규모와 그 난이도를 감안해서 일정을 수립한다. 소프트웨어 변경 수행 소프트웨어 변경을 수행할 때에는 계획한 대상에 대해서 순차적으로 진행한다. 회귀 테스트(Regression Test) 변경에 의해 영향을 받는 부분에 대해서 다시 테스트하면 유지보수 작업이 마무리 된다.","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"Enterprise Application","slug":"[SE] Enterprise Application","date":"2014-09-09T04:08:00.000Z","updated":"2018-10-20T02:44:33.179Z","comments":true,"path":"2014/09/09/[SE] Enterprise Application/","link":"","permalink":"http://melomance.github.io/2014/09/09/[SE] Enterprise Application/","excerpt":"","text":"EA 정의EA는 Enterprise Application의 약자로, 기업의 e-비즈니스를 지원하거나, 기업 또는 정부의 업무를 지원하는 소프트웨어이다. 여기서 소프트웨어란 프로그램과 프로그램의 개발, 운영, 유지보수에 필요한 정보일체를 말한다. EA 특징난이도가 낮은 프로그램 멀티 스레드를 사용하지 않으며, 프로토콜 수준의 스펙을 이해할 필요가 없다. 복잡한 비즈니스 로직 반영 복잡하지만 정형화되지 않은 업무 규칙이 있고, 많은 예외사항이 존재하며, 소프트웨어보다 많은 양의 데이터를 포함한다. 영속성(Persistency)이 있는 데이터 다음에 수행시킬 때에도 유지되어야 하는 성격의 데이터가 많다. 대량의 데이터 기업 운영을 위한 대량의 데이터에 대해서 관리해야 할 것을 감안해야 한다. 많은 동시 사용자 많은 사용자의 접속을 지원하기 위해 특별한 시스템을 구성해야 하며, 동일한 데이터에 대한 접근을 관리하기 위해 트랜잭션 제어도 반드시 필요하다. 다른 시스템과 상호작용 타 시스템과의 상호작용은 주로 데이터의 교환으로 수행된다. EA 구축시 필요한 기술개발 방법론 프로젝트를 운영하는 표준 프로세스로써 프로젝트 구성원들이 반드시 지켜야 하는 규범이다. 방법론에는 두 가지 개념이 존재한다. 시스템을 구축하기 위한 분석, 설계, 구현과 관련된 프로세스 및 기법 등 다른 하나는 위험관리, 프로젝트 관리 등 품질활동과 관련된 사항 프로젝트에서는 기존 방법론을 그대로 사용하는 것이 아니라, 프로젝트 환경에 맞게 적절하게 수정해서 사용한다. 비즈니스 분석/설계 (UML 등) 사용자의 요구사항을 분석하여 시스템을 설계하기 위한 다양한 분석 기법 및 설계 기법에 대한 지식이 필요하다. 데이터 모델링과 DB 설계 EA 특징 중 하나는 많은 데이터에 대한 동시접근이 가능하다는 것이다. 따라서 데이터에 대한 분석 및 설계가 EA 기능과 성능을 결정짓는 중요한 요소이다. 프로그래밍 언어 설계된 내용을 구현할 프로그래밍 언어와 관련된 기술이 필요하다. Tool (WAS, DBMS 등) EA 구축을 위해서는 미들웨어인 WAS와 데이터를 저장하는 DBMS가 필수적이다. 이 두가지를 적절하게 도입하여 배치하고 운영하는 기술은 시스템을 안정적으로 운영하는데 가장 중요한 요소이다. 보안 대부분의 기업 업무가 시스템을 통해 수행되기 때문에, 시스템에 대한 보안문제가 기업의 존폐를 위협한다. 특히 웹 어플리케이션은 다수의 사용자를 대상으로 하고 있기 때문에 보안에 더욱 민감하다. 테스트 신뢰성 있는 시스템을 구축하기 위해서는 반드시 테스트 계획을 수립하고, 수립된 계획에 맞춰 테스트를 수행해야 한다. 튜닝 EA는 많은 사용자가 동시에 접속하기도 하고, 또 시스템이 다운되거나 문제가 발생할 경우, 기업 업무 수행에 영향을 주기 때문에 성능 및 안정성이 매우 중요하다. 따라서 시스템의 성능을 향상시키기 위한 튜닝 기법과 방법을 이해하는 것도 중요하다. EA 개발의 특징 계획과 공법이 매우 중요하다. 복잡성과 크기가 커질 때 시간에 대한 중요성도 고려해야 한다. 재사용해도 닳지 않는다. 규모에 따른 기술적, 관리적 통제가 필요하다.","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"소프트웨어공학","slug":"[SE] 소프트웨어공학","date":"2014-09-09T03:58:00.000Z","updated":"2018-10-20T03:26:13.044Z","comments":true,"path":"2014/09/09/[SE] 소프트웨어공학/","link":"","permalink":"http://melomance.github.io/2014/09/09/[SE] 소프트웨어공학/","excerpt":"","text":"소프트웨어의 정의 및 특성소프트웨어란 프로그램과 프로그램의 개발, 운영, 유지보수에 필요한 정보의 일체를 의미한다. 소프트웨어는 다음과 같은 특성을 갖는다. 소프트웨어의 특성 비가시성(Intangible) 복잡성(Complexity) 변경성(Changeability) 비마모성(Longevity) 소프트웨어의 위기 $\\rightarrow$ 소프트웨어공학의 등장배경 소프트웨어 개발에 필요한 시간 및 비용 예측력 부족 개발된 소프트웨어의 품질 수준 부족 하드웨어에 대한 소프트웨어의 상대적 비용 변화 유지보수의 역할 증대 하드웨어 및 소프트웨어 기술의 급속한 발전 크고 복잡한 소프트웨어에 대한 수요 증가 소프트웨어공학의 정의 및 3요소소프트웨어공학이란 소프트웨어를 개발하고, 운영하며, 유지보수하고, 폐기하기까지의 과정에 적용되는 시스템적 접근방안이다. (IEEE) 방법(Method) 프로젝트 계획수립과 추정, 시스템과 소프트웨어 분석, 자료구조, 프로그램구조, 알고리즘, 코딩, 테스트, 유지보수 등 특수한 언어 중심 또는 그래표 표기법 및 소프트웨어 품질에 대한 일련의 평가기준을 도입한다. 도구(Tool) 소프트웨어 개발을 지원하는 시스템 설정 절차(Procedures) 방법과 도구를 결합하여 소프트웨어를 합리적이고 적시에 개발하도록 한다. 소프트웨어공학의 과정정의 과정: 무엇(What)에 초점 시스템 분석 컴퓨터기반 시스템에서 각 요소가 해야 할 역할을 정의한다. 소프트웨어가 수행해야 할 역할을 할당한다. 프로젝트 계획 수립 위험 분석 자원 할당 비용 추정 작업 내용과 일정 결정 요구사항 분석 개발방향 제시 (개발된 소프트웨어에 대한 정보와 기능의 상세한 정의) 개발 과정: 어떻게(How)에 초점 설계소프트웨어에 대한 요구사항들을 자료구조, 알고리즘적 절차, 인터페이스의 특성을 묘사하는 일련의 표현으로 변환한다. 구현설계 표현은 컴퓨터에 의해 실행되어질 수 있는 명령어를 가져다주는 프로그래밍 언어로 변환되어야 한다. 테스트소프트웨어의 기능적, 논리적, 구현에서의 결함을 발견하기 위한 테스트를 실시한다. 유지보수 과정: 변경에 초점 수정수정적 유지보수는 결함이 수정되도록 소프트웨어를 변경한다. 적응적응적 유지보수는 외부적인 환경변화(CPU, OS, 주변장치 변경 등)를 수용할 수 있도록 소프트웨어를 변경한다. 기능향상완전한 유지보수는 본래 요구된 기능을 능가하도록 소프트웨어를 확장한다. 소프트웨어공학의 원리정형성(Formality)수학에 근거를 둔 것으로 수학적 표현과 증명이 가능하다. 엄격(Rigor)정형화 기법을 대신할 수 있는 원리로 소프트웨어의 명세 또는 문서화를 엄격히 함으로써 프로세스의 재사용을 향상시킬 수 있다. 관심사의 분리(Separation of Concern)소프트웨어 개발 시에 각 단계별, 품질별, 크기별, 역할별로 분리하여 문제를 해결한다. 모듈화(Modularity)소프트웨어 개발시 모듈들이 서로 정보를 교환하면서 사용자가 필요로 하는 서비스를 제공하기 때문에 개별 모듈들이 가능한 정보 공유 또는 정보 교환의 횟수를 적게 설계한다. 추상화 (Abstraction)각 단계별 목적에 필요한 정보 이외에는 생략함으로 개발자가 쉽게 문제를 이해하고 의견 교환을 하기 위한 필수적인 원리이다. 일반화(Generality)소프트웨어의 경우 공통적인 소프트웨어를 개발하여 소프트웨어의 재사용 가능성을 높인다. 점진화(Incrementally)후반에 통합에 대한 충격을 분산하여 그 영향을 완화하는데 효과적이다. 소프트웨어공학 vs. 건축공학특수한 연산과 목적을 위해 사용되던 초기와 달리, 소프트웨어는 하드웨어적인 종속성을 벗어나 효율적이고 효과적인 소프트웨어 개발을 하기 위해 공학적인 접근이 필요했으며 이때 건축공학을 참조했다. 공통점 설계자, 아키텍트, 디자인패턴, 재활용 등 건축공학에서 쓰이는 용어를 사용한다. 둘 다 절차지향적이다. (요구사항 분석 $\\rightarrow$ 설계 $\\rightarrow$ 구축 $\\rightarrow$ 운영 $\\rightarrow$ 유지보수) 다만, 소프트웨어공학에 건축공학의 절차를 그대로 활용화기에는 한계점이 존재한다. 차이점 육체 노동적 보다는 정신 노동적이다. 눈에 보이지 않는 특성들을 가진다. 변경이 용이하다는 유연성을 가진다.","categories":[{"name":"S/W Engr.","slug":"S-W-Engr","permalink":"http://melomance.github.io/categories/S-W-Engr/"}],"tags":[{"name":"소프트웨어공학","slug":"소프트웨어공학","permalink":"http://melomance.github.io/tags/소프트웨어공학/"}]},{"title":"유동자산의 평가","slug":"[AC] 유동자산의 평가","date":"2014-09-08T06:28:00.000Z","updated":"2018-08-11T05:31:21.167Z","comments":true,"path":"2014/09/08/[AC] 유동자산의 평가/","link":"","permalink":"http://melomance.github.io/2014/09/08/[AC] 유동자산의 평가/","excerpt":"","text":"자산의 분류기업의 자산은 1년 이내에 현금화할 수 있는 유동자산과 그렇지 않은 비유동자산으로 분류된다. 유동자산은 당좌자산과 재고자산으로 다시 나눌 수 있는데, 판매목적으로 사용되는 상품과 같은 재고자산을 제외한 모든 유동자산은 당좌자산으로 구분되어지고 있다. 자산 유동자산 당좌자산 현금및현금성자산 단기투자자산 매출채권 이연법인세자산 기타의당좌자산(선급금, 선급비용, 미수금, 미수수익) 재고자산 비유동자산 투자자산 유형자산 무형자산 기타비유동자산 자산의 평가방법역사적 원가기업이 자산을 취득할 때 지불한 현금 또는 현금등가액이다. 측정이 용이하고 객관적이나 공정시장가치를 반영하지 못한다. 현행원가기업이 소유한 자산과 동일한 자산을 현시점에서 취득/판매시 지불/수취 하여야 할 현금액 또는 현금등가액이다. 측정이 어렵다는 단점이 있다. 미래현금흐름의 현재가치미래현금흐름의 현재가치란 자산에서 발생하는 현금흐름을 현재가치로 할인하여 평가한 것이다. 현재가치를 구하는 공식은 다음과 같다. $$\\underbrace{PV_0 = \\sum_{t=1}^n \\frac{CF_t}{(1+r)^t}}_{PV_0: \\text{ 현재시점의 가치} \\\\ CF_t: \\text{ t기의 현금흐름액} \\\\ r: \\text{ 할인율} \\\\ n: \\text{ 내용년수}}$$ 현금 및 현금성자산현금통화 및 타인 발행 수표 등 통화대용 증권으로 당좌예금이나 보통예금을 포함한다. 현금성자산큰 부대비용없이 현금으로의 전환이 용이하고, 이자율 변동에 따른 가치변동의 위험이 중요하지 않은 유가증권 및 단기금융상품으로 취득 당시 만기가 3개월 이내 도래하는 것이다. 단기금융자산단기적 자금 운용을 목적으로 소유하거나 기한이 1년 이내에 도래하는 금융상품이다. 분석시 유의사항 기업의 현금 및 현금성자산에 단기금융자산을 포함해서 분석한다. 주석사항에 표시되어 있는 사용이 제한된 예금은 유동성에서 차감하여 분석한다. 매출채권매출채권의 의의 및 분류기업이 재화나 용역을 외상으로 판매 제공하고 그 대가로 미래에 현금을 수취하기로 한 경우 매출채권 계정을 사용한다. 동 계정과목은 외상매출금과 받을어음을 포함한다. 매출채권의 평가와 대손 대손액 추정: 대손상각비라는 비용 계정, 대손충당금이라는 평가 계정을 사용 대손액 추정방법: 매출채권잔액비율법, 연령분석법 실제대손 발생: 대손충당금 상계, 부족시 대손상각비 처리 상각채권 회수: 대손충당금의 증가라는 계정을 이용하여 영업외수익으로 처리 Example A기업은 20X2년말 매출채권 잔액 ￦20,000에 대하여 ￦1,400 대손을 예상 20X3년에는 실제로 ￦2,000이 회수불능으로 판명 20X4년에는 과거에 상각한 매출채권을 ￦2,000 회수 $\\quad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ $\\qquad$ $\\quad$ $\\qquad\\qquad\\qquad\\qquad\\quad$ $\\qquad\\qquad$ 1. (차) 대손상각비 ￦1,400 $\\qquad$ (대) 대손충당금 ￦1,400 2. (차) 대손충당금 ￦1,400 $\\qquad$ (대) 매출채권 ￦2,000 (차) 대손상각비 ￦600 $\\qquad$ 3. (차) 현금 ￦2,000 $\\qquad$ (대) 대손충당금환입 ￦2,000 분석시 유의사항 연도별 매출채권의 추세를 분석하여 대손충당금과 현금흐름의 적정성을 검토한다. 매각 처리되어 장부에서 제외된 금액을 차입금으로 간주하여 재계산한다. (상환청구권 때문) 재고자산판매를 목적으로 보유하는 상품이나 제품을 말하며, 판매할 제품을 생산하기 위하여 보유하는 원재료, 제공품, 저장품 등이 포함된다. 판매된 재고자산은 매출원가로 손익계산서에 비용으로 계상되며, 보관하고 있는 재고자산은 재무상태표에 자산으로 계상된다. 상품의 수량계산매출원가는 (매출상품의 수량 × 단가), 기말재고액은 (기말재고수량 × 단가)로 계산된다. 상품의 매출수량을 산정하는 기본적인 방법으로 계속기록법과 실지재고조사법의 두 가지가 있다. 계속기록법(Perpetual inventory method)상품의 입고수량과 출고수량을 계속하여 기록해나가는 방법으로 일정기간 동안의 매출상품 수량을 직접 파악할 수 있다. 하지만 상품 판매시마다 매출원가를 계산하여 기입해야 하는 사무적인 번거로움이 따른다. $$기초재고수량 ＋ 당기매입수량 － 당기매출수량 = 기말재고수량$$ 실지재고조사법(Physical inventory method)상품에 대하여 기말재고조사를 실시하여 보유하고 있는 재고수량을 실제로 파악하고 그 수량을 기초의 재고수량과 당기의 매입수량의 합계에서 차감하여 당기의 매출수량을 간접적으로 파악한다. 계속기록법에 비하여 사무적으로는 간편하지만 도난 파손 등의 원인으로 없어진 수량도 모두 매출수량으로 계산되기 때문에 재고관리를 적절히 할 수 없다는 결점이 있다. 실무에서는 계속기록법과 실지재고조사법 양자를 병용하여 사용하는 것이 일반적이다. $$기초재고수량 ＋ 당기매입수량 － 기말재고수량 = 당기매출수량$$ 상품의 단가계산 개별법(Specific identification method)개별법은 상품을 매입할 때마다 금액을 개별적으로 식별하여 두었다가 판매할 때마다 판매상품의 매입원가가 얼마인지를 확인하여 그 금액을 출고단가로 하는 방법이다. 선입선출법(First-In First-Out)선입선출법은 먼저 매입한 상품이 먼저 매출되는 것으로 가정하여 매출상품의 출고단가를 산정하는 방법이다. 후입선출법(Last-In Last-Out)후입선출은 나중에 매입한 상품이 먼저 매출되는 것으로 가정하여 매출상품의 출고단가를 산정하는 방법이다. 이동평균법(Moving average method)이동평균법은 상품을 매입할 때마다 그 수량과 금액을 매입직전의 보유상품의 수량과 금액에 가산하여 새로운 가중평균단가를 산출하고 이 단가를 매출상품의 출고단가로 하는 방법이다. 총평균법(Weighted average method)총평균법은 일정기간 동안의 상품에 대한 전체원가를 평균하여 단가를 구하는 방법이다. Example 일자 이벤트 수량 단가 금액 8월 01일 전월이월 200개 @￦200 ￦40,000 8월 05일 매입 200개 @￦220 ￦44,000 8월 10일 매출 200개 8월 15일 매입 100개 @￦240 ￦24,000 단가계산방법 8월의 매출원가 월말상품 재고액 선입선출법 ￦40,000(=200 × @￦200) ￦68,000(=200 × @￦220 ＋ 100 × @￦240) 후입선출법 ￦44,000(=200 × @￦220) ￦64,000(=200 × @￦200 ＋ 100 × @￦240) 이동평균법 ￦42,000(=200 × @￦210) ￦66,000(=300 × @￦220) 총평균법 ￦43,200(=200 × @￦216) ￦64,800(=300 × @￦216) 분석시 유의사항 물가상승시 이익이 가장 높은 방법: 선입선출법 (기말재고수량이 기초재고수량보다 증가 가정) 물가상승시 이익이 가장 낮은 방법: 후입선출법 (기말재고수량이 기초재고수량보다 증가 가정)","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"재무보고","slug":"[AC] 재무보고","date":"2014-09-08T03:08:00.000Z","updated":"2018-07-04T11:55:50.904Z","comments":true,"path":"2014/09/08/[AC] 재무보고/","link":"","permalink":"http://melomance.github.io/2014/09/08/[AC] 재무보고/","excerpt":"","text":"외부회계감사 대상법인주식회사는 외감법(주식회사의 외부감사에 관한 법률)에 의해 의무적으로 회계법인으로부터 외부감사를 받고 1년에 1회씩 감사보고서를 작성하도록 하고 있다. 외감법 대상기준 직전 회계연도말 자산총액이 100억원 이상인 주식회사 자산총액이 70억원 이상이면서 부채총액이 70억원 이상 또는 종업원수가 300명 이상인 주식회사와 주권상장법인 다음 사업연도 중에 주권상장법인이 되고자 하는 주식회사 외감법에 의한 감사보고서는 금융감독원(dart.fss.or.kr)에 제출 외부회계감사외부회계감사는 독립적으로 외부감사인이 기업회계기준에 따라 재무제표가 적절하게 작성되어 있는지에 대한 의견을 표명함으로써 재무제표의 신뢰성을 제고시킬 수 있게 된다. 다만, 외부감사인의 감사의견은 재무제표가 기업회계기준에 따라 적정하게 작성되었는지에 대한 의견일 뿐 분식이 없거나 회사가 부도위험이 없다는 것을 의미하는 것은 아니다. 감사보고서의 구성 도입문단:$\\qquad$ 감사대상이 되는 재무제표의 명칭 등을 사실적으로 기술하여 그 내용을 정보이용자에게 알리기 위해 사용되는 문단이다. 범위문단: 감사인이 회계감사기준에 따라 수행하였다는 것을 언급한다. 중간문단: 적정의견을 제외한 의견을 표명할 경우 그 사유를 중간문단에 기재하며 중간문단을 통해 적정의견이 아닌 사유를 알 수 있다. 의견문단: 외부감사인의 감사결과를 기재하며 적정의견, 한정의견, 부적정의견과 의견거절을 알 수 있다. 특기사항: 감사의견에는 영향을 미치지 아니하며 감사보고서 이용자의 합리적인 의사결정에 참고가 될 것이라고 판단되는 사항을 기재한다. 감사의견의 표시방법독립된 제 3자로서 전문자격을 취득한 공인회계사들은 기업의 재무제표가 회계기준에 근거하여 작성되었는지를 비판적으로 검토한 후 감사의견을 표명한다. 즉, 감사인은 일반적으로 인정된 감사기준(GAAS: Generally Accepted Auditing Standards)에 의거 감사절차를 수행한 후 적발한 사항에 따라 다음과 같은 4가지 의견 중의 하나를 표명해야 한다. 적정의견(Unqualified Opinion) 감사인이 독립성을 유지하고 감사범위에 제한을 받지 않고 회계감사기준에 준거하여 감사를 수행한 결과, 재무제표 작성에 적용된 회계처리방법과 재무제표 표시방법이 일반적으로 안정된 회계원칙에 일치되고, 재무제표에 중요한 영향을 줄 수 있는 불확실한 사실이 없다고 인정되는 경우에 표명되는 의견이다. 회사에 의해 작성된 재무제표가 그 회사의 재무상태, 경영성과, 자본항목의 변동과 현금흐름의 내용을 회계기준에 따라 적정하게 표시하고 있음을 입증하는 의견이다. 한정의견(Qualified Opinion) 재무제표작성에 적용된 회계처리방법과 재무제표 표시방법 중 일부가 회계기준에 위배되거나 감사의견을 형성하는 데 필요한 합리적인 증거를 입수하지 못함으로써 이에 관련된 사항이 재무제표에 주는 영향이 중요한 정도가 아닌 경우에 표명되는 의견이다. 특정한 재무제표항목 또는 계정잔액을 제외하고는 회계기준에 따라 재무제표가 적정하게 작성되었음을 입증하는 의견이다. 부적정의견(Adverse Opinion) 적정의견과 완전히 대립되는 의견이다. 매우 부당한 회계처리방법 또는 정당한 이유없이 회계처리방법의 변경이나 한정사항이 재무제표에 중요한 영향을 주고 있다고 인정되는 경우에 표명된다. 회계기준에 위배되는 사항이 재무제표에 특히 중요한 영향을 줌으로써 재무제표가 전체적으로 왜곡 표시되어 무의미하다고 인정되는 경우에는 부적정의견을 표명해야 한다. 의견거절(Disclaimer of Opinion) 감사의견을 형성하는 데 필요한 합리적인 증거를 입수하지 못하여 재무제표 전체에 대한 의견표명이 불가능한 경우, 기업의 존립에 의문을 제기할 만한 객관적인 사항이 중요한 경우 또한 감사인이 감사를 수행함에 있어서 독립성이 결여되어 있는 경우 등 재무제표의 적정성에 대하여 의견표명을 하지 못하는 경우에 제시된다. 감사범위의 제한으로 합리적인 증거를 얻지 못하여 회계감사기준에 준거할 수 없는 사정이 있는 경우에는 감사인은 의견표명을 하지 못하며, 또한 의견표명이 이루어졌다 할지라도 대부분의 경우 무의미하게 된다. 감사의견을 결정하는 조건감사의견은 적정의견, 한정의견, 부적정의견, 의견거절의 네 가지 의견으로 나누어지며, 이들 의견은 다음의 네 가지 조건을 충족시키느냐에 따라 결정된다. 독립성 감사인과 감사대상법인 간의 독립성이 유지되느냐? 감사범위 감사범위에 제한이 없느냐? 기업회계기준 재무제표가 기업회계기준에 따라 작성되었느냐? 계속기업의 가정 계속기업의 가정이 충족되었느냐? 조건 적정의견 한정의견 부적정의견 의견거절 독립성 유지 유지 유지 유지안됨 감사범위 제한없음 중요한 제한 - 특히 중요한 제한 기업회계기준 적절하게 작성 중요한 위배 특히 중요한 제한 - 계속기업의 가정 충족 부적절한 공시 의문 중대한 의문 회계감사에 대한 오해와 진실 감사인은 회사의 모든 거래를 체크한다. [x] $\\quad$ vs. $\\quad$ 감사인은 표본을 추출하여 거래를 테스트 할 뿐 모든 거래를 절대 체크하지 않는다. [O] 적정의견 감사보고서는 투자자들에게 투자의 안정성을 보장한다. [x] vs. 감사인의 적정의견 감사보고서는 한 기업에 대한 안전한 투자를 절대 보장하지 않는다. [O] 감사인이 재무제표를 작성한다. [x] vs. 재무제표의 작성은 오직 경영자의 몫이다. [O] 감사인은 회사가 어떤 회계방침을 적용할지 결정한다. [x] vs. 회계방침의 결정은 전적으로 경영자에게 달려있다. [O]","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"기업회계의 개요 및 재무제표","slug":"[AC] 기업회계의 개요 및 재무제표","date":"2014-08-08T12:39:00.000Z","updated":"2018-07-08T16:06:54.662Z","comments":true,"path":"2014/08/08/[AC] 기업회계의 개요 및 재무제표/","link":"","permalink":"http://melomance.github.io/2014/08/08/[AC] 기업회계의 개요 및 재무제표/","excerpt":"","text":"회계의 정의회계란 특정기업에 대한 정보를 알고 싶어하는 기업의 이해관계자들이 합리적인 의사결정을 할 수 있도록 특정기업의 경제적 활동을 화폐단위로 측정·기록하고, 이에 관한 정보를 요약·수집하여 기업의 이해관계자들에게 전달하는 활동을 말한다. 회계정보는 일정한 표시형식으로 제공되는데 이것이 바로 재무제표이다. 정보이용자들의 종류 주주, 채권자, 종업원, 정부기관, 한국거래소 및 협회, 경영자 등 기업의 경제적 활동의 종류 금전적으로 측정이 가능하여야 한다. 측정금액이 신뢰성이 있어야 한다. 기업의 3가지 경제적 활동 영업활동: 제품의 생산과 상품 및 용역의 구매, 판매 및 부수적 활동 재무활동: 영업이나 투자 목적으로 필요한 자금을 조달 및 상환하기 위한 활동 투자활동: 비유동자산에 속하는 지분증권, 유·무형자산의 취득 회계의 분류회계는 그 정보의 이용자에 따라 재무회계, 관리회계 및 세무회계로 구분된다. 그러나 각 회계는 완전히 독립적으로 존재하는 것은 아니며, 회계는 하나로 존재하고 다만 정보이용자의 필요에 따라 정보를 제공해주는 과정에서 차이가 있을 수 있다. 재무회계(Financial Accounting) 기업의 설립, 유지, 성장에 기여하거나 기여하게 될 기업외부자에게 재무적 정보를 제공한다. [일반적으로 인정된 회계원칙(GAAP)]에 따라 재무적 정보를 제공한다. 기업의 전반적인 경영활동에 관한 정보를 제공하는데, 그 형식은 재무상태표(대차대조표)와 손익계산서로 대표되는 일정한 재무보고서에 의해 정기적으로 제공한다. 관리회계(Management Accounting) 기업내부자인 경영자가 합리적인 의사결정을 하는데 필요한 정보를 제공한다. [일반적으로 인정된 회계원칙(GAAP)]에 구애받지 않고 다양한 형태로 정보를 제공한다. 일정한 형식이 없어 관리의 필요상 수시로 또는 신속히 정보를 제공하는 것을 목적으로 한다. 세무회계(Tax Accounting) 정부당국(세무당국)이 세금을 결정하는데 필요한 정보를 제공하는 것이 목적이다. 세법의 목적달성을 위하여 「일반적으로 인정된 회계원칙」을 그대로 받아들이지 않는다. 회계원칙회계원칙이란 재무제표 작성의 오류를 최소화하고 상이한 기업들의 유사한 사건을 보고할 때 통일성을 부여함으로써 재무제표의 비교가능성을 높이기 위하여 일반적으로 보편타당하고 합리적이라고 인정되는 재무제표 작성과 표시에 관한 일련의 기준 또는 원칙을 말하며, 우리나라에서는 기업회계기준이라고 부른다. 우리나라의 회계원칙은 한국채택 국제회계기준(K-IFRS : International Finance Reporting Standards), 일반기업 회계기준 및 중소기업회계기준 3원화 체계이다. 비상장기업(비외부회계감사대상) 중소기업회계기준(총 10장으로 구성) 비상장기업(외부회계감사대상) 일반기업회계기준(총 32장으로 구성) 상장기업 K-IFRS(회계기준서와 회계기준해석서로 구성) 회계기록 방법복식부기제도복식부기란 경제적 사건이 발생하면 기록대상을 항상 관련항목과의 유기적 관계에서 파악하여 기록하는 방법이다. 자금의 사용내역이나 현재의 상태를 차변, 자금의 조달 또는 원천내역을 대변에 기록한다. 차변(DEBIT) 대변(CREDIT) 자금의 사용내역(유입된 자금을 어떻게 사용하고 있는지를 알 수 있다.) 자금의 조달방법(자금을 어떻게 조달하였는지를 알 수 있다.) 재무제표재무제표의 종류 재무제표는 주석을 포함한다. 재무상태표 기업의 일정시점에 있어서의 재무상태를 나타내는 보고서 손익계산서 기업의 일정기간 동안의 영업성적을 나타내는 보고서 이익잉여금처분계산서(또는 결손금처리계산서) 기업의 이익잉여금(결손금)의 변동을 나타내는 보고서 현금흐름표 기업의 일정기간 동안의 현금흐름을 나타내는 보고서 자본변동표 기업의 일정기간 동안의 자기자본 변동을 나타내는 보고서 재무제표의 작성절차 거래인식 분개장기록 총계정원장기입 시산표작성 재무제표작성 재무제표의 5요소 (자산, 부채, 자본, 수익, 비용) 자산, 부채, 자본은 그 시점에서의 상태(Stock)가 기록되며 수익과 비용은 일정 기간동안의 흐름(Flow)이 기록된다. 상태 개념인 자산, 부채, 자본을 별도로 구분하여 표시한 것을 재무상태표라 한다. 흐름 개념인 수익과 비용을 별도로 구분하여 표시한 것을 손익계산서라 한다. 흐름 개념인 손익계산서를 통해 특정 기업의 일정기간 동안의 경영성과를 파악할 수 있게 되고, 상태 개념인 재무상태표를 통해 특정기업의 특정시점 현재의 재무상태를 알 수 있게 된다. 재무상태표(기업의 재무상태)재무상태표의 경우에는 기업의 주된 목적사업에 따라 영업자산(또는 영업부채와 자본)과 영업외자산(또는 영업외 부채와 자본)으로 구분하지 않고 유동성(현금화할 수 있는 정도) 기준에 따라 다음과 같이 분류하고 있다. 자산의 구성 유동자산 당좌자산: 현금 및 현금성자산, 단기투자자산, 매출채권 등 재고자산: 상품, 제품, 반제품, 원재료, 재공품 등 비유동자산 투자자산: 투자부동산, 장기투자증권 등 유형자산: 토지, 설비자산 등 무형자산: 영업권, 산업재산권, 개발비 등 기타비유동자산: 이연법인세자산 등 부채의 구성 유동부채: 매입채무, 단기차입금, 미지급금, 선수금, 예수금, 미지급비용, 선수수익, 미지급법인세 등 비유동부채: 사채, 장기차입부채, 장기성매입채무, 부채성충당부채 등 자본의 구성 자본금: 보통주 자본금, 우선주 자본금 자본잉여금: 주식발행초과금, 자기주식처분이익, 감자차익 등 이익잉여금: 법정적립금, 임의적립금, 미처분이익잉여금 자본조정: 자시주식, 주식할인발행차금, 주식매수선택권 등 기타포괄손익누계액: 매도가능증권평가손익, 해외사업환산손익 등 손익계산서(기업의 경영성과)기업회계에서는 수익과 비용을 기업의 주목적사업에서 발생하였는지 아닌지에 따라 수익과 비용을 세분화하고 있으며, 주목적사업에 발생한 수익(비용)을 영업수익(비용)으로, 주목적사업 이외에서 발생한 수익(비용)을 영업외수익(비용)으로 구분하고 있다. 수익의 구성 영업수익: 순매출액(=총매출액 － 매출할인, 매출에누리와 환입액) 영업외수익: 이자수익, 배당금수익, 임대료, 단기투자자산처분이익, 단기투자자산평가이익, 유형자산처분이익 등 비용의 구성 영업비용: 매출원가, 판매비와 관리비 영업외비용: 이자비용, 기타의 대손상각비, 단기투자자산평가손실, 기부금 등 법인세비용: 법인세비용은 수익과 비용을 차감한 이익에 의해서 계산 당기순이익(손실): 총수익 － 총비용","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"기업과 회계","slug":"[AC] 기업과 회계","date":"2013-08-24T08:14:00.000Z","updated":"2018-06-26T15:00:43.851Z","comments":true,"path":"2013/08/24/[AC] 기업과 회계/","link":"","permalink":"http://melomance.github.io/2013/08/24/[AC] 기업과 회계/","excerpt":"","text":"기업의 의미기업은 재화와 서비스를 생산하여 그것을 필요로 하는 고객에게 판매하여 이익을 창출하고, 그 이익을 기업의 이해관계자들에게 분배하거나 재투자하여 그 활동을 계속 해 나가는 조직이다. 기업은 이러한 경제활동을 수행하기 위하여 자원, 노동, 자본 등과 같은 제1차적 생산요소와 이들 제1차적 생산요소들을 결합하여 기업이 이루어지도록 하는 경영이라는 제2차적 요소를 필요로 한다. 경영자(기업가)는 1차적 생산요소를 결합하여 재화와 서비스를 생산하고, 이를 판매하여 이익을 창출함으로써 기업가치를 증대시키는 것을 목표로 하고 있다. 기업의 형태기업의 형태는 주로 자본의 출자와 이에 수반되는 책임정도에 따라 다음과 같이 분류된다. ┌─ 자연인기업: 개인기업, 조합기업사기업 └─ 법인기업: 합명회사, 합자회사, 유한회사, 주식회사 ┌─ 관청기업, 국영기업공기업 └─ 법인체기업; 공사, 공단공사혼합기업: 특수회사 자연인기업자연인기업은 자연인으로서 개인에 의해 설립되고 개인의 책임하에 운영되는 개인기업과 소수의 개인이 동업을 함으로써 그 책임을 분담하고 이익을 공유하는 조합기업으로 나눌 수 있다. 기업을 둘러싼 이해관계자가 적어서 사회에 미치는 영향이 크지 못하기 때문에 상법 등의 법령에 의한 규제와 보호가 미약하다. 개인기업 (Sole Proprietorship) 오랜 전통을 가진 기업의 형태로서 개인상인이 대표적 일반적으로 출자자, 경영자 및 기업지배자가 일치 설립과 해산이 용이하며 모든 이익이 소유자 개인에게 귀속 법인기업에 비하여 자본조달이 어렵고 자본규모가 작아 큰 자본을 필요로 하지 않는 기업에 적합 조합기업 (Partnership) 두 사람 이상의 소유에 의하여 동업의 형태로 운영되는 기업형태 (민법에 설립근거) 설립이 용이하고 정부규제가 적은 편이나 조합원들이 무한책임을 져야하며 발생된 이익을 다른 조합원들과 분배하여야 하기 때문에 분쟁 가능성 존재 법인기업법인기업은 기업의 소유자가 아닌 기업 그 자체가 실체(entity)로서 법률상의 권리능력을 가지고 영업활동을 수행하는 기업형태이다. 즉, 법인기업은 소유자와는 별개의 법인격을 가지고 각종 계약을 체결하고 구매, 판매행위 등의 경제활동을 수행함으로써 이익을 창출한다. 법인기업은 많은 이해관계자를 가지고 있으므로 상법 등의 법령에 의하여 규제와 보호를 받으며, 사회에 끼치는 영향도 크다. 합명회사 (Ordinary Partnership) 기업의 채무에 대하여 무한적으로 책임을 지는 2인 이상의 무한책임사원으로 구성된 회사 사원은 정관 또는 모든 사원의 동의로써 대표사원을 정하지 않는 한 각 사원이 회사를 대표 새로운 사원의 입사나 퇴사가 모든 사원의 동의로서만이 가능 사원상호간의 개인적인 신뢰관계를 바탕으로 한 인적기업(동족회사) 합자회사 (Limited Partnership) 1인 이상의 무한책임사원과 1인 이상의 유한책임사원으로 구성된 기업형태 무한책임사원은 출자외 회사의 업무집행을 담당 유한책임사원은 출자만 담당 유한회사 (Private Company) 보다 설립과 조직을 간편하게 하여 중소기업에 적합하도록 50명 이하의 유한책임사원으로 구성 유한책임사원은 회사에 대하여 출자의무를 부담 유한책임사원은 회사의 채권자에 대하여 아무런 책임을 지지 않음 상법규정 중 주식회사에 대한 규정과 동일한 것이 많기 때문에 회계처리도 주식회사에 대한 방법과 유사 출자자를 공개모집할 수 없으므로 설립절차가 간략하고 재무보고서를 공개할 의무도 없음 주식회사 (Stock Corporation) 자본을 중심으로 한 물적회사로서 오늘날 자본주의 경제사회에서 가장 일반적인 기업형태 상법의 규정에 따라 3인 이상의 발기인이 회사의 정관을 작성하여 법원에 설립등기를 마침으로써 설립 유한책임을 지는 주주로서 구성되며 회계에서는 회사의 생명이 영속적인 것으로 전제 자본을 조달할 수가 있으며 소유권의 이전이 증권시장을 통하여 용이하게 이루어짐 많은 이해관계자를 가지고 있어서 사회에 많은 영향을 끼침 상법 등의 명령에 의하여 정부규제를 많이 받음 기업의 유형기업은 그 업종에 따라 상품매매기업, 제조기업 및 서비스기업으로 구분된다. 상품매매기업상품매매기업(Merchandising Company)이란 상품매매를 주된 영업활동으로 하는 기업으로서, 이 업종에 속하는 기업들은 구체적인 형태를 가지는 상품의 매매를 통한 이윤획득을 목적으로 한다. 상품매매기업은 완제품으로서의 상품을 외부에서 구입하고, 추가적인 가공없이 이윤을 가산하여 외부에 판매한다는 점이 제조기업과의 차이점이다. 도매기업도매기업(Wholesale Merchandiser)은 제조기업 또는 다른 도매기업으로부터 제품(상품)을 구매한 후 이를 소매기업에게 판매하는 기업 소매기업소매기업(Retail Merchandiser)은 도매기업으로부터 상품을 구매하여(경우에 따라서는 제조기업으로부터 직접 제품(상품)을 구매하여) 최종 소비자에게 판매하는 기업 제조기업제조기업(Manufacturing Company)이란 원재료를 구입하여 이를 생산과정을 통하여 제품으로 전환한 후, 이를 외부에 판매함으로써 이윤획득을 목적으로 하는 기업이다. 제조기업에 있어서 영업활동은 구매과정, 제조(생산)과정, 판매과정을 거쳐 이루어진다. 서비스기업서비스기업(Service Company)은 구체적인 형태를 가지는 제품(상품)을 취급하지 않고 이름 그대로에서 보듯이 주된 업무로써 서비스를 제공하고 그 대가로 수수료를 받는 것을 목적으로 하는 기업이다. 서비스의 예로서는 회계법인(회계사업), 법무법인(변호사업), 의료법인, 경영자문업(컨설팅업), 운송업, 학원 등을 들 수 있다. 기업의 이해관계자기업의 경영활동과 그 성과에 따라 영향을 받는 사람들을 기업의 이해관계자(Stakeholder)라고 한다. 이해관계자는 외부이해관계자와 내부이해관계자로 구분할 수 있다. 외부이해관계자외부이해관계자로는 출자자(주주)는 물론 기업에 출자를 고려하고 있는 잠재적 출자자(주주), 기업에게 자금을 대여한 채권자, 기업에게 원재료를 공급한 공급자(vendor), 기업의 제품이나 서비스를 구입하는 고객, 기업이 소재한 지역주민, 기업활동의 규제와 조세업무를 담당하는 정부나 규제기관 등이 있다. 내부이해관계자내부 이해관계자로는 경영자와 종업원을 들 수 있다. 이해관계자는 기업에 대하여 의사결정을 함에 있어 회계정보를 사용한다. 기업과 회계정보회계정보기업의 이해관계자들은 기업의 정보를 필요로 하며, 기업은 이해관계자들과 협조적인 관계를 유지하고 이들로부터 지원을 받기 위해서는 기업의 경영에 관한 정보를 제공해야 한다. 이와 같은 정보들은 기업의 이해관계자들이 기업을 이해하는 데 필요한 정보원천이 될 뿐만 아니라 이해관계자들 상호간의 커뮤니케이션의 수단이 될 수도 있다. 기업경영에 관한 모든 자료를 일정한 절차에 따라 계량화하여 공신력 있는 독립된 제3자(공인회계사)의 확인과정을 거쳐 제공되는 정보가 회계정보이다.회계정보를 통하여 기업과 이해관계자들간에 의사소통이 이루어진다. 즉, 기업이 일정기간의 경영활동 내역을 회계장부에 기록한 후 일정기간말에 이를 요약하여 재무보고서로 이해관계자들에게 제공한다면 이들은 적은 노력과 시간으로 당해 기업의 재무상태와 경영성과 등을 파악할 수 있을 것이며, 이를 근거로 자신에 돌아올 결과를 예측할 수 있다. 분식회계경영자나 종업원의 비윤리적 행동에 의하여 기업의 실질적 내용과 회계정보가 다를 수 있다. 경영자가 의도적으로 기업의 실질과 다른 회계정보를 공시하는 것을 분식회계라고 한다. 분식회계에 의한 회계정보는 기업의 실질과 다르므로 분식회계정보에 의하여 주식에 투자를 하거나 대출을 한 이해관계자는 주가가 하락하거나 기업이 원리금을 상환하지 못해 손해를 보게 된다. 회계규제기관인 정부는 분식회계에 의해 이해관계자가 손해를 보게 되므로 분식회계를 한 기업과 경영자 및 이에 관련된 공인회계사 등을 처벌하는 등 방지대책을 마련하고 있다.","categories":[{"name":"Finance","slug":"Finance","permalink":"http://melomance.github.io/categories/Finance/"},{"name":"Accounting","slug":"Finance/Accounting","permalink":"http://melomance.github.io/categories/Finance/Accounting/"}],"tags":[{"name":"회계기초","slug":"회계기초","permalink":"http://melomance.github.io/tags/회계기초/"}]},{"title":"The Traveling Salesperson Problem(외판원 문제)","slug":"[AG][BB] The Traveling Salesperson Problem","date":"2012-01-02T11:11:00.000Z","updated":"2019-05-19T00:55:25.825Z","comments":true,"path":"2012/01/02/[AG][BB] The Traveling Salesperson Problem/","link":"","permalink":"http://melomance.github.io/2012/01/02/[AG][BB] The Traveling Salesperson Problem/","excerpt":"","text":"Suppose a salesperson is planning a sales trip that includes 20 cities. Each city is connected to some of the other cities by a road. To minimize travel time, we want to determine a shortest route that starts at the salesperson’s home city, visits each of the cities once, and ends up at the home city. This problem of determining a shortest route is called the Traveling Salesperson problem. Recall that the goal in this problem is to find the shortest path in a directed graph that starts at a given vertex, visits each vertex in the graph exactly once, and ends up back at the starting vertex. Such a path is called an optimal tour. Because it does not matter where we start, the starting vertex can simply be the first vertex. 외판원 문제는 여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어졌을 때, 모든 도시들을 단 한번씩만 방문하고 원래 시작점으로 돌아오는 최적여행경로(최소비용의 이동 순서)를 구하는 것이다. 외판원 문제는 0-1 Knapsack 문제와 함께 NP-Complete에 속한다. Example Shows the adjacency matrix representation of a graph containing five vertices, in which there is an edge from every vertex to every other vertex, and an optimal tour for that graph. Step 1 [1]을 포함하는 노드를 방문한다. (일주여행경로의 첫번째 정점으로 $v_1$을 선택)v1 minimum(14, 4, 10, 20) = 4 // 최소값 계산시 자기자신 제외v2 minimum(14, 7, 8, 7) = 7 // 최소값 계산시 자기자신 제외v3 minimum(4, 5, 7, 16) = 4 // 최소값 계산시 자기자신 제외v4 minimum(11, 7, 9, 2) = 2 // 최소값 계산시 자기자신 제외v5 minimum(18, 7, 17, 4) = 4 // 최소값 계산시 자기자신 제외[1]을 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 21minlength = ∞ Step 2 [1, 2]를 포함하는 노드를 방문한다. (일주여행경로의 두 번째 정점으로 $v_2$ 선택)v1 14 // v1 -&gt; v2는 확정이므로 14v2 minimum(7, 8, 7) = 7 // 최소값 계산시 자기자신과 v1제외(사이클 방지)v3 minimum(4, 7, 16) = 4 // 최소값 계산시 자기자신과 이미 방문한 v2 제외v4 minimum(11, 9, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v2 제외v5 minimum(18, 17, 4) = 4 // 최소값 계산시 자기자신과 이미 방문한 v2 제외[1, 2]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 31 Step 3 [1, 3]을 포함하는 노드를 방문한다. (일주여행경로의 두 번째 정점으로 $v_3$ 선택)v1 4 // v1 -&gt; v3는 확정이므로 4v2 minimum(14, 8, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v3 제외v3 minimum(5, 7, 16) = 5 // 최소값 계산시 자기자신과 시작점 v1 제외(사이클 방지)v4 minimum(11, 7, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v3 제외v5 minimum(18, 7, 4) = 4 // 최소값 계산시 자기자신과 이미 방문한 v3 제외[1, 3]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 22 Step 4~5 [1, 4], [1, 5] 방문은 Step2~3과 비슷하므로 생략 Step 6 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. 그 노드는 [1, 3]을 포함하는 노드이다. 그 노드의 자식노드부터 방문한다. Step 7 [1, 3, 2]를 포함하는 노드를 방문한다. (일주여행경로의 세 번째 정점으로 $v_2$ 선택)v1 4 // v1 -&gt; v3는 확정이므로 4v2 minimum(8, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v3, 시작점 v1 제외v3 5 // v3 -&gt; v2는 확정이므로 5v4 minimum(11, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v3, v2는 제외v5 minimum(18, 4) = 4 // 최소값 계산시 자기자신과 이미 방문한 v3, v2는 제외[1, 3, 2]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 22 Step 8 [1, 3, 4]를 포함하는 노드를 방문한다. (일주여행경로의 세 번째 정점으로 $v_4$ 선택)v1 4 // v1 -&gt; v3는 확정이므로 4v2 minimum(14, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v3, v4 제외v3 7 // v3 -&gt; v4는 확정이므로 7v4 minimum(7, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v3, 시작점 v1 제외v5 minimum(18, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v3, v4 제외[1, 3, 4]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 27 Step 9 [1, 3, 5] 방문은 Step 7~8과 비슷하므로 생략 Step10 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. 그 노드는 [1, 3, 2]를 포함하는 노드이다. 그 노드의 자식노드부터 방문한다. Step11 [1, 3, 2, 4]를 포함하는 노드를 방문한다. (일주여행경로의 네 번째 정점으로 $v_4$ 선택) 이때 남은 정점은 $v_5$하나이므로 [1, 3, 2, 4, 5, 1]이라는 일주여행경로가 확정된다.[1, 3, 2, 4, 5, 1] 일주여행경로의 길이를 계산하면 37(=4+5+8+2+18)이 된다.37 &lt; minlength = ∞ → minlength = 37[1, 5] bound = 42 &gt;= minlength = 37 // [1, 5]는 이 시점에서 유망하지 않다.[1, 3, 5] bound = 39 &gt;= minlength = 37 // [1, 3, 5]는 이 시점에서 유망하지 않다. Step12 [1, 3, 2, 5]를 포함하는 노드를 방문한다. (일주여행경로의 네 번째 정점으로 $v_5$ 선택) 이때 남은 정점은 $v_4$하나이므로 [1, 3, 2, 5, 4, 1]이라는 일주여행경로가 확정된다.[1, 3, 2, 5, 4, 1] 일주여행경로의 길이를 계산하면 31(=4+5+7+4+11)이 된다.31 &lt; minlength = 37 → minlength = 31[1, 2] bound = 31 &gt;= minlength = 31 // [1, 2]는 이 시점에서 유망하지 않다. Step13 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. 그 노드는 [1, 3, 4]를 포함하는 노드이다. 그 노드의 자식노드부터 방문한다. Step14 [1, 3, 4, 2]를 포함하는 노드를 방문한다. 이때 남은 정점은 $v_5$하나이므로 [1, 3, 4, 2, 5, 1]이라는 일주여행경로가 확정된다.[1, 3, 4, 2, 5, 1] 일주여행경로의 길이를 계산하면 43(=4+7+7+7+18)이 된다. Step15 [1, 3, 4, 5]를 포함하는 노드를 방문한다. 이때 남은 정점은 $v_2$하나이므로 [1, 3, 4, 5, 2, 1]이라는 일주여행경로가 확정된다.[1, 3, 4, 5, 2, 1] 일주여행경로의 길이를 계산하면 34(=4+7+2+7+14)가 된다. Step16 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. [1, 4]를 포함하는 노드가 유일하다. 그 노드의 자식노드부터 방문한다. Step17 [1, 4, 2]를 포함하는 노드를 방문한다.v1 10 // v1 -&gt; v4는 확정이므로 10v2 minimum(7, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v4, 시작점 v1 제외v3 minimum(4, 16) = 4 // 최소값 계산시 자기자신과 이미 방문한 v4, v2 제외v4 = 7 // v4 -&gt; v2는 확정이므로 7v5 minimum(18, 17) = 17 // 최소값 계산시 자기자신과 이미 방문한 v4, v2 제외[1, 4, 2] bound = 45 &gt;= minlength = 31 // [1, 4, 2]는 유망하지 않다. Step18 [1, 4, 3]를 포함하는 노드를 방문한다.v1 10 // v1 -&gt; v4는 확정이므로 10v2 minimum(14, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v4, v3 제외v3 minimum(5, 16) = 5 // 최소값 계산시 자기자신과 이미 방문한 v4, 시작점 v1 제외v4 = 9 // v4 -&gt; v3는 확정이므로 9v5 minimum(18, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v4, v3 제외[1, 4, 3] bound = 38 &gt;= minlength = 31 // [1, 4, 3]은 유망하지 않다. Step19 [1, 4, 5]를 포함하는 노드를 방문한다.v1 10 // v1 -&gt; v4는 확정이므로 10v2 minimum(14, 7) = 7 // 최소값 계산시 자기자신과 이미 방문한 v4, v5 제외v3 minimum(4, 5) = 4 // 최소값 계산시 자기자신과 이미 방문한 v4, v5 제외v4 = 2 // v4 -&gt; v5는 확정이므로 2v5 minimum(7, 17) = 7 // 최소값 계산시 자기자신과 이미 방문한 v4, 시작점 v1 제외[1, 4, 5]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 30 Step20 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. [1, 4, 5]를 포함하는 노드가 유일하다. 그 노드의 자식노드부터 방문한다. Step21 [1, 4, 5, 2]를 포함하는 노드를 방문한다. 이때 남은 정점은 $v_3$하나이므로 [1, 4, 5, 2, 3, 1]이라는 일주여행경로가 확정된다.[1, 4, 5, 2, 3, 1] 일주여행경로의 길이를 계산하면 30(=10+2+7+7+4)이 된다.30 &lt; minlength = 31 → minlength = 30 Step22 [1, 4, 5, 3]을 포함하는 노드를 방문한다. 이때 남은 정점은 $v_2$하나이므로 [1, 4, 5, 3, 2, 1]이라는 일주여행경로가 확정된다.[1, 4, 5, 3, 2, 1] 일주여행경로의 길이를 계산하면 48(=10+2+17+5+14)이 된다. Step23 bound 값이 가장 작으면서 유망하고 확장하지 않은 노드를 결정한다. 해당하는 노드가 없으므로 알고리즘은 종료된다. 일주여행경로 [1, 4, 5, 2]를 포함하는 노드가 최적 일주여행경로([1, 4, 5, 2, 3, 1])이고, 그 길이는 30이다. The Best-First Search with Branch-and-Bound Pruning Algorithm for the Traveling Salesperson ProblemAlgorithm DesignAn obvious state space tree for this problem is one in which each vertex other than the starting one is tried as the first vertex (after the starting one) at level 1, each vertex other than the starting one and the one chosen at level 1 is tried as the second vertex at level 2, and so on. A portion of this state space tree, in which there are five vertices and in which there is an edge from every vertex to every other vertex, is shown in the below Figure. In what follows, the term “node” means a node in the state space tree, and the term “vertex” means a vertex in the graph. At each node in the below Figure, we have included the path chosen up to that node. For simplicity, we have denoted a vertex in the graph simply by its index. A node that is not a leaf represents all those tours that start with the path stored at that node. For example, the node containing [1, 2, 3] represents all those tours that start with the path [1, 2, 3]. That is, it represents the tours [1, 2, 3, 4, 5, 1] and [1, 2, 3, 5, 4, 1]. Each leaf represents a tour. We need to find a leaf that contains an optimal tour. We stop expanding the tree when there are four vertices in the path stored at a node because, at that time, the fifth one is uniquely determined. For example, the far-left leaf represents the tour [1, 2, 3, 4, 5, 1] because once we have specified the path [1, 2, 3, 4], the next vertex must be the fifth one. 외판원 문제에 대한 상태공간 트리를 만드는 방법은 다음과 같다. 각 노드는 출발 노드로부터의 일주 여행 경로를 나타내게 된다. 예를 들어 루트노드의 여행 경로는 [1]이 되고, 루트노드에서 뻗어 나가는 레벨 1의 여행 경로는 각각 [1, 2], [1, 3], …, [1, 5]가 된다. 노드 [1, 2]에서 뻗어 나가는 레벨 2에 있는 노드들의 여행 경로는 각각 [1, 2, 3], …, [1, 2, 5]가 되며, 같은 방식으로 한 단계씩 레벨을 확장해 나가면서 잎노드에 도달하면 완전한 일주여행경로를 가지게 된다. 최적화된 일주여행경로를 구하기 위해서는 잎 노드에 있는 일주여행경로를 모두 검사하여 그 중에서 길이가 가장 짧은 값을 찾으면 된다. To use best-first search, we need to be able to determine a bound for each node. we need to determine a lower bound on the length of any tour that can be obtained by expanding beyond a given node, and we call the node promising only if its bound is less than the current minimum tour length. We can obtain a bound as follows. In any tour, the length of the edge taken when leaving a vertex must be at least as great as the length of the shortest edge emanating from that vertex. Therefore, a lower bound on the cost (length of the edge taken) of leaving vertex $v_1$ is given by the minimum of all the nonzero entries in row 1 of the adjacency matrix, a lower bound on the cost of leaving vertex $v_2$ is given by the minimum of all the nonzero entries in row 2, and so on. In the same way, we can obtain a lower bound on the length of a tour that can be obtained by expanding beyond any node in the state space tree, and we use these lower bounds in our best-first search. bound 값을 계산하는 방법은 다음과 같다. 어떤 일주여행경로라도 한 정점을 떠날 때 선택한 이음선의 길이는 그 정점에서 나오는 가장 짧은 이음선의 길이만큼은 최소한 길다. 그러므로 정점 $v_1$을 떠나는 비용의 하한은 인접행렬의 첫 번째 행에서 0이 아닌 모든 값 중에서 최소값이 되고, $v_2$를 떠나는 비용의 하한은 인접행렬의 2번째 행에서 0이 아닌 모든 값 중에서 최소값이 되고, …, 이런 식으로 각 정점들에 대해 최소값을 계산한다. 각 일주여행경로는 정점을 정확히 각각 한 번씩 떠나야 하기 때문에, 일주여행경로 길이의 bound는 이 최소값들의 합이다. 같은 방법으로 상태공간트리에서 주어진 노드 이후로부터 확장하여 구할 수 있는 일주여행경로길이의 bound 값을 계산할 수 있고, 이 bound 값을 최고우선탐색에 사용할 수 있다. v1 minimum(14, 4, 10, 20) = 4 // 최소값 계산시 자기자신 제외v2 minimum(14, 7, 8, 7) = 7 // 최소값 계산시 자기자신 제외v3 minimum(4, 5, 7, 16) = 4 // 최소값 계산시 자기자신 제외v4 minimum(11, 7, 9, 2) = 2 // 최소값 계산시 자기자신 제외v5 minimum(18, 7, 17, 4) = 4 // 최소값 계산시 자기자신 제외[1]을 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 21v1 14 // v1 -&gt; v2는 확정이므로 14v2 minimum(7, 8, 7) = 7 // 최소값 계산시 자기자신과 시작점 v1제외(사이클 방지)v3 minimum(4, 7, 16) = 4 // 최소값 계산시 자기자신과 이미 방문한 v2 제외v4 minimum(11, 9, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v2 제외v5 minimum(18, 17, 4) = 4 // 최소값 계산시 자기자신과 이미 방문한 v2 제외[1, 2]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 31v1 14 // v1 -&gt; v2는 확정이므로 14v2 = 7 // v2 -&gt; v3는 확정이므로 7v3 minimum(7, 16) = 7 // 최소값 계산시 자기자신과 이미 방문한 v2, 시작점 v1 제외v4 minimum(11, 2) = 2 // 최소값 계산시 자기자신과 이미 방문한 v2, v3 제외v5 minimum(18, 4) = 4 // 최소값 계산시 자기자신과 이미 방문한 v2, v3 제외[1, 2, 3]를 포함한 노드에서 확장하여 구한 일주여행경로길이의 bound = 34 Pseudo Code// We will use the following data type in the algorithm.struct node&#123; int level; ordered_set path; number bound;&#125;void travel2(int n, const number W[][], ordered_set &amp;opttour, number &amp;minlength)&#123; priority_queue_of_node PQ; node u, v; initialize(PQ); // Initialize PQ to be empty. v.level = 0; v.path = [1]; // Make first vertex the starting one. v.bound = bound(v); minlength = INFINITE; insert(PQ, v); while (!empty(PQ)) &#123; remove(PQ, v); // Remove node with best bound. if (v.bound &lt; minlength) &#123; u.level = v.level + 1; for ((all i such that 2 &lt; i &lt; n) &amp;&amp; (i is not in v.path)) &#123; // e.g. first copy [1 3] to make paths [1 3 2], [1 3 4], [1 3 5] u.path = v.path; put i at the end of u.path; if (u.level == n-2) &#123; // Check if next vertex completes a tour. put index of only vertex not in u.path at the end of u.path; put 1 at the end of u.path; // Make first vertex last one. // Function length computes the length of the tour. if (length(u) &lt; minlength) &#123; minlength = length(u); opttour = u.path; &#125; &#125; else &#123; u.bound = bound(u); if (u.bound &lt; minlength) insert(PQ, u); &#125; &#125; &#125; &#125;&#125; Source Code// File: travel2.h#ifndef TRAVELING_SALESPERSON_H#define TRAVELING_SALESPERSON_H#include \"pqueue.h\" // Provides priority_queue and node#include \"graph.h\" // Provides graphusing namespace data_structures; // for graph and nodenamespace algorithms&#123; void travel2(const int n, graph W, std::vector&lt;int&gt;&amp; opttour, int&amp; minlength); // Problem: Determine an optimal tour in a weighted, directed graph. The weights // are nonnegative numbers. // Inputs: a weighted, directed graph, and n, the number of vertices in // the graph. The graph is represented by a graph class, which has both its // rows and columns indexed from 1 to n, where W.get_edge(i, j) is the weight // on the edge from the ith vertex to the jth vertex. // Outputs: variable minlength, whose value is the length of an optimal tour, // and variable optour, whose value is an optimal tour. int length(node u, graph W); // Inputs: a weighted, directed graph, and node. // Outputs: Returns the length of the tour u.path int bound(node u, graph W, const int n, int ptah_strt_vertex); // Inputs: a weighted, directed graph, node, and n, the number of vertices // in the graph. // Outputs: Returns the bound for a node. // Helper function int find_minedge_case1(graph W, int curr_vertex); int find_minedge_case2(graph W, int curr_vertex, bool* visited, int path_strt_vertex); int find_minedge_case3(graph W, int curr_vertex, bool* visited, int path_strt_vertex, node u); int find_unvisited_vertex(node u, const int n);&#125;#endif // File: travel2.cpp#include \"travel2.h\"#include &lt;iostream&gt; // Provides cout and endl#include &lt;iomanip&gt;#include &lt;cassert&gt;using namespace std;namespace algorithms&#123; void travel2(const int n, graph W, vector&lt;int&gt;&amp; opttour, int&amp; minlength) &#123; priority_queue PQ; node u, v; const int start_vertex = 1; // Make first vertex the starting one. assert(PQ.is_empty( )); // Initialize PQ to be empty. v.level = 0; v.path.push_back(start_vertex); v.bound = bound(v, W, n, start_vertex); minlength = W.INFINITE; PQ.insert(v); while (!PQ.is_empty( )) &#123; //PQ.print_tree(\"The tree:\", 0); v = PQ.get_front( ); // Remove node with best bound. if (v.bound &lt; minlength) &#123; u.level = v.level + 1; // Set u to a child of v. for (int i = 1; i &lt;= n; ++i) &#123; bool visited = false; vector&lt;int&gt;::iterator itr; // Find i(2 &lt;= i &lt;= n) that is not in v.path for (itr = v.path.begin( ); itr != v.path.end( ); ++itr) &#123; if (*itr == i) visited = true; &#125; if (!visited) &#123; // Copy and Put i at the end of u.path. u.path = v.path; u.path.push_back(i); // Check if next vertex completes a tour. if (u.level == n-2) &#123; // Put index of only vertex not in u.path at the end of u.path. int last_vertex = find_unvisited_vertex(u, n); u.path.push_back(last_vertex); // Put 1 at the end of u.path. (Make first vertex last one) u.path.push_back(start_vertex); // Function length computes the length of the tour. int tour_length = length(u, W); if (tour_length &lt; minlength) &#123; minlength = tour_length; opttour = u.path; &#125; &#125; else &#123; u.bound = bound(u, W, n, start_vertex); if (u.bound &lt; minlength) PQ.insert(u); &#125; cout &lt;&lt; \"[\" ; vector&lt;int&gt;::iterator itr; for (itr = u.path.begin(); itr != u.path.end(); ++itr) &#123; cout &lt;&lt; *itr; if (!(itr+1 == u.path.end())) cout &lt;&lt; \", \"; &#125; cout &lt;&lt; \"]\" &lt;&lt; \" Bound = \" &lt;&lt; bound(u, W, n, start_vertex); cout &lt;&lt; \", minlenth = \" &lt;&lt; minlength &lt;&lt; endl; &#125; &#125; &#125; else &#123; cout &lt;&lt; \"prunning is ... \"; cout &lt;&lt; \"[\" ; vector&lt;int&gt;::iterator itr; for (itr = v.path.begin(); itr != v.path.end(); ++itr) &#123; cout &lt;&lt; *itr; if (!(itr+1 == v.path.end())) cout &lt;&lt; \", \"; &#125; cout &lt;&lt; \"]\" &lt;&lt; \" Bound = \" &lt;&lt; v.bound &lt;&lt; \" &gt;= minlength\" &lt;&lt; endl; &#125; &#125; &#125; // Returns the bound for a node. int bound(node u, graph W, const int n, int path_strt_vertex) &#123; int minimum; int answer = 0; bool* visited; vector&lt;int&gt;::iterator itr; visited = new bool[n]; // dynamic allocation --visited; // pointer offset // initialization for (int i = 1; i &lt;= n; ++i) visited[i] = false; // marking only visited vertex e.g. [1,2].. for (itr = u.path.begin( ); itr != u.path.end( ); ++itr) visited[*itr] = true; for (int i = 1; i &lt;= n; ++i) // n is equal to the number of vertices &#123; minimum = W.INFINITE; if (u.path.capacity( ) == 1) // only one path exists &#123; minimum = find_minedge_case1(W, i); &#125; else &#123; if (!visited[i]) // unvisted vertex_i -&gt; find minimum edge minimum = find_minedge_case2(W, i, visited, path_strt_vertex); else // visited vertex_i -&gt; (1 to i-1) determin. edge + find minimum edge minimum = find_minedge_case3(W, i, visited, path_strt_vertex, u); &#125; answer += minimum; &#125; delete [ ] (visited + 1); // deallocation return answer; &#125; // Helper function int find_minedge_case1(graph W, int curr_vertex) &#123; int minimum = W.INFINITE; // CASE1 : Only one vertex exists in this path // e.g. path = [1], i = 1 -&gt; minimum = min(v2, v3, v4, v5) // path = [1], i = 2 -&gt; minimum = min(v1, v3, v4, v5) // ... // path = [1], i = 5 -&gt; minimum = min(v1, v2, v3, v4) for (int j = 1; j &lt;= W.get_size( ); ++j) &#123; if (curr_vertex != j &amp;&amp; W.get_edge(curr_vertex, j) &lt; minimum) minimum = W.get_edge(curr_vertex, j); &#125; return minimum; &#125; // Helper function int find_minedge_case2(graph W, int curr_vertex, bool* visited, int path_strt_vertex) &#123; int minimum = W.INFINITE; // CASE2 : i is one of unvisiteid vertexs. // e.g. path = [1, 2], i = 3 -&gt; minimum = min(v1, v4, v5) // i = 4 -&gt; minimum = min(v1, v3, v5) // i = 5 -&gt; minimum = min(v1, v3, v4) // (j != start_vertex &amp;&amp; visited[j]) is excluded from calculations for (int j = 1; j &lt;= W.get_size( ); ++j) &#123; if (curr_vertex != j &amp;&amp; W.get_edge(curr_vertex, j) &lt; minimum) &#123; if (j != path_strt_vertex &amp;&amp; visited[j]) ; // do nothing else minimum = W.get_edge(curr_vertex, j); &#125; &#125; return minimum; &#125; int find_minedge_case3(graph W, int curr_vertex, bool* visited, int path_strt_vertex, node u) &#123; int minimum = W.INFINITE; vector&lt;int&gt;::iterator curr_itr, next_itr; curr_itr = next_itr = u.path.begin( ); // CASE3 : i is one of visited vertex. // e.g. path = [1, 2, 3], i = 1 -&gt; minimum = graph.get_edge(1, 2) // i = 2 -&gt; minimum = graph.get_edge(2, 3) // i = 3 -&gt; minimum = min(v4, v5) // (j == path_strt_vertex || visited[j]) is excluded from calculations for (curr_itr = u.path.begin( ); curr_itr != u.path.end( ); ++curr_itr) &#123; if (*curr_itr == curr_vertex) &#123; next_itr = curr_itr + 1; if (next_itr != u.path.end( )) &#123; // [1, 2, 3] -&gt; get_edge(1, 2) and get_edge(2, 3) minimum = W.get_edge(*curr_itr, *next_itr); break; &#125; else &#123; for (int j = 1; j &lt;= W.get_size( ); ++j) &#123; if (curr_vertex != j &amp;&amp; W.get_edge(curr_vertex, j) &lt; minimum) &#123; if (j == path_strt_vertex || visited[j]) ; // do nothing else minimum = W.get_edge(curr_vertex, j); &#125; &#125; break; &#125; &#125; &#125; return minimum; &#125; // Returns the length of the tour u.path int length(node u, graph W) &#123; int answer = 0; vector&lt;int&gt;::iterator itr; vector&lt;int&gt;::iterator end_itr; for (itr = u.path.begin( ); itr != u.path.end( ); ++itr) &#123; end_itr = itr; if ((itr + 1) == u.path.end( )) break; answer += W.get_edge(*itr, *(itr+1)); &#125; answer += W.get_edge(*end_itr, u.path.front( )); return answer; &#125; // Helper function int find_unvisited_vertex(node u, const int n) &#123; int unvisited_vertex; bool* visited = new bool[n]; --visited; // pointer offset // initialization for (int j = 1; j &lt;= n; ++j) visited[j] = false; // mark visited vertex for (vector&lt;int&gt;::iterator itr = u.path.begin( ); itr != u.path.end( ); ++itr) &#123; for (int j = 1; j &lt;=n ; ++j) &#123; if (*itr == j) &#123; visited[*itr] = true; break; &#125; &#125; &#125; // find unvisited vertex for (int j = 1; j &lt;= n; ++j) &#123; if (visited[j] == false) &#123; unvisited_vertex = j; break; &#125; &#125; delete [ ](visited+1); return unvisited_vertex; &#125;&#125; // File: opttour.cpp#include &lt;iostream&gt; // Provides cout and endl#include &lt;cstdlib&gt;#include &lt;vector&gt;#include \"travel2.h\" // Provides trave2( ) method#include \"pqueue.h\" // Provides priorty queue#include \"graph.h\" // Provides graphusing namespace std;using namespace algorithms;int main( )&#123; // Graph initialization graph example; example.set_vertex(\"V1\"); example.set_vertex(\"V2\"); example.set_vertex(\"V3\"); example.set_vertex(\"V4\"); example.set_vertex(\"V5\"); // from V1 to Vn example.set_edge(1, 2, 14); example.set_edge(1, 3, 4); example.set_edge(1, 4, 10); example.set_edge(1, 5, 20); // from V2 to Vn example.set_edge(2, 1, 14); example.set_edge(2, 3, 7); example.set_edge(2, 4, 8); example.set_edge(2, 5, 7); // from V3 to Vn example.set_edge(3, 1, 4); example.set_edge(3, 2, 5); example.set_edge(3, 4, 7); example.set_edge(3, 5, 16); // from V4 to Vn example.set_edge(4, 1, 11); example.set_edge(4, 2, 7); example.set_edge(4, 3, 9); example.set_edge(4, 5, 2); // from V5 to Vn example.set_edge(5, 1, 18); example.set_edge(5, 2, 7); example.set_edge(5, 3, 17); example.set_edge(5, 4, 4); travel2(example.get_size( ), example, tsp, min); cout &lt;&lt; \"minlength: \" &lt;&lt; min &lt;&lt; endl; cout &lt;&lt; \"[\"; for (itr = tsp.begin( ); itr != tsp.end( ); ++itr) cout &lt;&lt; *itr &lt;&lt;\", \"; cout &lt;&lt; \"]\" &lt;&lt; endl; return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + (n-1) + (n-1)(n-2) + … + (n-1)(n-2)…(n-k) = n!$ 현 여행경로에서 미방문정점들을 하나씩 추가하며 상태공간트리를 구축한다. 따라서 상태공간트리 내 전체 노드의 수는 최대 $n!$개가 된다. 최악의 경우 방문하는 노드의 총 수는 계승으로 지수보다 나쁘다. 하지만 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 알고리즘의 효율은 더 좋을 수 있다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Branch and Bound","slug":"Algorithms/Branch-and-Bound","permalink":"http://melomance.github.io/categories/Algorithms/Branch-and-Bound/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분기한정법","slug":"분기한정법","permalink":"http://melomance.github.io/tags/분기한정법/"}]},{"title":"Branch-and-Bound with the 0-1 Knapsack problem(Best-First Search)(0-1 배낭 문제-최고우선탐색)","slug":"[AG][BB] 0-1 Knapsack Problem3","date":"2011-12-27T02:50:00.000Z","updated":"2019-05-12T13:57:24.377Z","comments":true,"path":"2011/12/27/[AG][BB] 0-1 Knapsack Problem3/","link":"","permalink":"http://melomance.github.io/2011/12/27/[AG][BB] 0-1 Knapsack Problem3/","excerpt":"","text":"In general, the breadth-first search strategy has no advantage over a depth-first search (backtracking). However, we can improve our search by using our bound to do more than just determine whether a node is promising. After visiting all the children of a given node, we can look at all the promising, unexpanded nodes and expand beyond the one with the best bound. Recall that a node is promising if its bound is better than the value of the best solution found so far. In this way, we often arrive at an optimal solution more quickly than if we simply proceeded blindly in a predetermined order. The example that follows illustrates this method. 0-1 배낭 문제에 최고우선탐색을 적용하기에 앞서 깊이우선탐색(백트래킹)과 너비우선탐색으로 해결하는 법을 살펴봤다. 일반적으로 너비우선탐색은 깊이우선탐색보다 좋은 점이 없었다. 하지만 최고우선탐색에서는 bound 값을 노드의 유망성 여부를 판단하는 것 외에 추가적으로 사용하여 알고리즘의 효율을 향상시킨다. 최고우선탐색은 어떤 노드의 모든 자식노드를 방문한 후 유망하면서 미확장된 노드 모두를 살펴보고 그 중 bound 값이 가장 좋은 노드를 우선으로 확장한다. 지금까지 찾은 최고의 해답보다 그 bound 값이 더 좋다면 그 노드는 유망하다. 이렇게 하면 미리 결정된 순서(깊이우선탐색, 너비우선탐색)대로 탐색을 진행하는 것보다 더 빨리 최적 해를 찾게된다. Example Suppose that n = 4, W = 16, and we have the following: i $p_i$ $w_i$ $p_i / w_i$ 1 $40 2 $20 2 $30 5 $6 3 $50 10 $5 4 $10 5 $2 Step 1 루트노드(0,0)를 방문한다.[profit = 0], [weight = 0], [bound = 115(= 40 + 30 + (16 - 7) x 50/10)]maxprofit = 0 Step 2 노드(1,1)을 방문한다.[profit = 40], [weight = 2], [bound = 115](2 &lt;= 16(W)) &amp;&amp; (40 &gt; 0(current maxprofit)) → maxprofit = 40 Step 3 노드(1,2)를 방문한다.[profit = 0], [weight = 0], [bound = 82(= 30 + 50 + (16 - 15) x 10/5)](0 &lt;= 16(W)) &amp;&amp; (0 &gt; 40(current maxprofit)) → false Step 4 아직 확장하지 않은 노드 중에서 가장 큰 bound를 가진 유망한 노드를 찾는다. 노드(1,1) bound = 115 &gt; 노드(1,2) bound = 82 이므로, 노드(1,1)이 bound가 가장 크면서 유망하고 확장하지 않은 노드이다. 따라서 그 노드의 자식노드(2,1)를 다음으로 방문한다. Step 5 노드(2,1)을 방문한다.[profit = 70], [weight = 7], [bound = 115](7 &lt;= 16(W)) &amp;&amp; (70 &gt; 40(current maxprofit)) → maxprofit = 70 Step 6 노드(2,2)를 방문한다.[profit = 40], [weight = 2], [bound = 98(= 40 + 50 + (16 - 12) x 10/5)](2 &lt;= 16(W)) &amp;&amp; (40 &gt; 70(current maxprofit)) → false Step 7 아직 확장하지 않은 노드 중에서 가장 큰 bound를 가진 유망한 노드를 찾는다. 노드(2,1) bound = 115 &gt; 노드(2,2) bound = 98 &gt; 노드(1,2) bound = 82 이므로 노드(2,1)의 자식노드인 (3,1)를 다음으로 방문한다. Step 8 노드(3,1)을 방문한다.[profit = 120], [weight = 17], [bound = 0](17 &lt;= 16(W)) &amp;&amp; (120 &gt; 70(current maxprofit)) → falseweight가 W를 초과했으므로 bound 값을 0으로 놓아 유망하지 않다고 표시한다. Step 9 노드(3,2)를 방문한다.[profit = 70], [weight = 7], [bound = 80(= 40 + 30 + 10](7 &lt;= 16(W)) &amp;&amp; (70 &gt; 70(current maxprofit)) → false Step10 아직 확장하지 않은 노드 중에서 가장 큰 bound를 가진 유망한 노드를 찾는다. 노드(2,2) bound = 98 &gt; 노드(1,2) bound = 82 &gt; 노드(3,2) bound = 80 이므로 노드(2,2)의 자식노드인 (3,3)을 다음으로 방문한다. Step11 노드 (3,3)을 방문한다.[profit = 90], [weight = 12], [bound = 98(= 40 + 50 + (16 - 12) x 10/5)](12 &lt;= 16(w)) &amp;&amp; (90 &gt; 70(current maxprofit)) → maxprofit = 9082(=노드(1,2) bound) &lt;= 90 → 이 시점에서 노드(1,2)는 유망하지 않다고 결정한다.80(=노드(3,2) bound) &lt;= 90 → 이 시점에서 노드(3,2)는 유망하지 않다고 결정한다. Step12 노드(3,4)를 방문한다.[profit = 40], [weight = 2], [bound = 50(= 40 + 10)](2 &lt;= 16(W)) &amp;&amp; (40 &gt; 90(current maxprofit)) → false50(=노드(3,4) bound) &lt;= 90 → 노드(3,4)는 유망하지 않다고 결정한다. Step13 아직 확장하지 않은 노드 중에서 가장 큰 bound를 가진 유망한 노드를 찾는다. 유일하게 확장되지 않고 남은 유망한 노드는 (3,3)이다. 그 노드의 자식노드인 (4,1)을 다음으로 방문한다. Step14 노드(4,1)을 방문한다.[profit = 100], [weight = 17], [bound = 0](17 &lt;= 16(W)) &amp;&amp; (100 &gt; 90(current maxprofit)) → falseweight가 W를 초과했으므로 bound 값을 0으로 놓아 유망하지 않다고 표시한다. Step15 노드(4,2)를 방문한다.[profit = 90], [weight = 12], [bound = 90(= 40 + 50)](12 &lt;= 16(W)) &amp;&amp; (90 &gt; 90(current maxprofit)) → false90(=노드(4,2) bound) &lt;= 90 → 노드(4,2)는 유망하지 않다고 결정한다. End Because there are now no promising, unexpanded nodes, we are done. 상태공간트리에서 잎노드들은 그 bound 값이 maxprofit을 넘을 수 없으므로 자동으로 유망하지 않게 된다. 유망하면서 미확장된 노드가 없으므로 알고리즘이 종료된다. It must be stressed, however, that there is no guarantee that the node that appears to be best will actually lead to an optimal solution. In Example, node (2,1) appears to be better than node (2,2), but node (2,2) leads to the optimal solution. In general, best-first search can still end up creating most or all of the state space tree for some instances. 위의 예제에서 노드(2,1)이 노드(2,2)보다 더 좋아보였지만 노드(2,2)가 해답을 이끌어낸다. 즉, 최고라고 여겨지는 노드에서 최적의 해가 나온다는 보장은 없다. The Best-First Search with Branch-and-Bound Pruning Algorithm for the 0-1 Knapsack ProblemAlgorithm Design$$\\begin{align}totweight &amp;= weight + \\sum_{j=i+1}^{k-1}w_j \\\\bound &amp;= \\left(profit + \\sum_{j=i+1}^{k-1}p_j\\right) + (W - totweight) \\times \\frac{w_k}{p_k}\\end{align}$$ profit: the sum of the profits of the items included up to the node. weight: the sum of the weights of those items. totweight: the sum of the weights could be obtained by expanding beyond that node (W를 초과할 수 없다.) bound: the upper bound on the profit that could be obtained by expanding beyond that node. Recall that a node is also nonpromising if $$weight &lt;= W$$ The implementation of best-first search consists of a simple modification to breadth-first search. Instead of using a queue, we use a priority queue. 너비우선탐색을 조금 변형하면 최고우선탐색을 구현할 수 있다. 최고의 bound 값을 가진 노드를 우선적으로 선택하기 위해 단순 큐 대신 우선순위 큐(Priority Queue)가 사용된다. Besides using a priority queue instead of a queue, we have added a check following the removal of a node from the priority queue. The check determines if the bound for the node is still better than best. This is how we determine that a node has become nonpromising after visiting the node. For example, node (1, 2) is promising at the time we visit it. In our implementation, this is when we insert it in PQ. However, it becomes nonpromising when maxprofit takes the value 90. In our implementation, this is before we remove it from PQ. We learn this by comparing its bound with maxprofit after removing it from PQ. In this way, we avoid visiting children of a node that becomes nonpromising after it is visited. 우선순위 큐에서 노드를 제거한 후 노드의 bound 값이 maxprofit 보다 아직 좋은지를 결정하는 검사를 추가했다. 예를 들어 노드 (1,2)는 방문 당시에는 유망하지만, 노드(3,3)을 방문하면서 maxprofit 값이 90이 될 때 유망하지 않게 된다. 이런식으로 더 이상 유망하지 않은 노드의 자식노드를 방문하지 못하게 한다. Pseudo Codevoid best_first_branch_and_bound (state_space_tree T, number&amp; best)&#123; priority_queue_of_node PQ; node u, v; initialize(PQ); // Initialize PQ to empty v = root of T; best = value(v); insert(PQ,v); while(!empty(PQ)) // Remove node with best bound &#123; remove(PQ,v); if (bound(v) is better than best) // Check if node is still promising &#123; for (each child u of v) &#123; if (value(u) is better than best) best = value(u); if (bound(u) is better than best) insert(PQ,u); &#125; &#125; &#125;&#125; Source Code// File: knapsack_bestfs.h#ifndef KNAPSACK_BESTFS_H#define KNAPSACK_BESTFS_H#include \"pqueue.h\" // Provides priority_queueusing namespace data_structures; // for nodenamespace algorithms&#123; void knapsack3(int n, const int p[ ], const int w[ ], int W, int&amp; maxprofit); // Problem: Let n items be given, where each item has a weight and // a profit. The weights and profits are positive integers. Furthermore, // let a positive integer W be given. Determine a set of items with // maximum total profit, under the constraint that the sum of their // weights cannot exceed W . // Inputs: positive integers n and W , arrays of positive integers // w and p, each indexed from 1 to n, and each of which is sorted in // nonincreasing order according to the values of p[i] / w [i]. // Outputs: an integer maxprofit that is the sum of the profits in an // optimal set. float bound(node u, int n, const int p[ ], const int w[ ], int W);&#125;#endif // File: knapsack_bestfs.cpp#include &lt;cassert&gt; // Provides assert#include &lt;iostream&gt; // Provides cout and endl#include &lt;iomanip&gt;#include \"knapsack_bestfs.h\"using namespace std;namespace algorithms&#123; void knapsack3(int n, const int p[ ], const int w[ ], int W, int&amp; maxprofit) &#123; int prm_node_cnt = 0; // The number of promising nodes int nprm_node_cnt = 0; // The number of non-promising nodes priority_queue PQ; node u, v; assert(PQ.is_empty( )); // Initialize PQ to be empty. v.level = 0; v.profit = 0; v.weight = 0; // Initialize v to be the root. maxprofit = 0; v.bound = bound(v, n, p, w, W); PQ.insert(v); while (!PQ.is_empty( )) &#123; v = PQ.get_front( ); // Remove node with best bound. cout &lt;&lt; \"level: \" &lt;&lt; setw(1) &lt;&lt; v.level &lt;&lt; setw(10) &lt;&lt; \"profit: \" &lt;&lt; setw(2) &lt;&lt; v.profit &lt;&lt; setw(10) &lt;&lt; \"weight: \" &lt;&lt; setw(2) &lt;&lt; v.weight &lt;&lt; setw(10) &lt;&lt; \"bound: \" &lt;&lt; setw(2) &lt;&lt; v.bound &lt;&lt; endl; if (v.bound &gt; maxprofit) // Check if node is still promising. &#123; // Set u to the child that includes the next item. u.level = v.level + 1; u.weight = v.weight + w[u.level]; u.profit = v.profit + p[u.level]; if (u.weight &lt;= W &amp;&amp; u.profit &gt; maxprofit) maxprofit = u.profit; u.bound = bound(u, n, p, w, W); if (u.bound &gt; maxprofit) PQ.insert(u); else &#123; // Count the number of non-promising nodes ++nprm_node_cnt; &#125; // Set u to the child that does not include the next item. u.weight = v.weight; u.profit = v.profit; u.bound = bound(u, n, p, w, W); if (u.bound &gt; maxprofit) PQ.insert(u); else &#123; // Count the number of non-promising nodes ++nprm_node_cnt; &#125; // Count the number of promising nodes ++prm_node_cnt; &#125; else &#123; // Count the number of non-promising nodes ++nprm_node_cnt; &#125; &#125; cout &lt;&lt; endl &lt;&lt; \"The number of promising node: \" &lt;&lt; prm_node_cnt &lt;&lt; endl; cout &lt;&lt; \"The number of non-promising node: \" &lt;&lt; nprm_node_cnt &lt;&lt; endl; &#125; float bound(node u, int n, const int p[ ], const int w[ ], int W) &#123; int j, k; int totweight; float result; if (u.weight &gt;= W) return 0; else &#123; result = (float)u.profit; j = u.level + 1; totweight = u.weight; while (j &lt;= n &amp;&amp; totweight + w[j] &lt;= W) &#123; // Grab as many items as possible. totweight = totweight + w[j]; result = result + p[j]; ++j; &#125; k = j; // Use k for consistency with formula in text. if (k &lt;= n) // Grab fraction of kth item. result = result + (W - totweight) * (p[k] / w[k]); return result; &#125; &#125;&#125; // File: maxtotprofit.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include \"knapsack_bestfs.h\"using namespace std;using namespace algorithms;const int n = 4;const int W = 16;int w[n+1] = &#123;0, 2, 5, 10, 5&#125;; // w[0] is meaninglessint p[n+1] = &#123;0, 40, 30, 50, 10&#125;; // p[0] is meaninglessint main( )&#123; clock_t start, end; int maxprofit = 0; start = clock( ); knapsack3(n, p, w, W, maxprofit); end = clock( ); cout &lt;&lt; \"The answer: \" &lt;&lt; maxprofit &lt;&lt; endl; double result = (double)(end-start) / CLOCKS_PER_SEC; cout &lt;&lt; \"Elpased time is: \"&lt;&lt; result &lt;&lt; \" sec.\" &lt;&lt; endl; return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + 2 + 2^2 + 2^3 + … + 2^n = 2^{(n+1)} - 1 \\in \\Theta(2^n)$ $w_i$를 포함시키느냐 그렇지 않느냐의 두 가지 선택이므로 상태공간트리 내 전체 노드의 수는 최대 $2^{n+1} - 1$개가 된다. 최악의 경우 방문하는 노드의 수가 지수이지만, 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 알고리즘의 효율은 더 좋을 수 있다. Comparing the Algorithm Techniques for the 0-1 Knapsack Problem Problem Algoritm Technique Worst-Case Time Complexity Checking Nodes 0-1 Knapsack Problem Dynamic Programming $O(min(2^n, nW))$ 0-1 Knapsack Problem Backtracking(depth-first search)In backtracking algorithms the worst case gives little insight into how many checking is usually saved by backtracking. $\\Theta(2^n)$ 13 0-1 Knapsack Problem Branch-and-Bound(breadth-first search)In general, the breadth-first search strategy has no advantage over a depth-first search(backtracking). $\\Theta(2^n)$ 17 0-1 Knapsack Problem Branch-and-Bound(best-first search)The best-first search can arrive at an optimal solution faster than we would by methodically visiting the nodes in some predetermined order (such as a dfs, bfs). $\\Theta(2^n)$ 11 Using best-first search, we have checked only 11 nodes, which is 6 less than the number checked using breadth-first search and 2 less than the number checked using depth-first search. A savings of 2 is not very impressive; however, in a large state space tree, the savings can be very significant when the best-first search quickly hones in on an optimal solution. 같은 예제에서 너비우선탐색은 17개, 깊이우선탐색은 13개의 노드 수를 검사하는 반면 최고우선탐색은 총 11개의 노드를 검사한다. 2개 노드를 절약한 건 인상적이지 않지만 큰 상태공간트리에서 최고우선탐색으로 최적해를 빨리 찾는 경우 이 차이는 매우 중요하다. 일반적으로 0-1 배낭 문제에 대해 너비우선탐색(13개 노드 검사)의 효율이 깊이우선탐색(17개 노드 검사)보다 더 좋다고 단정지을 순 없다. 깊이우선탐색과 너비우선탐색 중 무엇이 더 효율적이냐에 대한 답은 문제마다 다르기 때문이다. nW 덕분에 동적계획 알고리즘으로 문제를 해결하는게 더 좋은 것처럼 보일 수 있다. 그러나 깊이우선탐색, 너비우선탐색, 최고우선탐색 알고리즘에서 최악의 경우를 따지면 실제 방문하는 노드의 수를 얼마나 절약했는지 반영이 안되므로, 알고리즘의 상대적인 효율을 이론적으로 분석하기는 어렵다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Branch and Bound","slug":"Algorithms/Branch-and-Bound","permalink":"http://melomance.github.io/categories/Algorithms/Branch-and-Bound/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분기한정법","slug":"분기한정법","permalink":"http://melomance.github.io/tags/분기한정법/"},{"name":"0-1 배낭 문제","slug":"0-1-배낭-문제","permalink":"http://melomance.github.io/tags/0-1-배낭-문제/"}]},{"title":"Branch-and-Bound with the 0-1 Knapsack problem(Breadth-First Search)(0-1 배낭 문제-너비우선탐색)","slug":"[AG][BB] 0-1 Knapsack Problem2","date":"2011-12-27T02:49:00.000Z","updated":"2019-05-12T14:01:45.361Z","comments":true,"path":"2011/12/27/[AG][BB] 0-1 Knapsack Problem2/","link":"","permalink":"http://melomance.github.io/2011/12/27/[AG][BB] 0-1 Knapsack Problem2/","excerpt":"","text":"We show how to use the branch-and-bound design strategy by applying it to the 0-1 Knapsack problem. First we discuss a simple version called breadth-first search with branch-and-bound pruning. After that, we show an improvement on the simple version called best-first search with branch-and-bound pruning. 0-1 배낭 문제에 너비우선탐색을 적용해봄으로써 분기한정기법을 어떻게 사용하는지 살펴볼 것이다. 그 후 동 문제에 최고우선탐색까지 적용할 것이다(너비우선탐색을 조금 변형하면 최고우선탐색이 되기 때문). Example Suppose that n = 4, W = 16, and we have the following: i $p_i$ $w_i$ $p_i / w_i$ 1 $40 2 $20 2 $30 5 $6 3 $50 10 $5 4 $10 5 $2 각 노드에는 3가지 값들이 들어가 있는데 제일 위부터 profit, weight, bound 값이다. 하늘색으로 칠해진 노드가 최적의 해답을 보유한 노드이다. 백트래킹에서 본 것과 비슷하지만 상태공간트리를 방문하는 순서가 너비우선탐색이다. 예를 들어 백트래킹기법에서는 노드(1, 2)가 유망하지 않음을 알았고 그 아래로 확장하지 않았다. 하지만 너비우선탐색을 통한 분기한정법에서는 노드(1,2)아래로 확장한다. The Breadth-First Search with Branch-and-Bound Pruning Algorithm for the 0-1 Knapsack ProblemAlgorithm DesignUsing breadth-first search with branch-and-bound pruning, we proceed exactly as we did using backtracking, except that we do a breadth-first search instead of a depth-first search. That is, we let weightand profit be the total weight and total profit of the items that have been included up to a node. Unlike depth-first search, there is no simple recursive algorithm for breadth-first search. However, we can implement it using a queue. The algorithm that follows does this. The algorithm is written specifically for trees because presently we are interested only in trees. We insert an item at the end of the queue with a procedure called enqueue, and we remove an item from the front with a procedure called dequeue. Notice that nodes (3, 1) and (4, 3) have bounds of 0. A branch-and-bound algorithm decides whether to expand beyond a node by checking whether its bound is better than the value of the best solution found so far. Therefore, when a node is nonpromising because its weight is not less than W, we set its bound to 0. In this way, we ensure that its bound cannot be better than the value of the best solution found so far. 0-1 배낭 문제에 분기한정 가지치기 너비우선탐색을 사용하면 깊이우선탐색 대신 너비우선탐색을 하게 된다. 너비우선탐색은 깊이우선탐색과 달리 재귀 알고리즘을 사용하지 않으며, 그 대신 큐(queue) 자료구조를 사용하여 알고리즘을 구현한다. 이런 점을 제외하면 백트래킹에서 봤던 방법과 똑같은 방법으로 진행된다. 분기한정 알고리즘은 노드의 확장 여부를 결정할 때, 자식노드로 확장했을 때의 bound 값이 현재까지 구한 가장 좋은 답보다 더 큰지 검사한다. 여기서 weight가 W를 초과하여 해당 노드가 유망하지 않게 되면 노드(3, 1), (4, 3) 처럼 bound를 0으로 설정한다. Last of all, in a simple breadth-first search with branch-and-bound pruning, the decision of whether or not to visit a node’s children is made at the time the node is visited. That is, if the branches to the children are pruned, they are pruned when the node is visited. Therefore, when we visit node (2, 3), we decide to visit its children because the value of maxprofit at that time is only 70, whereas the bound for the node is 82. Unlike a depth-first search, in a breadth-first search the value of maxprofit can change by the time we actually visit the children. In this case, maxprofit has a value of 90 by the time we visit the children of node (2, 3). We then waste our time checking these children. We avoid this in our best-first search, which is described in the next subsection. 마지막으로 분기한정 가지치기 너비우선탐색은 어떤 노드의 자식노드를 방문해야 할지는 그 노드를 방문할 때 결정한다. 깊이우선탐색과는 달리 너비우선탐색에서는 maxprofit의 값이 자식노드를 실제 방문하는 때에 변할 수 있다. To determine whether the node is promising, we initialize totweight and bound to weight and profit, respectively, and then greedily grab items, adding their weights and profits to totweight and bound, until we reach an item whose weight would bring totweight above W . We grab the fraction of that item allowed by the available weight, and add the profit of that fraction to bound. In this way, bound becomes an upper bound on the amount of profit we could obtain by expanding beyond the node. If the node is at level i, and the node at level k is the one whose weight would bring the weight above W , then $$\\begin{align}totweight &amp;= weight + \\sum_{j=i+1}^{k-1}w_j \\\\bound &amp;= \\left(profit + \\sum_{j=i+1}^{k-1}p_j\\right) + (W - totweight) \\times \\frac{w_k}{p_k}\\end{align}$$ profit: the sum of the profits of the items included up to the node. weight: the sum of the weights of those items. totweight: the sum of the weights could be obtained by expanding beyond that node (W를 초과할 수 없다.) bound: the upper bound on the profit that could be obtained by expanding beyond that node. Recall that a node is also nonpromising if $$weight &lt;= W$$ Pseudo Codevoid knapsack2(int n, const int p[], cont int w[], int W, int&amp; maxprofit)&#123; queue_of_node Q; node u, v; initialize(Q); // Initialize Q to be empty. v.level =0; v.profit = 0; v.weight = 0; // Initialize v to be the root. maxprofit = 0; enqueue(Q, v); while (!empty(Q)) &#123; dequeue(Q, v); u.level = v.level+1; // Set u to a child of v. u.profit = v.profit + p[u.level]; // Set u to the child that u.weight = v.weight + w[u.level]; // includes the next item. if ((u.weight &lt;= W) &amp;&amp; (u.profit &gt; maxprofit)) maxprofit = u.profit; if (bound(u) &gt; maxprofit) enqueue(Q, u); u.weight = v.weight; // Set u to the child that does not u.profit = v.profit; // does not include the next item. if (bound(u) &gt; maxprofit) enqueue(Q, u); &#125;&#125; Source Code// File: knapsack_bfs.hnamespace algorithms&#123; struct node &#123; int level; // the node's level in the tree int profit; int weight; &#125;; typedef struct node node; void knapsack2(int n, const int p[ ], const int w[ ], int W, int&amp; maxprofit); // Problem: Let n items be given, where each item has a weight and // a profit. The weights and profits are positive integers. Furthermore, // let a positive integer W be given. Determine a set of items with // maximum total profit, under the constraint that the sum of their // weights cannot exceed W . // Inputs: positive integers n and W , arrays of positive integers // w and p, each indexed from 1 to n, and each of which is sorted in // nonincreasing order according to the values of p[i] / w [i]. // Outputs: an integer maxprofit that is the sum of the profits in an // optimal set. float bound(node u, int n, const int p[ ], const int w[ ], int W);&#125; // File: knapsack_bfs.cpp#include &lt;cassert&gt; // Provides assert#include &lt;queue&gt; // Provides queue#include &lt;iostream&gt;#include &lt;iomanip&gt;#include \"knapsack_bfs.h\"using namespace std;namespace algorithms&#123; void knapsack2(int n, const int p[ ], const int w[ ], int W, int&amp; maxprofit) &#123; queue&lt;node&gt; Q; node u, v; int depth = 1; int prm_node_cnt = 0; // The number of promising nodes int nprm_node_cnt = 0; // The number of non-promising nodes assert(Q.empty( )); // Initialize Q to be empty. // Initialize v to be the root. v.level = 0; v.profit = 0; v.weight = 0; maxprofit = 0; Q.push(v); // enqueue(Q, v) while(!Q.empty( )) &#123; v = Q.front( ); cout &lt;&lt; \"level: \" &lt;&lt; setw(2) &lt;&lt; v.level; cout &lt;&lt; \" profit: \" &lt;&lt; setw(2) &lt;&lt; v.profit; cout &lt;&lt; \" weight: \" &lt;&lt; setw(2) &lt;&lt; v.weight &lt;&lt; endl; Q.pop( ); // dequeue(Q, v) u.level = v.level + 1; // Set u to a child of v. u.profit = v.profit + p[u.level]; // Set u to the child that u.weight = v.weight + w[u.level]; // includes the next item. if (u.weight &lt;= W &amp;&amp; u.profit &gt; maxprofit) maxprofit = u.profit; if (bound(u, n, p, w, W) &gt; maxprofit) &#123; Q.push(u); // enqueue(Q, u) ++prm_node_cnt; // Count the number of promising nodes &#125; else &#123; // Count the number of non-promising nodes ++nprm_node_cnt; &#125; u.profit = v.profit; // Set u to the child that does u.weight = v.weight; // not include the next item. if (bound(u, n, p, w, W) &gt; maxprofit) &#123; Q.push(u); // enqueue(Q, u) ++prm_node_cnt; // Count the number of promising nodes &#125; else &#123; // Count the number of non-promising nodes ++nprm_node_cnt; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"The num of promising nodes: \" &lt;&lt; prm_node_cnt+1 &lt;&lt; endl; cout &lt;&lt; \"The num of non-promising nodes: \" &lt;&lt; nprm_node_cnt &lt;&lt; endl; &#125; float bound(node u, int n, const int p[ ], const int w[ ], int W) &#123; int j, k; int totweight; float result; if (u.weight &gt;= W) return 0; else &#123; result = (float)u.profit; j = u.level + 1; totweight = u.weight; while (j &lt;= n &amp;&amp; totweight + w[j] &lt;= W) &#123; // Grab as many items as possible. totweight = totweight + w[j]; result = result + p[j]; ++j; &#125; k = j; // Use k for consistency with formula in text. if (k &lt;= n) // Grab fraction of kth item. result = result + (W - totweight) * (p[k] / w[k]); return result; &#125; &#125;&#125; // File: maxtotprofit.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include \"knapsack_bfs.h\"using namespace std;using namespace algorithms;int main( )&#123; // CONSTANT and VARIANCES const int n = 4; const int W = 16; int w[n+1] = &#123;0, 2, 5, 10, 5&#125;; // w[0] is meaningless int p[n+1] = &#123;0, 40, 30, 50, 10&#125;; // p[0] is meaningless int maxprofit = 0; clock_t start, end; start = clock( ); knapsack2(n, p, w, W, maxprofit); end = clock( ); cout &lt;&lt; \"The answer: $\" &lt;&lt; maxprofit &lt;&lt; endl; double result = (double)(end-start) / CLOCKS_PER_SEC; cout &lt;&lt; \"Elpased time is: \"&lt;&lt; result &lt;&lt; \" sec.\" &lt;&lt; endl; return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + 2 + 2^2 + 2^3 + … + 2^n = 2^{(n+1)} - 1 \\in \\Theta(2^n)$ $w_i$를 포함시키느냐 그렇지 않느냐의 두 가지 선택이므로 상태공간트리 내 전체 노드의 수는 최대 $2^{n+1} - 1$개가 된다. 최악의 경우 방문하는 노드의 수가 지수이지만, 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 알고리즘의 효율은 더 좋을 수 있다. Comparing the Algorithm Techniques for the 0-1 Knapsack Problem Problem Algoritm Technique Worst-Case Time Complexity 0-1 Knapsack Problem Dynamic Programming $O(min(2^n, nW))$ 0-1 Knapsack Problem Backtracking(depth-first search) $\\Theta(2^n)$ 0-1 Knapsack Problem Branch-and-Bound(breadth-first search) $\\Theta(2^n)$ Owing to the additional bound of nW , it may appear that the dynamic programming algorithm is superior. However, in backtracking algorithms the worst case gives little insight into how much checking is usually saved by backtracking. In general, the breadth-first search strategy has no advantage over a depth-first search(backtracking). 일반적으로 0-1 배낭 문제에 대해 너비우선탐색의 효율이 깊이우선탐색(백트래킹)보다 더 좋다고 단정지을 순 없다. 깊이우선탐색과 너비우선탐색 중 무엇이 더 효율적이냐에 대한 답은 문제마다 다르기 때문이다. nW 덕분에 동적계획 알고리즘으로 문제를 해결하는게 더 좋은 것처럼 보일 수 있다. 그러나 백트래킹, 너비우선탐색 알고리즘에서 최악의 경우를 따지면 실제 방문하는 노드의 수를 얼마나 절약했는지 반영이 안되므로, 알고리즘의 상대적인 효율을 이론적으로 분석하기는 어렵다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Branch and Bound","slug":"Algorithms/Branch-and-Bound","permalink":"http://melomance.github.io/categories/Algorithms/Branch-and-Bound/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분기한정법","slug":"분기한정법","permalink":"http://melomance.github.io/tags/분기한정법/"},{"name":"0-1 배낭 문제","slug":"0-1-배낭-문제","permalink":"http://melomance.github.io/tags/0-1-배낭-문제/"}]},{"title":"Branch and Bound(분기한정법)","slug":"[AG][BB] Branch and Bound","date":"2011-12-26T01:23:00.000Z","updated":"2018-09-09T07:45:59.790Z","comments":true,"path":"2011/12/26/[AG][BB] Branch and Bound/","link":"","permalink":"http://melomance.github.io/2011/12/26/[AG][BB] Branch and Bound/","excerpt":"","text":"The branch-and-bound design strategy is very similar to backtracking in that a state space tree is used to solve a problem. The differences are that the branch-and-bound method (1) does not limit us to any particular way of traversing the tree and (2) is used only for optimization problems. A branch-and-bound algorithm computes a number (bound) at a node to determine whether the node is promising. The number is a bound on the value of the solution that could be obtained by expanding beyond the node. If that bound is no better than the value of the best solution found so far, the node is nonpromising. Otherwise, it is promising. As is the case for backtracking algorithms, branch-and-bound algorithms are ordinarily exponential-time (or worse) in the worst case. However, they can be very efficient for many large instances. 분기한정법은 상태공간트리를 사용해서 문제를 푼다는 점에서 백트래킹 기법과 유사하다. 하지만 분기한정법은 트리 순회 방법을 제한하지 않으며 최적화 문제를 해결하는데만 사용된다. 백트래킹과 마찬가지로 분기한정법의 시간복잡도는 최악의 경우 지수시간(또는 더 나쁠 수도 있다)이지만 n이 커질수록 알고리즘의 효율은 좋아질 수 있다. Branch and Bound TechniqueThe backtracking algorithm for the 0-1 Knapsack problem is actually a branch-and-bound algorithm. In that algorithm, the promising function returns false if the value of bound is not greater than the current value of maxprofit. A backtracking algorithm, however, does not exploit the real advantage of using branch-and-bound. Besides using the bound to determine whether a node is promising, we can compare the bounds of promising nodes and visit the children of the one with the best bound. In this way we often can arrive at an optimal solution faster than we would by methodically visiting the nodes in some predetermined order (such as a depth-first search). This approach is called best-first search with branch-and-bound pruning. The implementation of the approach is a simple modification of another methodical approach called breadth-first search with branch-and-bound pruning. Therefore, even though this latter technique has no advantage over depth-first search, we will first solve the 0-1 Knapsack problem using a breadth-first search. This will enable us to more easily explain best-first search and use it to solve the 0-1 Knapsack problem. Before proceeding, we review breadth-first-search. In the case of tree, a breadth-first search consists of visiting the root first, followed by all nodes at level 1, followed by all nodes at level 2, and so on. Unlike depth-first search, there is no simple recursive algorithm for breadth-first search. However, we can implement it using a queue. 0-1 배낭 문제에 적용한 깊이우선탐색 알고리즘은 분기한정법이지만 분기한정법의 실질적인 이점을 이용하진 못한다. 노드가 유망한지를 결정하기 위해 한계값(bound)을 사용는 것 외에도, 유망한 노드들 간 한계값을 비교하여 그 중에서 가장 좋은 한계값을 가진 노드의 자식노드를 방문하면, 미리 정한 순서(깊이우선탐색)대로 방문하는 것보다 종종 더 빨리 최적해에 도달할 수 있게 된다. 앞서 깊이우선탐색으로 살펴본 0-1 배낭 문제를 너비우선탐색으로 해결해보고(깊이우선탐색에 비해 이점은 없다) 이를 수정하여 최고우선탐색까지 적용해볼 것이다. 이렇게 해야 최고우선탐색을 더 쉽게 설명할 수 있다. 아래는 너비우선탐색의 리뷰를 위한 슈도코드이다. 루트노드에서부터 시작해 레벨1의 노드들을 다 방문한 후, 레벨2의 노드들을 탐색하는 것을 알 수 있다. 후손 노드들을 먼저 방문하는 깊이우선탐색과는 그 탐색방법이 다름을 알 수 있다. Unlike depth-first search, there is no simple recursive algorithm for breadth-first search. However, we can implement it using a queue. // Pseudocode for BFS(Breadth-First Search)void breadth_first_search(tree T)&#123; queue_of_node Q; node u, v; initialize(Q); // Initialize Q to be empty v = root of T; visit v; enqueue(Q,v); while (!empty(Q)) &#123; dequeue(Q,v); for(each child u of v) &#123; visit u; enqueue(Q,u); &#125; &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Branch and Bound","slug":"Algorithms/Branch-and-Bound","permalink":"http://melomance.github.io/categories/Algorithms/Branch-and-Bound/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분기한정법","slug":"분기한정법","permalink":"http://melomance.github.io/tags/분기한정법/"}]},{"title":"Backtracking with the 0-1 Knapsack problem(Depth-First Search)(0-1 배낭 문제-깊이우선탐색)","slug":"[AG][BT] 0-1 Knapsack Problem","date":"2011-12-24T01:57:00.000Z","updated":"2019-05-12T14:22:24.568Z","comments":true,"path":"2011/12/24/[AG][BT] 0-1 Knapsack Problem/","link":"","permalink":"http://melomance.github.io/2011/12/24/[AG][BT] 0-1 Knapsack Problem/","excerpt":"","text":"Recall that in this problem we have a set of items, each of which has a weight and a profit. The weights and profits are positive integers. A thief plans to carry off stolen items in a knapsack, and the knapsack will break if the total weight of the items placed in it exceeds some positive integer W. The thief’s objective is to determine a set of items that maximizes the total profit under the constraint that the total weight cannot exceed W. We can solve this problem using a state space tree exactly like the one in the Sum-of-Subsets problem. That is, we go to the left from the root to include the first item, and we go to the right to exclude it. Similarly, we go to the left from a node at level 1 to include the second item, and we go to the right to exclude it, and so on. Each path from the root to a leaf is a candidate solution. This problem is different from the others discussed in this chapter in that it is an optimization problem. This means that we do not know if a node contains a solution until the search is over. Therefore, we back-track a little differently. If the items included up to a node have a greater total profit than the best solution so far, we change the value of the best solution so far. However, we may still find a better solution at one of the node’s descendants (by stealing more items). Therefore, for optimization problems we always visit a promising node’s children. The following is a general algorithm for backtracking in the case of optimization problems. 0-1 배낭 문제는 각각 무게와 이익(무게와 이익은 양의 정수)을 가진 아이템의 집합이 존재한다. 도둑은 훔친 물건을 배낭에 담아갈 계획이고, 배낭 안에 넣은 아이템의 총 무게가 W를 초과하면 배낭은 찢어진다. 도둑의 목표는 총 무게가 W를 초과할 수 없다는 제약하에 총 이익이 최대가 되는 아이템의 집합을 구하는 것이다. 0-1 배낭 문제도 앞서 봐왔던 문제들과 마찬가지로, 상태공간트리를 구축하여 백트래킹 기법으로 문제를 해결한다. 루트에서 왼쪽으로 가면 첫번째 아이템을 배낭에 넣는 경우이고, 오른쪽으로 가면 첫번째 아이템을 배낭에 넣지 않는 경우이다. 동일한 방법으로 두 번째 아이템을 넣으면 레벨 1의 노드에서 왼쪽으로 가고, 넣지 않으면 오른쪽으로 간다. 이런 방법으로 계속하여 상태공간트리를 구축하면, 루트 노드에서부터 잎 노드까지의 모든 경로는 해답 후보가 된다. 이 문제는 최적화 문제(optimization problem)라는 점에서 앞서 다룬 다른 문제들과 다르다. 최선이라고 여겼던 노드를 선택했다고 해서 실제로 그 마디로부터 최적의 해가 항상 나온다는 보장은 없다. 즉, 검색이 완전히 끝나기 전에는 해답을 알 수가 없으므로 검색하는 과정 동안 항상 그 때까지 찾은 최적의 해를 기억해 두어야 한다. Example Suppose that n = 4, W = 16, and we have the following: i $p_i$ $w_i$ $p_i / w_i$ 1 $40 2 $20 2 $30 5 $6 3 $50 10 $5 4 $10 5 $2 상태공간트리에서 X표시는 유망하지 않은(nonpromising) 노드를 뜻하며 이런 노드들은 탐색하지 않는다. 각 노드에는 3가지 값들이 들어가 있는데 제일 위부터 profit, weight, bound 값이다. bound가 98인 경우는 40 + 50 + (16 - 12) $\\times$ 10/5로 구해진다. 이해를 돕기 위해 하나의 예를 들자면, (3, 4)의 경우 현재까지 구한 최고 profit은 (3, 3)에서 구한 90이다. 그런데 (3, 4)를 방문함으로써 얻을 수 있는 bound값은 50이기 때문에, 90 &gt; 50 이므로 (bound값이 maxprofit보다 작다) 그 노드를 방문하지 않는다. 즉, (3, 4)는 유망하지 않으므로 가지치기 당한다. The Backtracking Algorithm for the 0-1 Knapsack ProblemAlgorithm DesignWe first order the items in nonincreasing order according to the values of $p_i / w_i$, where $w_i$ and $p_i$ are the weight and profit, respectively, of the ith item. Next we greedily grab items, adding their profits to bound and their weights to totweight, until we get to an item that if grabbed would bring totweight above W. We grab the fraction of that item allowed by the remaining weight, and we add the value of that fraction to bound. Suppose the node is at level i, and the node at level k is the one that would bring the sum of the weights above W. Then $$\\begin{align}totweight &amp;= weight + \\sum_{j=i+1}^{k-1}w_j \\\\bound &amp;= \\left(profit + \\sum_{j=i+1}^{k-1}p_j\\right) + (W - totweight) \\times \\frac{w_k}{p_k}\\end{align}$$ profit: the sum of the profits of the items included up to the node. weight: the sum of the weights of those items. totweight: the sum of the weights could be obtained by expanding beyond that node (W를 초과할 수 없다.) bound: the upper bound on the profit that could be obtained by expanding beyond that node. 노드가 레벨 i에 있다고 하고, 레벨 k에 있는 노드에서 총 무게가 W를 넘었을때의 계산방법이다. 식이 복잡해보이지만 전혀 그렇지 않다. 인덱스가 k일때는 W를 초과하므로 k-1까지의 합을 구 한 것이고 총 무게에서 k-1번까지의 더한 무게를 뺀 후 남은 무게만큼 이익을 쪼개서 채워넣은 것이다. If maxprofit is the value of the profit in the best solution found so far, then a node at level i is nonpromising if$$bound &lt;= maxprofit$$ maxprofit은 현재까지 찾은 최고이익 값이다. 만약 노드를 확장했을 때의 bound 값이 maxprofit 보다 작거나 같다면, 즉 상기 부등식이 성립하면 레벨 i에 위치한 노드들은 유망하지 않다. 알고리즘의 단계를 구체적으로 세분화하면 다음과 같다. Step 1 bound와 totweight를 profit과 weight 값으로 초기화한다.Step 2 다음으로 탐욕적인 방법으로 아이템을 취한다.Step 3 이 과정을 totweight이 W를 초과하게 되는 아이템을 잡을 때까지 반복한다.Step 4 남은 무게만큼 마지막 아이템의 일부분을 취한다. 다음은 전체적인 알고리즘의 흐름이다. 먼저 깊이우선탐색으로 각 노드를 방문하고 아래에 명시된 단계들을 수행한다. Step 1 해당 노드의 profit과 weight를 계산한다.Step 2 해당 노드의 bound를 계산한다.Step 3 weight &lt; W 이고, bound &gt; maxprofit이면, 검색을 계속한다. 그렇지 않다면 백트래킹한다. Pseudo Codevoid knapsack(index i, int profit, int weight)&#123; if (weight &lt;= W &amp;&amp; profit &gt; maxprofit) &#123; // best so far maxprofit = profit; numset = i; bestset = include; &#125; if (promising(i)) &#123; include[i+1] = \"YES\"; // Include w[i+1] knapsack(i+1, profit+p[i+1], weight+w[i+1]); include[i+1] = \"NO\"; // Not include w[i+1] knapsack(i+1, profit, weight); &#125;&#125;bool promising(index i)&#123; index j, k; int totweight; float bound; if (weight &gt;= W) return false; else &#123; j = i + 1; bound = profit; totweight = weight; while ((j &lt;= n) &amp;&amp; (totweight + w[j] &lt;= W)) &#123; // Grab as many items as possible. totweight = totweight + w[j]; bound = bound + p[j]; j++ &#125; k = j; if (k &lt;= n) &#123; // Grab fraction of kth item. bound = bound + (W–totweight)*p[k]/w[k]; &#125; return bound &gt; maxprofit; &#125;&#125; Source Code// File: knapsack_dfs.hnamespace algorithms&#123; void knapsack(int i, int profit, int weight); // Problem: Let n items be given, where each item has a weight and // a profit. The weights and profits are positive integers. Furthermore, // let a positive integer W be given. Determine a set of items with // maximum total profit, under the constraint that the sum of their // weights cannot exceed W. // Inputs: Positive integers n and W; arrays w and p, each indexed from // 1 to n, and each containing positive integers sorted in nonincreasing // order according to the values of p[i]/w[i]. // Outputs: an array bestset indexed from 1 to n, where the values of // bestset[i] is \"yes\" if the ith item is included in the optimal set // and is \"no\" otherwise; an integer maxprofit that is the maximum // profit. bool promising(int i, int profit, int weight);&#125; // File: knapsack_dfs.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include \"knapsack_dfs.h\"using namespace std;// GLOBAL VARIANCES and CONSTANTconst int n = 4;const int W = 16;int w[n+1] = &#123;0, 2, 5, 10, 5&#125;; // w[0] is meaninglessint p[n+1] = &#123;0, 40, 30, 50, 10&#125;; // p[0] is meaninglessstring* include = new string[n+1];string* bestset = new string[n+1];int prm_node_cnt = 0;int nprm_node_cnt = 0;int numbest = 0;int maxprofit = 0;namespace algorithms&#123; void knapsack(int i, int profit, int weight) &#123; // This set is best so far. Set numbest to number of items considered. // Set bestset to this solution. if (weight &lt;= W &amp;&amp; profit &gt; maxprofit) &#123; maxprofit = profit; numbest = i; copy(include, include + n+1, bestset); &#125; if (promising(i, profit, weight)) &#123; ++prm_node_cnt; // Count the number of promising node include[i+1] = \"YES\"; // Inlcude w[i+1] knapsack(i + 1, profit + p[i+1], weight + w[i+1]); include[i+1] = \"NO\"; // Do not include w[i+1] knapsack(i + 1, profit, weight); &#125; else &#123; ++nprm_node_cnt; // Count the number of non-promising node &#125; &#125; bool promising(int i, int profit, int weight) &#123; int j, k; int totweight; float bound; // Node is promising only if we should expand to its children. // There must be some capacity left for the children. if (weight &gt;= W) &#123; return false; &#125; else &#123; j = i + 1; bound = (float)profit; totweight = weight; while (j &lt;= n &amp;&amp; totweight + w[j] &lt;= W) &#123; // Grab as many items as possible. totweight = totweight + w[j]; bound = bound + p[j]; ++j; &#125; k = j; // Use k for consistency with formula in text. if (k &lt;= n) // Grab fraction of kth item. bound = bound + (W - totweight) * (p[k] / w[k]); return (bound &gt; maxprofit); &#125; &#125;&#125;int main( )&#123; clock_t start, end; start = clock( ); algorithms::knapsack(0, 0, 0); end = clock( ); for (int j = 1; j &lt;= numbest; ++j) cout &lt;&lt; \"w\"&lt;&lt; j &lt;&lt; \": \" &lt;&lt; bestset[j] &lt;&lt; setw(3); cout &lt;&lt; endl &lt;&lt; \"The answer: $\" &lt;&lt; maxprofit &lt;&lt; endl; cout &lt;&lt; \"The num of promising node: \" &lt;&lt; prm_node_cnt &lt;&lt; endl; cout &lt;&lt; \"The num of nonpromising node: \" &lt;&lt; nprm_node_cnt &lt;&lt; endl; double result = (double)(end-start) / CLOCKS_PER_SEC; cout &lt;&lt; \"Elpased time is: \"&lt;&lt; result &lt;&lt; \" sec.\" &lt;&lt; endl; delete [ ] include; delete [ ] bestset; return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + 2 + 2^2 + 2^3 + … + 2^n = 2^{(n+1)} - 1 \\in \\Theta(2^n)$ $w_i$를 포함시키느냐 그렇지 않느냐의 두 가지 선택이므로 상태공간트리 내 전체 노드의 수는 최대 $2^{n+1} - 1$개가 된다. 최악의 경우 방문하는 노드의 수가 지수이지만, 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 백트래킹 알고리즘의 효율은 더 좋을 수 있다. Comparing the Algorithm Techniques for the 0-1 Knapsack Problem Problem Algoritm Technique Worst-Case Time Complexity 0-1 Knapsack Problem Dynamic Programming $O(min(2^n, nW))$ 0-1 Knapsack Problem Backtracking(depth-first search) $\\Theta(2^n)$ Owing to the additional bound of nW , it may appear that the dynamic programming algorithm is superior. However, in backtracking algorithms the worst case gives little insight into how much checking is usually saved by backtracking. With so many considerations, it is difficult to analyze theoretically the relative efficiencies of the two algorithms. nW 덕분에 동적계획 알고리즘으로 문제를 해결하는게 더 좋은 것처럼 보일 수 있다. 그러나 백트래킹 알고리즘에서 최악의 경우를 따지면 실제 백트래킹으로 방문하는 노드의 수를 얼마나 절약했는지 반영이 안되므로, 두 알고리즘의 상대적인 효율을 이론적으로 분석하기는 어렵다. Backtracking ExercisesUse the Backtracking algorithm for the 0-1 Knapsack problem to maximize the profit for the following problem instance. Suppose that n = 5, W = 9, and we have the following: i $p_i$ $w_i$ $p_i / w_i$ 1 $20 2 $10 2 $30 5 $6 3 $35 7 $5 4 $12 3 $4 5 $3 1 $3 w1: YES w2: NO w3: YESThe answer: $55The num of promising nodes: 6The num of nonpromising nodes: 7Elpased time is: 0 sec.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Backtracking","slug":"Algorithms/Backtracking","permalink":"http://melomance.github.io/categories/Algorithms/Backtracking/"}],"tags":[{"name":"백트래킹","slug":"백트래킹","permalink":"http://melomance.github.io/tags/백트래킹/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"0-1 배낭 문제","slug":"0-1-배낭-문제","permalink":"http://melomance.github.io/tags/0-1-배낭-문제/"}]},{"title":"Graph Coloring(그래프 채색)","slug":"[AG][BT] Graph Coloring Problem","date":"2011-12-23T06:47:00.000Z","updated":"2019-05-19T01:10:19.246Z","comments":true,"path":"2011/12/23/[AG][BT] Graph Coloring Problem/","link":"","permalink":"http://melomance.github.io/2011/12/23/[AG][BT] Graph Coloring Problem/","excerpt":"","text":"The m-Coloring problem concerns finding all ways to color an undirected graph using at most m different colors, so that no two adjacent vertices are the same color. We usually call the m-Coloring problem a unique problem for each value of m. An important application of graph coloring is the coloring of maps. m-그래프 채색 문제는 비방향그래프에서 서로 인접한 정점이 같은 색을 갖지 않도록 최대 m개의 다른 색으로 칠하는 방법을 모두 찾는 것이다. m값에 대해서는 각기 다른 문제로 취급한다. A graph is called planar if it can be drawn in a plane in such a way that no two edges cross each other. The graph at the below is planar. However, if we were to add the edges ($v_1$, $v_5$) and ($v_2$, $v_4$) it would no longer be planar. To every map there corresponds a planar graph. Each region in the map is represented by a vertex. If one region is adjacent to another region, we join their corresponding vertices by an edge. The below figure shows a map at the left and its planar graph representation at the right. 2개의 이음선이 서로 교차하지 않도록 그린 그래프를 평면그래프라고 한다. 모든 지도는 그에 상응하는 평면그래프로 바꿔 그릴 수 있다. 지도에서 각 지역은 정점에 해당한다. 만일 한 지역이 다른 지역과 인접해 있으면, 그 정점들을 이음선으로 연결한다. Example There is no solution to the 2-Coloring problem for this graph because, if we can use at most two different colors, there is no way to color the vertices so that no adjacent vertices are the same color. One solution to the 3-Coloring problem for this graph is as follows: $$\\begin{align}Ve&amp;rtex &amp;Color \\\\&amp;v_1 &amp;color1 \\\\&amp;v_2 &amp;color2 \\\\&amp;v_3 &amp;color3 \\\\&amp;v_4 &amp;color4\\end{align}$$ There are a total of six solutions to the 3-Coloring problem for this graph. However, the six solutions are only different in the way the colors are permuted. 위의 그래프에서 최대 2개의 색만 사용할 수 있다면 인접한 정점이 같은 색을 갖지 않도록 칠하는 것은 불가능하다. 즉, 2-Coloring 문제에 대한 해답은 없다. 3개의 다른 색으로 그래프를 채색하는 경우 총 6가지 해답이 존재한다. 그러나 6가지 해답은 색이 조합된 방법만 다를 뿐이다. The Backtracking Algorithm for the m-Coloring ProblemAlgorithm DesignA straightforward state space tree for the m-Coloring problem is one in which each possible color is tried for vertex $v_1$ at level 1, each possible color is tried for vertex $v_2$ at level 2, and so on until each possible color has been tried for vertex $v_n$ at level n. Each path from the root to a leaf is a candidate solution. We check whether a candidate solution is a solution by determining whether any two adjacent vertices are the same color. m-Coloring 문제에 대한 상태공간트리는 다음과 같다. 레벨 1에서 정점 $v_1$에 가능한 모든 색을 각각 시도하고, 레벨 2에서는 정점 $v_2$에 가능한 모든 색을 각각 시도해 본다. 이런식으로 레벨 n에서는 정점 $v_n$에 가능한 모든 색을 각각 시도해 본다. 상태공간트리의 루트노드에서 잎노드까지의 경로가 해답후보가 되며, 인접한 정점이 같은 색인지를 결정함으로써 해답여부를 판단한다. We can backtrack in this problem because a node is nonpromising if a vertex that is adjacent to the vertex being colored at the node has already been colored the color that is being used at the node. After $v_1$ is colored color 1, choosing color 1 for $v_2$ is nonpromising because $v_1$ is adjacent to $v_2$. Similarly, after $v_1$, $v_2$, and $v_3$ have been colored colors 1, 2, and 3, respectively, choosing color 1 for $v_4$ is nonpromising because $v_1$ is adjacent to $v_4$. 한 정점에서 사용된 색이 인접한 정점을 칠하기 위해 사용됐다면 그 마디는 유망하지 않다. 이 점을 이용하면 이번 문제에서도 백트래킹을 적용할 수 있다. 예를 들어, $v_1$을 색1로 칠한 후 $v_2$에서 색1을 선택하는 것은 유망하지 않다. $v_1$과 $v_2$는 서로 인접해있기 때문이다. 마찬가지로 $v_1$, $v_2$, $v_3$를 색1, 색2, 색3으로 칠한 경우 $v_4$에서 색1을 선택하는 것은 유망하지 않다. Pseudo Codevoid m_coloring(index i)&#123; int color; if (promising(i)) if (i == n) cout &lt;&lt; vcolor[1] through vcolor[n]; else for (color = 1; color &lt;= m; color++) &#123; vcolor[i+1] = color; m_coloring(i+1); &#125;&#125;bool promising(index i)&#123; index j; bool switch; switch = true; j = 1; while (j &lt; i &amp;&amp; switch) &#123; if (W[i][j] &amp;&amp; vcolor[i] == vcolor[j]) switch = false; j++; &#125; return switch;&#125; Source Code// File: mcoloring.h#ifndef GRAPH_COLOR_H#define GRAPH_COLOR_H#include \"graph.h\"using namespace data_structures; // for graphnamespace algorithms&#123; void m_coloring(graph g, int i, int* vcolor); // Problem: Determine all ways in which the vertices in an undirected graph can // be colored, using only m colors, so that adjacent vertices are not the same // color. // Inputs: positive integers n and m, and an undirected graph containing // n vertices. The graph is represented by a two-dimensional array W, which // has both its rows and columns indexed from 1 to n, where W [i][j] is true if // there is an edge between ith vertex and the jth vertex and false otherwise. // Outputs: all possible colorings of the graph, using at most m colors, so that // no two adjacent vertices are the same color. The output for each coloring is // an array vcolor indexed from 1 to n, where vcolor[i] is the color // (an integer between 1 and m) assigned to the ith vertex. bool promising(graph g, int i, int* vcolor); template &lt;typename Item&gt; Item* get_vector_space(const int n) // Prostcondition: Return the array containing n spaces &#123; Item* v = new Item[n]; return (v-1); // offset the pointer &#125;&#125;#endif // File: mcoloring.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt; // Provides setw#include \"mcoloring.h\"namespace algorithms&#123; void m_coloring(graph g, int i, int *vcolor) &#123; const int m = 3; // m is the number of colors. if (promising(g, i, vcolor)) &#123; if (i == (g.get_size())) &#123; // Print vcolor[1] through vcolor[n]; for (int i = 1; i &lt;= g.get_size(); ++i) std::cout &lt;&lt; std::setw(4) &lt;&lt; g[i] &lt;&lt; \"'s color: \" &lt;&lt; vcolor[i]; std::cout &lt;&lt; std::endl; &#125; else &#123; for (int color = 1; color &lt;= m; ++color) &#123; vcolor[i + 1] = color; m_coloring(g, i + 1, vcolor); &#125; &#125; &#125; &#125; bool promising(graph g, int i, int *vcolor) &#123; int j; bool is_switch; const int EDGES_CONN = 1; j = 1; is_switch = true; while (j &lt; i &amp;&amp; is_switch) &#123; if (g.get_edge(i, j) == EDGES_CONN &amp;&amp; vcolor[i] == vcolor[j]) is_switch = false; ++j; &#125; return is_switch; &#125;&#125; // namespace algorithms // File: mcoloringtest.cpp#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include \"mcoloring.h\"#include \"graph.h\"using namespace algorithms;int main( )&#123; const int GRAPH_SIZE = 4; const int EDGES_CONN = 1; graph W(GRAPH_SIZE); int* vcolor = get_vector_space&lt;int&gt;(GRAPH_SIZE); W.set_vertex(\"v1\"); W.set_vertex(\"v2\"); W.set_vertex(\"v3\"); W.set_vertex(\"v4\"); W.set_edge(1, 2, EDGES_CONN); W.set_edge(1, 3, EDGES_CONN); W.set_edge(1, 4, EDGES_CONN); W.set_edge(2, 1, EDGES_CONN); W.set_edge(2, 3, EDGES_CONN); W.set_edge(3, 1, EDGES_CONN); W.set_edge(3, 2, EDGES_CONN); W.set_edge(3, 4, EDGES_CONN); W.set_edge(4, 1, EDGES_CONN); W.set_edge(4, 3, EDGES_CONN); m_coloring(W, 0, vcolor); delete [ ](vcolor + 1); return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + m + m^2 + m^3 + … + m^n = \\frac{m^{n+1} - 1}{m-1} \\in \\Theta(m^n)$ For a given m and n, it is possible to create an instance that checks at least an exponentially large number of nodes (in terms of n). As with any backtracking algorithm, even though the worst case is exponential, the algorithm can be efficient for many large instances. 한 정점에서 가능한 모든 색(m개)을 시도해 봐야하므로 주어진 m, n에 대해 최소한 지수만큼 많은 노드의 수를 점검하는 상태공간트리를 만들 수 있다. 하지만 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 알고리즘의 효율은 더 좋을 수 있다. n-퀸, 부분집합의 합구하기 문제와 마찬가지로 유망한 노드의 수를 정확히 구하기 위한 방법은 실제 알고리즘을 수행 후 구축된 상태공간트리의 노드 갯수를 세어 보는 수 밖에 없다. 또한 몬테 카를로 알고리즘을 이용해 시간복잡도를 추정할 수 있다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Backtracking","slug":"Algorithms/Backtracking","permalink":"http://melomance.github.io/categories/Algorithms/Backtracking/"}],"tags":[{"name":"백트래킹","slug":"백트래킹","permalink":"http://melomance.github.io/tags/백트래킹/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"The Sum-of-Subsets Problem(부분집합의 합 구하기)","slug":"[AG][BT] Sum-of-Subsets Problem","date":"2011-12-23T04:09:00.000Z","updated":"2019-05-19T01:11:31.068Z","comments":true,"path":"2011/12/23/[AG][BT] Sum-of-Subsets Problem/","link":"","permalink":"http://melomance.github.io/2011/12/23/[AG][BT] Sum-of-Subsets Problem/","excerpt":"","text":"In the Sum-of-Subsets problem, there are n positive integers (weights) $w_i$ and a positive integer W. The goal is to find all subsets of the integers that sum to W. As mentioned earlier, we usually state our problems so as to find all solutions. 부분집합의 합을 구하는 문제는 n개의 양의 정수(무게) $w_i$와 양의 정수 W가 주어졌을 때, 합이 W가 되는 정수의 부분집합을 모두 찾는 것이다. n-퀸 문제처럼 모든 해답을 찾도록 알고리즘을 구현할 것이다. Example Suppose that n = 5, W = 21, and$$w_1=5 \\quad w_2=6 \\quad w_3=10 \\quad w_4=11 \\quad w_5 = 16.$$ because$$\\begin{align}w_1 + w_2 + w_3 &amp;= 5 + 6 + 10 = 21, \\\\w_1 + w_5 &amp;= 5 + 16 = 21, \\\\w_3 + w_4 &amp;= 10 + 11 = 21,\\end{align}$$ Example Suppose that n = 4, W = 13, and$$w_1=3 \\quad w_2=4 \\quad w_3=5 \\quad w_4=6.$$ becasue$$\\begin{align}w_1 + w_2 + w_4 = 3 + 4 + 6 = 13\\end{align}$$the solutions are {$w_1$, $w_2$, $w_4$} 각 노드에는 그 노드까지의 총 합이 적혀 있다. 가장 왼쪽 잎노드인 12는 3 + 4 + 5의 결과이다. 부모노드를 기준으로 왼쪽자식노드는 $w_i$를 포함시킨다는 뜻이며 오른쪽 노드는 $w_i$를 배제한다는 의미이다. 위의 상태공간트리에서 유망하지 않은 자식노드들은 X로 표시된다. 12, 8, 9를 포함하는 노드들은 다음 무게인 6을 추가하면 weight의 값이 W를 초과하기 때문에 유망하지 않다. 7, 3, 4, 0을 포함하는 노드들은 남은 무게를 더했을때의 총합이 W까지 가기에는 충분하지 않으므로 유망하지 않다. The Backtracking Algorithm for the Sum-of-Subsets ProblemAlgorithm DesignIf we sort the weights in nondecreasing order, there are obvious signs that a node is nonpromising. 부분합 문제의 상태공간트리 전체를 깊이우선탐색하는 것은 비효율적이다. $w_1$ ~ $w_n$을 오름차순으로 정렬하면 가지치기를 판단할 수 있는 분명한 증거들이 있다. weight: the sum of the weights that have been included up to a node at level $i$$$weight + w_{i+1} &gt; W \\text{: a node is nonpromising.}$$ total: the total weight of the remaining weights$$weight + total &lt; W \\text{: a node is nonpromising.}$$ weight는 i레벨에 있는 노드까지 포함된 무게의 합이다. weight에 $w_{i+1}$을 더한 결과가 W를 초과한다면 그 이후에 어떤 다른 무게도 W를 넘길 것이다. 즉, $w_{i+1}$부터는 유망하지 않으므로 그 자식 노드들은 탐색대상에서 제외한다. total은 남아있는 아이템의 총 무게이다. total에 weight를 더해서 W보다 작다면, 그 노드 아래로 확장을 해도 W와 같아질 수 없다. 따라서 이 경우도 유망하지 않으므로 가지치기를 통해 탐색대상에서 제외한다. The algorithm uses an array include. It sets include[i] to “YES” if w[i] is to be included and to “NO” if it is not. $w_i$의 포함여부는 include[i] 배열을 통해 관리한다. include[i]는 $w_i$를 포함하면 “YES”, 그렇지 않으면 “NO” 값을 가진다. When the sum of the weights included up to a node equals W , there is a solution at that node. Therefore, we cannot get another solution by including more items. This means that if $$W = weight$$ we should print the solution and backtrack. W = weight 등식이 성립하면 해답을 출력하고 백트래킹한다. Pseudo Codevoid sum_of_subsets(index i, int weight, int total)&#123; if (promising(i)) if (weight == W) cout &lt;&lt; include[1] through include[i]; else &#123; include[i+1] = \"yes\"; // Include w[i+1] sum_of_subsets(i+1, weight + w[i+1], total - w[i+1]); include[i+1] = \"no\"; // Do not include w[i+1] sum_of_subsets(i+1, weight, total - w[i+1]); &#125;&#125;bool promising(index i)&#123; return (weight + total &gt;= W) &amp;&amp; (weight == W || weight + w[i+1] &lt;= W);&#125; Source Code// File: sumofsubs.h#include &lt;cstring&gt;using namespace std; // for stringnamespace algorithms&#123; void sum_of_subsets(int i, int weight, int total, int W, int* w, string* include); // Problem: Given n positive integers (weights) and a positive integer W, // determine all combinations of the integers that sum to W. // Inputs: positive integer n, sorted (nondecreasing order) array of positive // integers w indexed from 1 to n, and a positive integer W. // Outputs: all combinations of the integers that sum to W. bool promising(int i, int weight, int total, int W, int* w); template &lt;typename Item&gt; Item* get_vector_space(const int n) // Prostcondition: Return the array containing n spaces &#123; Item* v = new Item[n]; return (v-1); // offset the pointer &#125;&#125; // File: sumofsubs.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt; // Provides setw#include \"sumofsubs.h\"namespace algorithms&#123; void sum_of_subsets(int i, int weight, int total, int W, int* w, string* include) &#123; if (promising(i, weight, total, W, w)) &#123; if (weight == W) &#123; for (int j = 1; j &lt;= i; ++j) cout &lt;&lt; setw(3) &lt;&lt; \"w\" &lt;&lt; j &lt;&lt; \": \" &lt;&lt; include[j] &lt;&lt; setw(3); cout &lt;&lt; endl; &#125; else &#123; include[i + 1] = \"YES\"; // Include w[i+1] sum_of_subsets(i + 1, weight + w[i + 1], total - w[i + 1], W, w, include); include[i + 1] = \"NO \"; // Do not include w[i+1] sum_of_subsets(i + 1, weight, total - w[i + 1], W, w, include); &#125; &#125; &#125; bool promising(int i, int weight, int total, int W, int *w) &#123; return (weight + total &gt;= W) &amp;&amp; (weight == W || weight + w[i + 1] &lt;= W); &#125;&#125; // File: sumofsubstest.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include \"sumofsubs.h\"using namespace algorithms;int main( )&#123; const int N = 5; const int W = 21; int* w = get_vector_space&lt;int&gt;(N); int total = 0; string* include = get_vector_space&lt;string&gt;(N); w[1] = 5; w[2] = 6; w[3] = 10; w[4] = 11; w[5] = 16; // total 초기값 계산 for (int i = 1; i &lt;= 5; ++i) total += w[i]; sum_of_subsets(0, 0, total, W, w, include); delete [ ] (w + 1); delete [ ] (include + 1); return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + 2 + 2^2 + 2^3 + … + 2^n = 2^{n+1} - 1 \\in \\Theta(2^n)$ As stressed before, even though the worst case is exponential, the algorithm can be efficient for many large instances. $w_i$를 포함시키느냐 그렇지 않느냐의 두 가지 선택이므로 상태공간트리 내 전체 노드의 수는 최대 $2^{n+1} - 1$개가 된다. 최악의 경우가 지수이지만, 가지치기를 통해 상태노드의 수를 줄일 수 있기 때문에 알고리즘의 효율은 더 좋을 수 있다. n-퀸 문제와 마찬가지로 유망한 노드의 수를 정확히 구하기 위한 방법은 실제 알고리즘을 수행 후 구축된 상태공간트리의 노드 갯수를 세어 보는 수 밖에 없다. 또한 몬테 카를로 알고리즘을 이용해 시간복잡도를 추정할 수 있다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Backtracking","slug":"Algorithms/Backtracking","permalink":"http://melomance.github.io/categories/Algorithms/Backtracking/"}],"tags":[{"name":"백트래킹","slug":"백트래킹","permalink":"http://melomance.github.io/tags/백트래킹/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"n-Queens Problem(n-퀸 문제)","slug":"[AG][BT] n-Queens Problem","date":"2011-10-03T04:34:00.000Z","updated":"2019-05-19T01:21:48.787Z","comments":true,"path":"2011/10/03/[AG][BT] n-Queens Problem/","link":"","permalink":"http://melomance.github.io/2011/10/03/[AG][BT] n-Queens Problem/","excerpt":"","text":"The classic example of the use of backtracking is in the n-Queens problem. The goal in this problem is to position n queens on an n×n chessboard so that no two queens threaten each other; that is, no two queens may be in the same row, column, or diagonal. The n-Queens problem is a generalization of its instance when n = 8, which is the instance using a standard chessboard. For the sake of brevity, we will illustrate backtracking using the instance when n = 4. The backtracking technique with the instance of the n-Queens problem when n = 4. Our task is to position four queens on a 4 x 4 chessboard so that no two queens threaten each other. In other words, No two queens can be in the same row. The instance can then be solved by assigning each queen a different row and checking which column combinations yield solutions. Because each queen can be placed in one of four columns, there are 4 x 4 x 4 x 4 = 256 candidate solutions. The sequence in this problem is the n positions in which the queens are placed, the set for each choice is the $n^2$ possible positions on the chessboard, and the criterion is that no two queens can threaten each other. n-퀸 문제는 n개의 퀸을 서로 상대방을 잡아먹지 않도록 체스판에 배치하는 것이다. 즉, 두 개의 퀸이 같은 행, 열, 또는 대각선상에 위치할 수 없다. 원래의 문제는 8개의 퀸을 표준 체스판(8 x 8)에 배치하는 거지만,설명의 간결함을 위해 n=4인 인스턴스에 대해 백트래킹을 설명할 것이다. n=4일 때 각 퀸은 4개의 열 중 하나에 배치될 수 있기 때문에 4 x ​​4 x 4 x 4 = 256 개의 해답후보가 존재한다. n-퀸 문제에서 순서(sequence)는 퀸을 두는 n개의 위치가 되고, 각 선택의 집합(set for each choice)은 체스판에 말을 둘 수 있는 $n^2$개의 위치들이며, 기준(criterion)은 두 퀸이 서로 잡아먹히지 말아야 한다는 것이다. Backtracking is the procedure whereby, after determining that a node can lead to nothing but dead ends, we go back (“backtrack”) to the node’s parent and proceed with the search on the next child. We call a node nonpromising if when visiting the node we determine that it cannot possibly lead to a solution. Otherwise, we call it promising. To summarize, backtracking consists of doing a depth-first search of a state space tree, checking whether each node is promising, and, if it is nonpromising, backtracking to the node’s parent. This is called pruning the state space tree, and the subtree consisting of the visited nodes is called the pruned state space tree. n-퀸 문제의 백트래킹 기법은 상태공간트리를 깊이우선탐색하여 각 노드가 유망한지를 검사하고, 만약 유망하지 않으면 탐색을 중단하고 그 노드의 부모노드로 돌아가 다음 자식노드의 검색을 계속하는 절차이다. 상태공간트리(state space tree)의 루트노드에서 잎노드까지의 경로가 해답후보이다. 만약 해당 노드의 자식 노드에서 답이 나올 가능성이 있으면 유망하다(promising)라고 한다. 반대로 노드를 방문할 때 해답이 될 가능성이 없다고 결정되면 그 노드를 유명하지 않다(nonpromising)라고 한다. 유망하지 않은 노드를 방문한 경우 부모노드로 백트래킹 한다. 이 절차를 상태공간트리의 가지치기(pruning)라고 한다. Example we use backtracking to solve the instance of the n-Queens problem when n = 4. Step (a) &lt;1,1&gt; is promising. $\\qquad$ $\\qquad$ { because queen 1 is the first queen positioned } Step (b) &lt;2,1&gt; is nonpromising. { because queen 1 is in column 1 } &lt;2,2&gt; is nonpromising. { because queen 1 is on left diagonal } &lt;2,3&gt; is promising. - Step (c) &lt;3,1&gt; is nonpromising. { because queen 1 is in column 1 } &lt;3,2&gt; is nonpromising. { because queen 2 is on right diagonal } &lt;3,3&gt; is nonpromising. { because queen 2 is in column 3 } &lt;3,4&gt; is nonpromising. { because queen 2 is on left diagonal } Step (d) Backtrack to &lt;1,1&gt;. &lt;2,4&gt; is promising. Step (e) &lt;3,1&gt; is nonpromising. { because queen 1 is in column 1 } &lt;3,2&gt; is promising. { This is the second time we’ve tried &lt;3,2&gt;. } Step (f) &lt;4,1&gt; is nonpromising. { because queen 1 is in column 1 } &lt;4,2&gt; is nonpromising. { because queen 3 is in column 2 } &lt;4,3&gt; is nonpromising. { because queen 3 is on left diagonal } &lt;4,4&gt; is nonpromising. { because queen 2 is in column 4 } Step (g) Backtrack to &lt;2,4&gt;. - &lt;3,3&gt; is nonpromising. { because queen 2 is in on right diagonal } &lt;3,4&gt; is nonpromising. { because queen 2 is in column 4 } (Step h) Backtrack to root. &lt;1,2&gt; is promising. (Step i) &lt;2,1&gt; is nonpromising. { because queen 1 is on right diagonal } &lt;2,2&gt; is nonpromising. { because queen 1 is in column 2 } &lt;2,3&gt; is nonpromising. { because queen 1 is on left diagonal } &lt;2,4&gt; is promising. - (Step j) &lt;3,1&gt; is promising. $\\qquad$ $\\quad$ { This is the third time we’ve tried &lt;3,1&gt;. } (Step k) &lt;4,1&gt; is nonpromising. { because queen 3 is in column 1 } &lt;4,2&gt; is nonpromising. { because queen 1 is in column 2 } &lt;4,3&gt; is promising. - The Backtracking Algorithm for the n-Queens ProblemAlgorithm DesignIf we let $col(i)$ be the column where the queen in the ith row is located, then to check whether the queen in the kth row is in the same column, we need to check whether$$ col(i) = col(k) $$ col(i)는 n X n 체스판의 i행에서 퀸이 놓여있는 열의 인덱스이다. col(i) = col(k)이므로 i행과 k행에 있는 두 퀸이 같은 열에 있는지 검사하는 등식이다. Next let’s see how to check the diagonals. The queen in row 6 is being threatened in its left diagonal by the queen in row 3, and in its right diagonal by the queen in row 2. For the queen threatening from the left, the difference in the columns is the same as the difference in the rows. For the queen threatening from the right, the difference in the columns is the negative of the difference in the rows. $$\\begin{align}&amp;col(6) - col(3) = 4 - 1 = 3 = 6 - 3 \\\\&amp;col(6) - col(2) = 4 - 8 = -4 = 2 - 6\\end{align}$$ 6행의 퀸은 3행의 퀸에 의해 왼쪽 대각선으로 위협받고 있으며, 2행에 놓인 퀸에 의해 오른쪽 대각선으로도 위협받고 있다. 왼쪽 대각선에서 위협하는 퀸에 대해서는 열에서의 차이(4-1=3)가 행에서의 차이(6-3=3)와 같다. 오른쪽 대각선에서 위협하는 퀸에 대해서는 열에서의 차이(4-8=-4)가 행에서의 차이(2-6=-4)의 음과 같다. These are examples of the general result that if the queen in the kth row threatens the queen in the ith row along one of its diagonals, then $$ col(i) - col(k) = i -k \\quad \\text{or} \\quad col(i) - col(k) = k - i$$ 일반화하면 k행에 위치한 퀸이 i행에 놓인 퀸에 의해 어느 한쪽 대각선으로 위협받고 있으면 위의 등식이 성립한다. Pseudo Codevoid queens(index i)&#123; index j; if (promising(i)) if (i == n) cout &lt;&lt; col[1] through col[n]; else for (j = 1; j &lt;= n; j++) &#123; // See if queen in col[i+1] = j; // (i+1)st row can be queens(i+1); // positioned in each of &#125; // the n columns.&#125;bool promising(index i)&#123; index k; bool switch; k = 1; switch = true; // Check if any queen threatens while (k &lt; i &amp;&amp; switch) &#123; // queen in the ith row. if (col[i] == col[k] || abs(col[i] - col[k]) == i - k) switch = false; k++; &#125; return switch;&#125; Source Code// File: nqueens.h#ifndef NQUEENS_H#define NQUEENS_Hnamespace algorithms&#123; void queens(int i, int n, int* col); // Problem: Position n queens on a chessboard so that no two are in the same // row, column, or diagonal. // Inputs: positive integer n, an array of integers col indexed from 1 to n. // Outputs: all possible ways n queens can be placed on an n x n chessboard so // that no two queens threaten each other. Each output consists of an array of // integers col indexed from 1 to n, where col[i] is the column where the queen // in the ith row is placed. bool promising(int i, int* col); template &lt;typename Item&gt; Item* get_vector_space(const int n) // Prostcondition: Return the array containing n spaces &#123; Item* v = new Item[n]; return (v-1); // offset the pointer &#125;&#125;#endif // File: nqueens.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt; // Provides setw#include \"nqueens.h\"using namespace std;namespace algorithms&#123; void queens(int i, int n, int* col) &#123; int j; if (promising(i, col)) &#123; if (i == n) &#123; // Print col[1] through col[n] for (j = 1; j &lt;= n; ++j) // Print index cout &lt;&lt; setw(7) &lt;&lt; \"col[\" &lt;&lt; j &lt;&lt; \"] = \" &lt;&lt; setw(2) &lt;&lt; col[j]; cout &lt;&lt; endl; &#125; else &#123; // See if queen in (i+1)st row can be positioned in each of the n columns. for (j = 1; j &lt;= n; ++j) &#123; col[i+1] = j; queens(i+1, n, col); &#125; &#125; &#125; &#125; bool promising(int i, int* col) &#123; int k; bool is_switch; k = 1; is_switch = true; // Check if any queen threatens queen in the ith row. while (k &lt; i &amp;&amp; is_switch) &#123; if (col[i] == col[k] || abs(col[i] - col[k]) == i - k) is_switch = false; k++; &#125; return is_switch; &#125; &#125; // File: nqueenstest.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include \"nqueens.h\"using namespace algorithms;int main( )&#123; // if n = 8 and there are 8 x 8 chessboard const int N_QUEENS_SIZE = 4; int* col = get_vector_space&lt;int&gt;(N_QUEENS_SIZE); queens(0, N_QUEENS_SIZE, col); delete [ ] (col+1); return EXIT_SUCCESS;&#125; Time Complexity AnalysisWorst-Case Time Complexity $O(n) = 1 + n + n^2 + n^3 + … + n^n = \\frac{n^{n+1} - 1}{n-1} \\in \\Theta(n^n)$ It is difficult to analyze n-Queens Algorithm theoretically. To do this, we have to determine the number of nodes checked as a function of n, the number of queens. Algorithm1 We can get an upper bound on the number of nodes in the pruned state space tree by counting the number of nodes in the entire state space tree. This latter tree contains 1 node at level 0, $n$ nodes at level 1, $n^2$ nodes at level 2, …, and $n^n$ nodes at level n. $$\\text{The total number of nodes is}=1 + n + n^2 + n^3 + … + n^n = \\frac{n^{n+1} - 1}{n-1}$$ This analysis is of limited value because the whole purpose of backtracking is to avoid checking many of these nodes. 가지 친 상태공간트리에서 전체 노드의 수를 세어 노드 개수의 상한을 구한다. 하지만 이 분석은 의미가 없다. 상한값으로는 백트래킹을 통해 점검하는 노드의 수를 얼마나 줄였는지 알 수 없기 때문이다. Algorithm2 Once the first queen is positioned, the second can be positioned in at most seven columns; once the second is positioned, the third can be positioned in at most six columns; and so on. Therefore, there are at most$$ \\text{Promising nodes}= 1 + n + n(n-1) + n(n-1)(n-2) + \\cdots + n!$$ 두개의 퀸이 같은 열에 위치할 수 없다는 사실을 이용하여 유망한 노드를 센다. 그러나 이 경우에도 알고리즘의 복잡도를 정확히 산출하진 못한다. 왜냐하면 대각선 점검을 고려하지 않았고 유망한 노드와 유망하지 않은 노드 둘다 포함하고 있기 때문이다. Backtracking A straightforward way to determine the efficiency of the algorithm is to actually run the algorithm on a computer and count how many nodes are checked. 위의 분석(Algorithm1, Algorithm2)으로는 백트래킹 알고리즘의 효율성을 제대로 파악할 수 없다. 유망한 노드의 개수를 정확하게 구하기 위한 유일한 방법은 실제로 알고리즘을 수행하여 구축된 상태공간트리의 노드의 개수를 세어 보는 것이다. However, running an algorithm to determine its efficiency is not really an analysis. We did this to illustrate how much time backtracking can save. The purpose of an analysis is to determine ahead of time whether an algorithm is efficient. In the next section we show how the Monte Carlo technique can be used to estimate the efficiency of a backtracking algorithm. n-Queens Algorithm1로 검사한 노드의 수 Algorithm2로 검사한 해답 후보의 수 백트래킹으로 검사한 노드의 수 백트래킹으로 유망함을 알아낸 노드의 수 $4$ $341$ $24$ $61$ $17$ $8$ $19,173,961$ $40,320$ $15,721$ $2,057$ $12$ $9.73 \\times 10^{12}$ $4.79 \\times 10^8$ $1.01 \\times 10^7$ $8.56 \\times 10^5$ $14$ $1.20 \\times 10^{16}$ $8.72 \\times 10^{10}$ $3.78 \\times 10^8$ $2.74 \\times 10^7$ 하지만 이 방법은 진정한 분석이 아니다. 분석은 알고리즘을 실제로 수행하지 않고 이루어져야 하기 때문이다. 위의 표는 백트래킹으로 n-퀸 문제를 해결하면 얼마나 시간을 절약할 수 있는지 설명하기 위해 알고리즘을 실행한 것일 뿐이다. n이 커질수록 상당한 시간 절약이 가능하다. 몬테 카를로 기법을 사용하면 백트래킹 알고리즘의 효율 추정이 가능하다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Backtracking","slug":"Algorithms/Backtracking","permalink":"http://melomance.github.io/categories/Algorithms/Backtracking/"}],"tags":[{"name":"백트래킹","slug":"백트래킹","permalink":"http://melomance.github.io/tags/백트래킹/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"Backtracking(백트래킹)","slug":"[AG][BT] Backtracking","date":"2011-08-06T01:32:00.000Z","updated":"2018-06-19T14:17:36.483Z","comments":true,"path":"2011/08/06/[AG][BT] Backtracking/","link":"","permalink":"http://melomance.github.io/2011/08/06/[AG][BT] Backtracking/","excerpt":"","text":"If you were trying to find your way through the well-known maze of hedges by Hampton Court Palace in England, you would have no choice but to follow a hopeless path until you reached a dead end. When that happened, you’d go back to a fork and pursue another path. Think how much easier it would be if there were a sign, positioned a short way down a path, that told you that the path led to nothing but dead ends. If the sign were positioned near the beginning of the path, the time savings could be enormous, because all forks after that sign would be eliminated from consideration. This means that not one but many dead ends would be avoided. There are no such signs in the famous maze of hedges or in most maze puzzles. However, as we shall see, they do exist in backtracking algorithms. 백트래킹의 개념을 의미하는 미로그림이 챕터 앞부분에 실려있다. 미로 속에서 길을 찾다가 막다른 곳에 조우했다면,가장 최근의 갈림길로 돌아가 다른 길을 갈 것이다. 갈림길의 시작지점에 막힌 곳으로 가는 경로가 표시되어 있다면, 표지판 뒤에 있는 모든 분기점들을 고려대상에서 제외시키기 때문에 탐색시간을 엄청나게 절약할 수 있을 것이다. 백트래킹 알고리즘에는 그런 표시가 존재한다. The Backtracking TechniqueBacktracking is used to solve problems in which a sequence of objects is chosen from a specified set so that the sequence satisfies some criterion. Backtracking is a modified depth-first search of a tree. Although the depth-first search is defined for graphs in general, we will discuss only searching of trees, because backtracking involves only a tree search. A preorder tree traversal is a depth-first search of the tree. This means that the root is visited first, and a visit to a node is followed immediately by visits to all descendants of the node. Although a depth-first search does not require that the children be visited in any particular order, we will visit the children of a node from left to right in the applications in this chapter. The nodes are numbered in the order in which they are visited. Notice that in a depth-first search, a path is followed as deeply as possible until a dead end is reached. At a dead end we back up until we reach a node with an unvisited child, and then we again proceed to go as deep as possible. 백트랙킹 기법은 지정된 집합(a specified set)에서 어떤 기준(creiterion)을 만족하면서 그 집합에 속한 대상의 순서(sequence)를 선택하는 문제를 푸는데 사용된다. 이 기법은 수정 된 깊이우선탐색(depth-first search)이다. 깊이우선탐색은 트리 방문방법 중 하나인 전위순회(preorder)와 같다. 루트가 되는 노드를 먼저 방문한 뒤, 그 노드의 모든 후손 노드들을 차례로(일반적으로 왼쪽에서 오른쪽) 방문한다. 깊이우선탐색에서의 방문경로는 더 이상 갈 수 없는 노드까지 내려간다. 그렇게 내려간 마지막 노드에서 다시 방문하지 않은 자식노드가 있는 노드로 되돌아가고, 거기서부터 다시 가능한 깊이까지 내려간다. There is a simple recursive algorithm for doing a depth-first search. Because we are presently interested only in preorder traversals of trees, we give a version that specifically accomplishes this. The procedure is called by passing the root at the top level. // Pseudocode for DFS(depth-first search)void depth_first_tree_search (node v)&#123; node u; visit v; for (each child u of v) depth_first_tree_search(u)&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Backtracking","slug":"Algorithms/Backtracking","permalink":"http://melomance.github.io/categories/Algorithms/Backtracking/"}],"tags":[{"name":"백트래킹","slug":"백트래킹","permalink":"http://melomance.github.io/tags/백트래킹/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"Dijkstra's Algorithm for Single-Source Shortest Paths(다익스트라 알고리즘)","slug":"[AG][GA] Dijkstra","date":"2011-07-24T08:23:00.000Z","updated":"2019-05-19T04:07:08.200Z","comments":true,"path":"2011/07/24/[AG][GA] Dijkstra/","link":"","permalink":"http://melomance.github.io/2011/07/24/[AG][GA] Dijkstra/","excerpt":"","text":"We developed a $\\Theta(n^3)$ algorithm, which is Floyd Algorithm, for determining the shortest paths from each vertex to all other vertices in a weighted, directed graph. If we wanted to know only the shortest paths from one particular vertex to all the others, that algorithm would be overkill. Therefore, we will use the greedy approach to develop a $\\Theta(n^2)$ algorithm for this problem (called the Single Source Shortest Paths problem). This algorithm is due to Dijkstra (1959). 앞서 동적계획법으로 살펴 본 플로이드 알고리즘 역시 최단경로 문제와 관련된 해법을 제시해준다. 플로이드 알고리즘의 경우, 그래프상의 각 정점에서 다른 모든 정점으로 가는 최단 경로를 제시해 준다. 하나의 특정 정점에서 다른 정점으로 가는 최단경로를 구하기 위해 플로이드 알고리즘을 사용하는 것은 과잉이다. 이 경우 탐욕적 접근법으로 설계된 다익스트라 알고리즘을 사용하여 문제를 해결하면 된다. Example Determine the shortest paths from $v_1$ to all other vertices in a weighted, directed graph. Init. $v_1$에서 다른 정점들로 가는 최단경로를 계산하고, 시작정점인 $v_1$이 먼저 선택된다. Step 1 $v_1$에서 가장 가까운 정점인 $v_5$가 선택된다. Step 2 $v_1$으로부터 {$v_5$}를 통해서 갈 수 있는 다음의 가장 가까운 정점은 $v_4$이므로, $v_4$가 선택된다. Step 3 $v_1$으로부터 {$v_4$, $v_5$}를 통해서 갈 수 있는 다음의 가장 가까운 정점은 $v_3$이므로, $v_3$가 선택된다. Step 4 $v_1$으로부터 {$v_3$, $v_4$, $v_5$}를 통해서 갈 수 있는 다음의 가장 가까운 정점은 $v_2$이다. 최단경로확정여부 $v_1$ $\\rightarrow$ $v_1$ $v_1$ $\\rightarrow$ $v_2$ $v_1$ $\\rightarrow$ $v_3$ $v_1$ $\\rightarrow$ $v_4$ $v_1$ $\\rightarrow$ $v_5$ Step 1 Y N N N Y Step 2 Y N N Y Y Step 3 Y N Y Y Y Step 4 Y Y Y Y Y The Dijkstra’s Algorithm for Single-Source Shortest PathsAlgorithm DesignWe initialize a set Y to contain only the vertex whose shortest paths are to be determined (the vertex is $v_1$). We initialize a set F of edges to being empty. First we choose a vertex $v$ that is nearest to $v_1$, add it to Y, and add the edge &lt;$v_1$, $v$&gt; to F. That edge is clearly a shortest path from $v_1$ to $v$. Next we check the paths from $v_1$ to the vertices in V - Y that allow only vertices in Y as intermediate vertices. A shortest of these paths is a shortest path. The vertex at the end of such a path is added to Y, and the edge (on the path) that touches that vertex is added to F. This procedure is continued until Y equals V, the set of all vertices. At this point, F contains the edges in shortest paths.This algorithm is very similar to Prim’s algorithm. The difference is that instead of the arrays nearest and distance, we have arrays touch and length, where for i = 2, …, n. touch[i] = index of vertex $v$ in Y such that the edge &lt;$v$, $v_i$&gt; is the last edge on the current shortest path from $v_1$ to $v_i$ using only vertices in Y as intermediates. length[i] = length of the current shortest path from $v_1$ to $v_i$ using only vertices in Y as intermediates. [용어정의] G=(V,E) 모든 정점들의 집합 V와 모든 이음선들의 집합 E로 구성된 그래프 G. Y 시작정점으로부터 최단경로가 이미 결정된 정점들의 집합이다. F Y의 정점들을 최단경로로 연결시키는 이음선들의 집합이다. touch[i] Y에 속한 정점 $v$의 인덱스이다. length[i] Y에 속한 정점만을 통해서 $v_i$로 가는 현재까지의 최단경로 길이이다. [다익스트라 알고리즘 초기화 로직]Y는 $v_1$(시작정점)만 포함하도록, F는 어떤 이음선도 포함하지 않도록 초기화시킨다.touch[i]는 시작정점인 $v_1$을 가리키는 1로 값을 초기화한다. 즉, touch[2], touch[3], …, touch[k] 값 모두 1이다. length[i] 값은 본래 시작정점에서 다른 정점으로 가는 경로의 길이로 초기화한다 (초기화 시점에서 Y에 속한 정점은 시작정점인 $v_1$하나) [다익스트라 알고리즘 메인 로직]$v_1$에서 가장 가까운 정점 $v$를 선택하여 Y에 추가하고, $v_1$과 $v$를 연결하는 이음선은 F에 추가한다. 이 이음선은 분명 $v_1$에서 $v$까지의 최단경로이다.다음으로 $v_1$에서 Y에 속해있는 정점들을 통해서 갈 수 있는 V - Y에 속한 정점들까지의 거리를 점검한다. 이 경로 중 가장 짧은 경로는 최단경로이므로, 해당 정점을 Y에 추가하고 그 정점과 연결되는 경로상의 이음선을 F에 추가한다. 이 과정을 Y가 모든 정점들의 집합 V와 같아질때까지 반복 수행한다. min vnear Y추가 F추가 length[2][3][4][5] touch[2][3][4][5] Init. - 1 $v_1$ ∅ 7 4 6 1 1 1 1 1 Step 1 1 5 $v_5$ &lt;$v_1$,$v_5$&gt; 7 4 2 -1 1 1 5 1 Step 2 2 4 $v_4$ &lt;$v_5$,$v_4$&gt; 5 4 -1 -1 4 1 5 1 Step 3 4 3 $v_3$ &lt;$v_1$,$v_3$&gt; 5 -1 -1 -1 4 1 5 1 Step 4 5 2 $v_2$ &lt;$v_4$,$v_2$&gt; -1 -1 -1 -1 4 1 5 1 시작정점을 포함시키지 않아도 되므로 총 n-1번의 루프를 수행한다. 메인루프에는 2개의 for문이 존재하는데, 첫번째 for문은 length[i]의 값들 중에서 가장 작은 값을 찾아 기록한다 (vnear). 다른 하나의 for문은 새로 추가된 정점을 현재까지의 중간정점에 포함시켜, 이를 이용해서 갈 수 있는 경로가 현재 경로의 값보다 작다면 length[i]와 touch[i]의 값을 갱신한다. 이 과정을 n-1번 반복수행하면 한 특정 정점에서 다른 정점으로 가는 최단경로를 구할 수 있다. 책에서는 시작정점을 $v_1$으로 한정짓고 있지만, 융통성 있는 프로그램을 위해 시작정점을 선택할 수 있도록 프로그램을 구현했다. Pseudo Codevoid dijkstra(int n, const number W[ ][ ], set_of_edges&amp; F)&#123; index i, vnear; edge e; index touch[2...n]; number length[2...n]; F = \"empty\"; for (i=2; i &lt;= n; i++) &#123; // For all vertices, initialize v1 to be the last touch[i] = 1; // vertex on the current shortest path from v1, length[i] = W[1][i]; // and initialize length of that path to be the &#125; // weight on the edge from v1. repeat(n-1 times) // Add all n-1 vertices to Y. &#123; min = \"infinite\"; for (i=2; i &lt;= n; i++) // Check each vertex for having shortest path. &#123; if (0 &lt;= length[i] &lt;= min) &#123; min = length[i]; vnear = i; &#125; &#125; e = edge from vertex indexed by touch[vnear] to vertex indexed by vnear; add e to F; for (i=2; i &lt;= n; i++) &#123; if (length[vnear] + W[vnear][i] &lt; length[i]) &#123; // For each vertex not in Y, update its shortest path length[i] = length[vnear] + W[vnear][i]; touch[i] = vnear; &#125; &#125; length[vnear] = -1; // Add vertex indexed by vnear to Y. &#125;&#125; Source Code// File: dijkstra.h#ifndef DIJKSTRA_H#define DIJKSTRA_H#include &lt;string&gt; // Provides string#include \"graph.h\"using namespace data_structures;namespace algorithms&#123; struct edge &#123; std::string vertex[2]; int weight; &#125;; typedef struct edge edge; typedef edge* set_of_edges; void dijkstra(int n, const graph g, set_of_edges&amp; F, int start_vertex); // Problem: Determine the shortest paths from v1 to all other vertices // in a weighted, directed graph. // Inputs: integer n &gt;= 2, and a connected, weighted, directed graph // containing n vertices. The graph is represented by graph class. // Outputs: set of edges F containing edges in shortest paths. template &lt;typename Item&gt; Item* get_vector_space(const int n) // Prostcondition: Return the array containing n spaces &#123; Item* v = new Item[n]; return (v-1); // offset the pointer &#125;&#125;#endif // File: dijkstra.cpp#include &lt;iostream&gt;#include \"dijkstra.h\"using namespace std;namespace algorithms&#123; void dijkstra(int n, const graph g, set_of_edges&amp; F, int start_vertex) &#123; int i, vnear; edge e; int* touch = get_vector_space&lt;int&gt;(n); int* length = get_vector_space&lt;int&gt;(n); // For all vertices, initialize start-vertex to be the last // vertex on the current shortest path from start-vertex, // and initialize length of that path to be the weight // on the edge from start-vertex. for (i = 1; i &lt;= n; ++i) &#123; touch[i] = start_vertex; length[i] = g.get_edge(start_vertex, i); &#125; int repeat = 0; while (repeat &lt; n) // Add all n vertices to Y. &#123; int min = graph::INFINITE; for (i = 1; i &lt;= n; ++i) // Check each vertex for having shortest path &#123; if (length[i] &gt;= 0 &amp;&amp; length[i] &lt; min) &#123; min = length[i]; vnear = i; &#125; &#125; // edge from vertex indexed by touch[vnear] to vertex indexed by vnear e.vertex[0] = g[touch[vnear]]; e.vertex[1] = g[vnear]; e.weight = min; F[repeat++] = e; // add e to F for (i = 1; i &lt;= n; ++i) &#123; if ((length[vnear] + g.get_edge(vnear, i)) &lt; length[i]) &#123; length[i] = length[vnear] + g.get_edge(vnear, i); touch[i] = vnear; &#125; &#125; length[vnear] = -1; cout &lt;&lt; \"min : \" &lt;&lt; min &lt;&lt; endl; cout &lt;&lt; \"vnear : \" &lt;&lt; vnear &lt;&lt; endl; cout &lt;&lt; \"length : \"; for (int k = 2; k &lt;= n; ++k) &#123; cout &lt;&lt; length[k] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl &lt;&lt; \"touch :\"; for (int k=2; k&lt;=n; ++k) &#123; cout &lt;&lt; touch[k] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; &#125;&#125; // File: shorttest.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt; // Provides setw#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include \"graph.h\" // Provides graph#include \"dijkstra.h\" // Provides Dijkstra's algorithmusing namespace std;using namespace data_structures;using namespace algorithms;int main( )&#123; const int GRAPH_SIZE = 5; int start_vertex = 1; set_of_edges F = new edge[GRAPH_SIZE]; graph test; test.set_vertex(\"V1\"); test.set_vertex(\"V2\"); test.set_vertex(\"V3\"); test.set_vertex(\"V4\"); test.set_vertex(\"V5\"); test.set_edge(1, 2, 7); test.set_edge(1, 3, 4); test.set_edge(1, 4, 6); test.set_edge(1, 5, 1); test.set_edge(3, 2, 2); test.set_edge(3, 4, 5); test.set_edge(4, 2, 3); test.set_edge(5, 4, 1); dijkstra(GRAPH_SIZE, test, F, start_vertex); for (int i = 0; i &lt; GRAPH_SIZE; ++i) &#123; cout &lt;&lt; \"The shortest path from v\" &lt;&lt; start_vertex &lt;&lt;\" to \"&lt;&lt; setw(3) &lt;&lt; F[i].vertex[1]; cout &lt;&lt; \" is\" &lt;&lt; setw(4) &lt;&lt; F[i].weight &lt;&lt; endl; &#125; return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation There are two loops, each with n-1 iterations, inside the repeat loop. Executing the instructions inside each of them can be considered to be doing the basic operation once. Input size n, the number of vertices. Every-Case Time Complexity $ T(n) = (n-1)2(n-1) = 2(n-1)^2 \\in \\Theta(n^2) $ Optimality ProofWe use a proof by contradiction. But first, we assert the following. LemmaLemma 1 Shortest paths are composed of shortest paths. The proof of this is based on the notion that if there was a shorter path than any sub-path, then the shorter path should replace that sub-path to make the whole path shorter. 최단경로를 구성하는 부분경로들 역시 최단경로이다. Lemma 2 If s $\\rightarrow$ … $\\rightarrow$ u $\\rightarrow$ v is a shortest path from s to v, then after u has been added to Y and we check paths from u to vertices in V - Y that allow only vertices in Y as intermediate vertices. Therefore, length[v] = δ(s,v) and length[v] is not changed thereafter. // check paths from u to vertices in V - Y that allow only vertices// in Y as intermediate vertices.if (length[u] + edge(u,v) &lt; length[v]) length[v] = length[u] + edge(u,v); s에서 v로가는 최단경로가 s $\\rightarrow$ … $\\rightarrow$ u $\\rightarrow$ v일 때, 정점 u가 Y에 추가되면서 length[v]를 더 짧은 거리로 갱신할 수 있는지 점검하므로 결국 length[v] = δ(s,v)가 된다. length[v] 값은 그 이후로 변하지 않는다. Proof by contradictionProof For each vertex u ∈ V, it follows from the fact that at all times length[u] $\\ge$ δ(s,u). After running Dijkstra’s algorithm, we assert that length[u] = δ(s,u). 다익스트라 알고리즘이 찾아낸 최단경로의 정확성을 검증한다. δ(s,u)는 시작정점 s에서 u까지의 최단경로를 의미하므로, 알고리즘 수행 후 모든 정점 u에 대해 length[u] = δ(s, u)가 성립함을 보이면 된다. 증명을 위해 귀류법(proof by contradiction)을 사용한다. 귀류법이란 어떤 명제를 반대로 가정했을 때, 모순을 이끌어내어 가정이 거짓임을 증명하는 방법이다. Hypothesis Suppose that u is the first vertex added to Y for which length[u] ≠ δ(s,u). We note: u cannot be s, because length[s] = 0. There must be a path from s to u. If there were not, length[u] would be infinity. Since there is a path, there must be a shortest path. Y(최단경로가 결정된 정점들의 집합)에 추가되는 첫번째 정점이 u일 때, 다익스트라 알고리즘이 정점 u에 대해 최단경로를 산출하지 못한다고 가정하자. (length[u] ≠ δ(s,u)) 바꿔 말하면 알고리즘이 산출한 최단경로보다 더 좋은 경로가 존재함을 의미한다. 먼저 u는 시작정점일 수 없다. 시작정점은 length[s] = δ(s,s) = 0 이기 때문이다.또한, s $\\rightarrow$ u 까지의 경로는 반드시 존재한다. 그렇지 않으면 length[u]는 무한대 값이므로, Y에 속하는 첫번째 정점으로 u가 선택될 수 없다. 정리하면 s $\\rightarrow$ u 까지의 최단경로가 존재하며, length[u] ≠ δ(s,u)이므로 현재까지 찾은 최단경로보다 더 짧은 최단경로가 존재한다. Let s $\\rightarrow$ v $\\rightarrow$ w $\\rightarrow$ u be the shortest path from s to u. Where v is within Y and w is the first vertex not within Y. When v was inserted into Y, length[v] = δ(s,v) (since we hypothesise that u was the first vertex for which this was not true). Edge (v,w) was relaxed at that time, so that $$\\begin{align}length[w] &amp;= δ(s,w) \\\\&amp;\\le δ(s,u) \\\\&amp;\\le length[u] \\tag{due to $w$ $\\rightarrow$ $u$}\\end{align}$$ 그 최단경로를 s $\\rightarrow$ v $\\rightarrow$ w $\\rightarrow$ u라고 하면, v는 Y에 속한 임의의 정점이고 w는 V-Y에 속한 임의의 정점이다. 그리고 보조정리에 따라 length[v] = δ(s,v)이며, v를 통해 w로가는 length[w] 값 역시 갱신된 상태다. 사실 이 최단경로는 참일 수 없다. 첫번째로 선택된 정점이 u인데 Y에 이미 v라는 정점이 존재하기 때문이다. 하지만 length[u] = δ(s,u)를 보이기 위해 증명을 계속 진행한다. Now both w and u were in V-Y when u was chosen, so$$length[u] \\le length[w]$$ w, u 둘다 V-Y에 속하는 정점이다. 여기서 u를 첫번째 정점으로 선택했다는 것은 시작정점으로부터 최단거리를 가지는 정점이 u라는 뜻이다. Thus the two inequalities must be equalities,$$\\underbrace{length[w] = δ(s,w) = δ(s,u) = length[u]}_{\\text{length[w] $\\le$ length[u] &amp; length[u] $\\le$ length[w]}}$$ So length[u] = δ(s,u) contradicting our hypothesis.Thus when each vertex u ∈ V was inserted to Y, length[u] = δ(s,u).Therefore, by the proof of contradiction, Dijkstra’s algorithm always produces Shortest Paths. 두 부등식에 의해 length[u] = δ(s,u)가 되므로, 다익스트라 알고리즘이 정점 u에 대해 최단경로를 산출하지 못한다는 가정에 모순이 생긴다. 그러므로 각 정점 u가 Y에 추가되면 length [u] = δ(s, u)이며, 다익스트라 알고리즘에서 계산된 Length[u]는 s에서 u까지의 최단경로이다. Greedy Approach ExercisesUse Dijkstra’s algorithm to find the shortest paths from the vertex $v_4$ to all the other vertices of the below graph. /* adjacency matrix for the above graph */index 1 2 3 4 5 6 7 8 9 10 ___________________________________________________ 1 │ 0 32 ∞ 17 ∞ ∞ ∞ ∞ ∞ ∞ 2 │ 32 0 ∞ ∞ 45 ∞ ∞ ∞ ∞ ∞ 3 │ ∞ ∞ 0 18 ∞ ∞ 5 ∞ ∞ ∞ 4 │ 17 ∞ 18 0 10 ∞ ∞ 3 ∞ ∞ 5 │ ∞ 45 ∞ 10 0 28 ∞ ∞ 25 ∞ 6 │ ∞ ∞ ∞ ∞ 28 0 ∞ ∞ ∞ 6 7 │ ∞ ∞ 5 ∞ ∞ ∞ 0 59 ∞ ∞ 8 │ ∞ ∞ ∞ 3 ∞ ∞ 59 0 4 ∞ 9 │ ∞ ∞ ∞ ∞ 25 ∞ ∞ 4 0 12 10 │ ∞ ∞ ∞ ∞ ∞ 6 ∞ ∞ 12 0/* the shortest paths from the vertex v4 to all the other vertices */The shortest path from v4 to v4 is 0The shortest path from v4 to v8 is 3The shortest path from v4 to v9 is 7The shortest path from v4 to v5 is 10The shortest path from v4 to v1 is 17The shortest path from v4 to v3 is 18The shortest path from v4 to v10 is 19The shortest path from v4 to v7 is 23The shortest path from v4 to v6 is 25The shortest path from v4 to v2 is 49","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"최단경로탐색","slug":"최단경로탐색","permalink":"http://melomance.github.io/tags/최단경로탐색/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"}]},{"title":"Comparing Prim's Algorithm with Kruskal's Algorithm(최소신장트리-프림 알고리즘 vs. 크러스컬 알고리즘)","slug":"[AG][GA] Prim's Algorithm vs. Kruskal's Algorithm","date":"2011-07-24T04:20:00.000Z","updated":"2018-06-17T12:47:11.138Z","comments":true,"path":"2011/07/24/[AG][GA] Prim's Algorithm vs. Kruskal's Algorithm/","link":"","permalink":"http://melomance.github.io/2011/07/24/[AG][GA] Prim's Algorithm vs. Kruskal's Algorithm/","excerpt":"","text":"Time ComplexityPrim’s Algorithm $T(n) \\in \\Theta(n^2)$ Kruskal’s Algorithm $W(m,n) \\in \\Theta(mlgm) \\text{ and } W(m,n) \\in \\Theta(n^2lgn)$ Comparing Both AlgorithmsThe number of edges in a connected graph$$ n - 1 \\leq m \\leq \\frac{n(n - 1)}{2}$$ 한 그래프에서 정점의 개수를 n이라고 할 때, 이음선 개수(m)의 범위는 n - 1개에서 부터 n(n - 1)/2 (1부터 n-1까지의 합)이다. For a graph whose number of edges m is near the low end of these limits (the graph is very sparse), Kruskal’s algorithm is $\\Theta(nlgn)$, which means that Kruskal’s algorithm should be faster. However, for a graph whose number of edges is near the high end (the graph is highly connected), Kruskal’s algorithmis $\\Theta(n^2lgn)$, which means that Prim’s algorithm should be faster. Time Complexity(시간복잡도) Sparse Graph(희소 그래프) Dense Graph(밀집 그래프) Prim’s Algorithm $\\Theta(n^2)$ $\\Theta(n^2)$ $\\Theta(n^2)$ Kruskal’s Algorithm $\\Theta(mlogm) \\ \\text{and} \\ \\Theta(n^2lgn)$ $\\Theta(mlgm)$ $\\Theta(n^2lgn)$ 이음선의 개수가 하한선 근처(n - 1에 근접)인 경우 희소 그래프(sparse graph)이고, 상한선 근처(n(n - 1)/2에 근접)인 경우는 밀집 그래프(dense graph) 이다. 결론적으로 희소 그래프의 경우 Kruskal 알고리즘의 성능이, 밀집 그래프의 경우엔 Prim 알고리즘의 성능이 효율적임을 알 수 있다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"},{"name":"최소신장트리","slug":"최소신장트리","permalink":"http://melomance.github.io/tags/최소신장트리/"}]},{"title":"Minimum Spanning Trees - Kruskal's Algorithm(최소신장트리-크러스컬)","slug":"[AG][GA] MST-Kruskal","date":"2011-07-21T02:51:00.000Z","updated":"2019-05-19T04:21:23.080Z","comments":true,"path":"2011/07/21/[AG][GA] MST-Kruskal/","link":"","permalink":"http://melomance.github.io/2011/07/21/[AG][GA] MST-Kruskal/","excerpt":"","text":"We will investigate two different greedy algorithms for this problem, Prim’s algorithm and Kruskal’s algorithm. Each uses a different locally optimal property. Recall that there is no guarantee that a given greedy algorithm always yields an optimal solution. One must prove whether or not this is the case. We will prove that both Prim’s and Kruskal’s algorithms always produce minimum spanning trees. 프림 알고리즘 대신 크러스컬 알고리즘을 이용해도 최소신장트리를 구할 수 있다. Example Determine a minimum spanning tree. Step 1 가중치를 기준으로 전체 이음선들을 오름차순으로 정렬한다. Step 2 5개의 정점들이 있으므로 총 5개의 서로소 집합, 즉 {$v_1$}, {$v_2$}, {$v_3$}, {$v_4$}, {$v_5$}이 만들어지게 된다. Step 3 오름차순으로 정렬된 이음선 중 최소가중치 값인 1이 선택된다. 1은 $v_1$정점과 $v_2$정점을 연결해주는 이음선 값이다. 그리고 $v_1$과 $v_2$는 서로소 집합이므로 두 집합을 하나의 부분집합으로 합진다. 현재까지의 부분집합은 {$v_1$, $v_2$}, {$v_3$}, {$v_4$}, {$v_5$} 이렇게 4개이다. Step 4 최소가중치를 갖는 이음선으로 $v_3$정점과 $v_5$정점을 연결해주는 2가 선택된다. $v_3$과 $v_5$역시 서로소 집합이므로 두 집합을 하나의 부분집합으로 합친다. 현재까지의 부분집합은 {$v_1$, $v_2$}, {$v_3$, $v_5$}, {$v_4$} 이렇게 3개이다. Step 5 최소가중치를 갖는 이음선으로 $v_1$정점과 $v_3$정점을 연결해주는 3이 선택되며, 위의 과정이 똑같이 수행된다. 현재까지의 부분집합은 {$v_1$, $v_2$, $v_3$, $v_5$}과 {$v_4$} 이렇게 총 2개이다. Step 6 다음으로 $v_2$정점과 $v_3$정점을 연결해주는 이음선 3이 선택된다. 그러나 $v_2$와 $v_3$의 경우 이미 같은 집합에 포함되어 있다. 같은 집합의 정점들끼리 연결하는 경우에는 순환경로가 생기므로 $v_2$정점과 $v_3$정점을 연결하는 이음선은 버린다. Step 7 마지막으로 $v_3$정점과 $v_4$정점을 연결하는 이음선이 선택되고, 5개로 출발했던 서로소 집합들이 하나의 집합으로 합쳐졌기 때문에 최소신장트리가 완성된다. Kruskal’s AlgorithmAlgorithm DesignTo write a formal version of Kruskal’s algorithm, we need a disjoint set abstract data type. The disjoint set abstract data type consists of data types index and set pointer, and routines initial, find, merge, and equal. 크러스컬 알고리즘에서는 서로소 집합(disjoint set)의 자료구조가 사용된다. Kruskal’s algorithm for the Minimum Spanning Tree problem starts by creating disjoint subsets of V, one for each vertex and containing only that vertex. It then inspects the edges according to nondecreasing weight (ties are broken arbitrarily). If an edge connects two vertices in disjoint subsets, the edge is added and the subsets are merged into one set. This process is repeated until all the subsets are merged into one set. The following is a high-level algorithm for this procedure. 정점들의 개수만큼 서로소 부분집합을 생성하고, 가중치를 기준으로 전체 이음선들을 오름차순으로 정렬한다. 그 다음 오름차순으로 정렬된 이음선들을 하나씩 조사하면서, 해당 이음선이 연결하고 있는 정점들이 서로소 부분집합이면 두 개의 부분집합을 하나로 합친다. 이 과정을 모든 서로소 부분집합들이 하나의 집합으로 합쳐질 때까지 계속 수행한다. Pseudo Codevoid kruskal(int n, int m, set_of_edges E, set_of_edges&amp; F)&#123; index i, j; set_pointer p, q; edge e; Sort the m edges in E by weight in nondecreasing order; F = \"empty\"; initial(n); while (number of edges in F is less than n-1) &#123; e = edges with least weight not yet considered; i, j = indices of vertices connected by e; p = find(i); q = find(j); if (!equal(p,q)) &#123; merge(p,q); add e to F; &#125; &#125;&#125; Source Code// File: kruskal.h#ifndef KRUSKAL_H#define KRUSKAL_H#include &lt;string&gt;#include \"graph.h\"using namespace data_structures;namespace algorithms&#123; struct edge &#123; std::string vertex[2]; int weight; &#125;; typedef struct edge edge; typedef edge* set_of_edges; void kruskal(int n, int m, set_of_edges&amp; E, set_of_edges&amp; F); // Problem: Determine a minimum spanning tree. // Inputs: integer n &gt;= 2, positive integer m, and a connected, weighted, // undirected graph containing n vertices and m edges. The graph is // represented b y a set E that contains the edges in the graph along // with their weights. // Outputs: F, a set of edges in a minimum spanning tree. void make_edgeset(const graph g, set_of_edges&amp; E, int&amp; num_of_edges); void init_edgeset(set_of_edges&amp; F, const int n); void mergesort2(set_of_edges&amp; data, int low, int high); void merge2(set_of_edges&amp; data, int low, int mid, int high); &#125;#endif // File: kruskal.cpp#include &lt;string&gt;#include \"disjointset.h\"#include \"kruskal.h\"namespace algorithms&#123; void kruskal(int n, int m, set_of_edges &amp;E, set_of_edges &amp;F) &#123; disjointset dsjset(n); // disjoint set disjointset::index i, j; disjointset::set_pointer p, q; edge e; // Sort the m edges in E by weight in nondecreasing order mergesort2(E, 0, m); dsjset.initialize(n); // Initialize n disjoint subsets. int k = 0; int repeat = 0; while (repeat &lt; n) &#123; // edge with least weight not yet considered e.weight = E[repeat].weight; e.vertex[0] = E[repeat].vertex[0]; e.vertex[1] = E[repeat].vertex[1]; // indices of vertices connected by e i = atoi(e.vertex[0].c_str()); j = atoi(e.vertex[1].c_str()); p = dsjset.find(i); q = dsjset.find(j); if (!dsjset.equal(p, q)) &#123; dsjset.merge(p, q); F[k++] = e; &#125; ++repeat; &#125; &#125; void make_edgeset(const graph g, set_of_edges &amp;E, int &amp;num_of_edges) &#123; edge e; int cnt = 0; int k = 0; for (int i = 1; i &lt;= g.get_size(); ++i) &#123; for (int j = i; j &lt;= g.get_size(); ++j) &#123; if (g.get_edge(i, j) != graph::INFINITE &amp;&amp; g.get_edge(i, j) != 0) &#123; // edge connecting vertices index by i and j e.vertex[0] = std::to_string(i); e.vertex[1] = std::to_string(j); e.weight = g.get_edge(i, j); E[k++] = e; // add e to E ++cnt; // count valid edges &#125; &#125; &#125; num_of_edges = cnt; &#125; void init_edgeset(set_of_edges &amp;F, const int n) &#123; for (int i = 0; i &lt; n; ++i) &#123; F[i].vertex[0] = \"\"; F[i].vertex[1] = \"\"; F[i].weight = graph::INFINITE; &#125; &#125; void mergesort2(set_of_edges &amp;data, int low, int high) // Problem: Sort n keys in nondecreasing sequence. // Inputs: positive integer n, array of key S indexed from 1 to n. // the array S containing the keys in nondecreasing order. &#123; int mid; if (low &lt; high) &#123; mid = (low + high) / 2; mergesort2(data, low, mid); mergesort2(data, mid + 1, high); merge2(data, low, mid, high); &#125; &#125; void merge2(set_of_edges &amp;data, int low, int mid, int high) &#123; int i, j, k; // A local array needed for the merging set_of_edges temp = new edge[(high - low) + 1]; i = low; j = mid + 1; k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (data[i].weight &lt; data[j].weight) temp[k] = data[i++]; // Copy from first half else temp[k] = data[j++]; // Copy from second half k++; &#125; // Copy any remaining entries in the left and right subarrays. if (i &gt; mid) &#123; while (j &lt;= high) temp[k++] = data[j++]; &#125; else &#123; while (i &lt;= mid) temp[k++] = data[i++]; &#125; // Copy from temp back to the data array, and release temp's memory. i = low; for (k = 0; k &lt; (high - low) + 1; ++k) data[i++] = temp[k]; delete[] temp; &#125;&#125; // namespace algorithms // File: minspantree.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS;#include &lt;iomanip&gt; // Provides setw#include \"graph.h\" // Provides graph#include \"kruskal.h\" // Provides Kruskal's algorithm#include \"disjointset.h\" // Provides disjoint setusing namespace std;using namespace data_structures;using namespace algorithms;int main()&#123; const int GRAPH_SIZE = 5; int num_of_edges = 0; set_of_edges E, F; graph example(GRAPH_SIZE); example.set_vertex(\"V1\"); example.set_vertex(\"V2\"); example.set_vertex(\"V3\"); example.set_vertex(\"V4\"); example.set_vertex(\"V5\"); example.set_edge(1, 2, 1); example.set_edge(1, 3, 3); example.set_edge(2, 1, 1); example.set_edge(2, 3, 3); example.set_edge(2, 4, 6); example.set_edge(3, 1, 3); example.set_edge(3, 2, 3); example.set_edge(3, 4, 4); example.set_edge(3, 5, 2); example.set_edge(4, 2, 6); example.set_edge(4, 3, 4); example.set_edge(4, 5, 5); example.set_edge(5, 3, 2); example.set_edge(5, 4, 5); E = new edge[GRAPH_SIZE * GRAPH_SIZE]; make_edgeset(example, E, num_of_edges); // Copy edges from graph F = new edge[num_of_edges]; init_edgeset(F, num_of_edges); for (int i = 0; i &lt; num_of_edges; ++i) cout &lt;&lt; \"V\" &lt;&lt; E[i].vertex[0] &lt;&lt; \" to \" &lt;&lt; \"V\" &lt;&lt; E[i].vertex[1] &lt;&lt; \" with weight \" &lt;&lt; E[i].weight &lt;&lt; endl; kruskal(example.get_size(), num_of_edges, E, F); // Kruskal algorithm for (int i = 0; i &lt; num_of_edges; ++i) &#123; if (F[i].weight != 0 &amp;&amp; F[i].weight != graph::INFINITE) &#123; cout &lt;&lt; setw(7) &lt;&lt; \"From\" &lt;&lt; setw(3) &lt;&lt; \"V\" &lt;&lt; F[i].vertex[0] &lt;&lt; setw(3) &lt;&lt; \"to\" &lt;&lt; setw(3) &lt;&lt; \"V\" &lt;&lt; F[i].vertex[1] &lt;&lt; \": \" &lt;&lt; F[i].weight &lt;&lt; endl; &#125; &#125; delete[](E); delete[](F); return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation A comparison instruction. Input size n, the number of vertices, and m, the number of edges. Worst-Case Time Complexity $W(m,n) \\in \\Theta(n^2lgn^2) = \\Theta(n^22lgn) = \\Theta(n^2lgn)$ W(m)= The time to sort the edges(Mergesort) $W(m) \\in \\Theta(mlgn)$ W(m)= The time in the while loop $W(m) \\in \\Theta(mlgn)$ T(n)= The time to initialize n disjoint sets $T(n) \\in \\Theta(n)$ Optimality ProofWe show that the following proposition P is true by induction. proposition P If F is the set of edges chosen at any stage of the algorithm, then there is some minimum spanning tree that contains F. F가 알고리즘의 어느 단계에서 선택된 이음선의 집합이라면 F를 포함하는 최소신장트리가 존재한다. Clearly P is true at the beginning, when F is empty: any minimum spanning tree will do, and there exists one because a weighted connected graph always has a minimum spanning tree. 처음 시작은 F가 공집합인 경우다. 연결되고, 가중치가 있는 비방향성 그래프에서는 항상 최소신장트리가 존재하므로, 공집합 F를 포함하는 최소신장트리가 존재한다. 따라서 명제 P는 참이다. Now assume P is true for some non-final edge set F and let T be a minimum spanning tree that contains F. 이제 P가 공집합이 아닌 이음선 집합 F에 대해서도 참이며, T가 F를 포함하는 최소신장트리라고 가정한다. Case 1 If the next chosen edge e is also in T, then P is true for F U {e}. 다음에 선택된 이음선 e가 e ∈ T라면, F U {e}에 대해 명제 P가 참이다. Case 2 Otherwise, e is not in T, and T U {e} has a cycle C and there is another edge e’ that is in C but not F. (Since if all the e’ are in the F, then the algorithm won’t choose e, otherwise it will be a cycle.) (If there was no such edge e’, then e could not have been added to F, since doing so would have created the cycle C.) Then T − {e’} U {e} is a tree, and it has the same weight as T, since T has minimum weight and the weight of e’ cannot be less than the weight of e, otherwise the algorithm would have chosen e’ instead of e. So T − {e’} U {e} is a minimum spanning tree containing F U {e} and again P holds. 만일 e ∉ T라면 T U {e}는 순환경로 C를 가지며 그 순환경로상에는 F에 속하지 않은 이음선 e’가 있다.(모든 e’가 F에 속하게 되면 알고리즘은 e를 선택하지 않는다. e를 선택하는 순간 순환경로가 생기기 때문이다.)(그런 이음선 e’가 없다면, e를 F에 추가할 수 없다. e를 추가하면 순환경로 C가 생성되기 때문이다.) 그러면 T - {e’} U {e}는 트리이고 T와 동일한 가중치를 가진다. (T는 최소가중치를 가지며 e’의 가중치는 e의 가중치보다 작을 수 없다. 그렇지 않으면 크러스컬 알고리즘은 e대신 e’를 선택하게 된다.) 따라서 T - {e’} U {e}는 F U {e}를 포함하는 최소신장트리이며 명제 P가 유지된다. Therefore, by the principle of induction, P holds when F has become a spanning tree, which is only possible if F is a minimum spanning tree itself. 그러므로 귀납법 원리에 의해, 명제 P(F가 알고리즘의 어느 단계에서 선택된 이음선의 집합이라면 F를 포함하는 최소신장트리가 존재)는 F가 신장트리가 될 때 성립하며, 이는 F가 최소신장트리 자체인 경우에만 가능하다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"},{"name":"최소신장트리","slug":"최소신장트리","permalink":"http://melomance.github.io/tags/최소신장트리/"}]},{"title":"Minimum Spanning Trees - Prim's Algorithm(최소신장트리-프림)","slug":"[AG][GA] MST-Prim","date":"2011-07-20T00:09:00.000Z","updated":"2019-05-19T04:07:03.838Z","comments":true,"path":"2011/07/20/[AG][GA] MST-Prim/","link":"","permalink":"http://melomance.github.io/2011/07/20/[AG][GA] MST-Prim/","excerpt":"","text":"Consider the problem of removing edges from a connected, weighted, undirected graph G to form a subgraph such that all the vertices remain connected and the sum of the weights on the remaining edges is as small as possible. Such a problem has numerous applications. Road construction: want to connect a set of cities with a minimum amount of road. Telecommunications: want to use a minimal length of cable. Plumbing: want to use a minimal amount of pipe. A spanning tree for graph G is a connected subgraph that contains all the vertices in G and is a tree. An algorithm for our problem must obtain a spanning tree of minimum weight. Such a tree is called a minimum spanning tree. A graph can have more than one minimum spanning tree. A subgraph with minimum weight must be a tree, because if a subgraph were not a tree, it would contain a simple cycle, and we could remove any edge on the cycle, resulting in a connected graph with a smaller weight. It is possible that a graph can have more than one minimum spanning tree. 그래프 G에 대한 신장트리는 G의 모든 정점을 포함한 트리이다. 하나의 그래프에는 여러 신장트리가 존재할 수 있는데, 모든 신장트리가 최소신장트리는 아니다. 이번 알고리즘의 목적은 여러 신장트리 중 가중치 합이 가장 작은 신장트리를 찾는 것이다. 최소의 가중치를 갖는 부분그래프는 반드시 트리이다. 그렇지 않으면 그래프 내에는 순환경로(cycle)가 있을 것이고, 그 순환경로상의 한 이음선을 제거함으로써 더 작은 비용의 신장트리를 만들 수 있다. Example Determine a minimum spanning tree. Step 1 시작 정점으로 $v_1$을 선택한다. Step 2 {$v_1$}에서 가장 가까운 정점인 $v_2$를 추가한다. 여기서 가깝다는 뜻은 이음선의 길이가 가장 작음을 의미한다. Step 3 {$v_1$, $v_2$}에서 가장 가까운 정점인 $v_3$를 추가한다. Step 4 {$v_1$, $v_2$, $v_3$}에서 가장 가까운 정점인 $v_5$를 추가한다. Step 5 {$v_1$, $v_2$, $v_3$, $v_5$}에서 선택되지 않은 가장 작은 이음선의 값은 3이다. 하지만 이 값을 선택하면 순환경로가 생기므로 선택하지 않고, 그 다음 작은 값인 $v_3$과 $v_4$를 잇는 이음선을 선택하면서 마지막 정점인 $v_4$를 추가한다. 이렇게 모든 정점을 포함하게 되면 최소신장트리가 완성된다. Prim’s AlgorithmAlgorithm DesignPrim’s algorithm starts with an empty subset of edges F and a subset of vertices Y initialized to contain an arbitrary vertex. We will initialize Y to {$v_1$}. A vertex nearest to Y is a vertex in V - Y that is connected to a vertex in Y by an edge of minimum weight. Because at the start Y = {$v_1$}, nearest[i] is initialized to 1 and distance[i] is initialized to the weight on the edge between $v_1$ and $v_i$. As vertices are added to Y, these two arrays are updated to reference the new vertex in Y nearest to each vertex outside of Y. To determine which vertex to add to Y, in each iteration we compute the index for which distance[i] is the smallest. We call this index vnear. The vertex indexed by vnear is added to Y by setting distance[vnear] to −1. [용어정의] G=(V,E) 모든 정점들의 집합 V와 모든 이음선들의 집합 E로 구성된 그래프이다. F E의 유망한 부분집합이다(최소신장트리가 되도록 이음선 추가 가능) Y F의 이음선들에 의해 연결된 정점들의 집합이다. nearest[i] Y에 속한 정점 중에서 $v_i$와 가장 가까운 정점의 인덱스이다. distance[i] $v_i$와 nearest[i]를 잇는 이음선의 가중치이다. vnear Y에 추가 할 정점을 결정하기 위해 distance[i] 중 최소값을 보유한 인덱스를 찾는데, 이 인덱스를 vnear라고 부른다. [프림 알고리즘 초기화 로직]distance[2]의 값은 W[1][2], distance[3]는 W[1][3], …, distance[k]는 W[1][k] 일 것이다. 왜냐하면 초기화 시점에서 Y에 속한 정점은 시작정점, 즉 $v_1$하나이므로 이를 통해서만 다른 정점으로 갈 수 있기 때문이다.nearest[i]는 시작정점인 $v_1$으로 값을 초기화한다. 즉, nearest[2], nearest[3], …, nearest[k] 모두 1로 초기화 된다. 시작정점을 제외한 다른 모든 정점들에게 가장 가까운 정점을 $v_1$으로 초기화 시키는 것 뿐이다. (해당 정점으로 갈 수 있는 이음선이 없을지라도) [프림 알고리즘 메인 로직]시작정점을 포함시키지 않아도 되므로 총 n-1번의 루프 수행과정에서 distance[i]와 nearest[i]값들을 갱신해 나가며 최소신장트리를 완성한다. distance[i]의 값들 중에서 가장 작은 이음선의 값을 찾아 기록한 후, 추가된 정점을 통해 갈 수 있는 이음선의 값이 기존의 값 보다 작다면 distance[i]와 nearest[i] 값을 갱신한다. min vnear distance[2][3][4][5] nearest[2][3][4][5] Step 1 - - 1 3 ∞ ∞ 1 1 1 1 Step 2 1 2 -1 3 6 ∞ 1 1 2 1 Step 3 3 3 -1 -1 4 2 1 1 3 3 Step 4 2 5 -1 -1 4 -1 1 1 3 3 Step 5 4 4 -1 -1 -1 -1 1 1 3 3 이해를 돕기 위해 위의 예제의 $v_2$가 추가되는 과정(Step 2)을 살펴보자. 먼저 $v_2$는 $v_1$에서 가장 가까운(min = 1) 정점이므로 추가가 되고 (vnear = 2), 추후에 다시 고려할 필요가 없기 때문에 distance[vnear = 2]의 값을 -1로 할당한다. $v_2$를 추가함으로써 $v_4$까지 갈 수 있는 이음선이 생기며, 이 값은 6으로 초기값인 ∞보다 작으므로 distance[4], nearest[4]의 값을 갱신한다. 이 과정을 n-1번 반복하게 되며, 그 결과로 최소신장트리를 얻을 수 있다. Pseudo Codevoid prim(int n, const number W[ ][ ], set_of_edges&amp; F)&#123; index i, vnear; number min; edge e; index nearest[2...n]; number distance[2...n]; F = \"empty\"; for (i = 2; i &lt;= n; ++i) &#123; // For all vertices, initialize V1 to be the nearest[i] = 1; // nearest vertex in Y and initialize the distance[i] = W[1][i]; // distance from Y to be the weight on &#125; // the edge to V1. repeat(n-1 times) // Add all n-1 vertices to Y. &#123; min = \"infinite\"; for (i = 2; i &lt;= n; i++) // Check each vertex for if (0 &lt;= distance[i] &lt;= min) // being nearest to Y. &#123; min = distance[i]; vnear = i; &#125; e = edge connecting vertices indexed by vnear and nearest[vnear]; add e to F; distance[vnear] = -1; // Add vertex indexed by vnear to Y. for (i = 2; i &lt;= n; i++) if (W[i][vnear] &lt; distance[i]) // For each vertex not in Y, &#123; // update its distance from Y. distance[i] = W[i][vnear]; nearest[i] = vnear; &#125; &#125;&#125; Source Code// File: prim.h#ifndef PRIM_H#define PRIM_H#include \"graph.h\"using namespace data_structures;namespace algorithms&#123; struct edge &#123; std::string vertex[2]; int weight; &#125;; typedef struct edge edge; typedef edge* set_of_edges; void prim(int n, const graph g, set_of_edges&amp; F); // Problem: Determine a minimum spanning tree. // Inputs: integer n &gt;= 2, and a connected, weighted, undirected graph // containing n vertices. The graph is represented by a two-dimensional // array W, which has both its rows and columns indexed from 1 to n, // where W[i][j] is the weight on the edge between the ith vertex and // the jth vertex. // Outputs: set of edges F in a minimum spanning tree for the graph. template &lt;typename Item&gt; Item* get_vector_space(const int n) // Postcondition: Return the array containing n spaces &#123; Item* v = new Item[n]; return (v-1); // offset the pointer &#125;&#125;#endif // File: prim.cpp#include \"prim.h\"namespace algorithms&#123; void prim(int n, const graph g, set_of_edges&amp; F) &#123; int i, vnear; int min; edge e; int* nearest = get_vector_space&lt;int&gt;(n); int* distance = get_vector_space&lt;int&gt;(n); // For all vertices, initialize V1 to be the nearest vertex in Y // and initialize the distance from Y to be the weight on the edge to V1. for (i = 2; i &lt;= n; ++i) &#123; nearest[i] = 1; distance[i] = g.get_edge(1, i); &#125; int repeat = 0; while (repeat &lt; n-1) // Add all n-1 vertices to Y. &#123; min = graph::INFINITE; for (i = 2; i &lt;= n; ++i) // Check each vertex for being nearest to Y &#123; if (distance[i] &gt;= 0 &amp;&amp; distance[i] &lt; min) &#123; min = distance[i]; vnear = i; &#125; &#125; // edge connecting vertices index by vnear and nearest[vnear] e.vertex[0] = g[nearest[vnear]]; e.vertex[1] = g[vnear]; e.weight = min; F[repeat++] = e; // add e to F distance[vnear] = -1; for (i = 2; i &lt;=n ;++i) &#123; if (g.get_edge(i, vnear) &lt; distance[i]) &#123; distance[i] = g.get_edge(i, vnear); nearest[i] = vnear; &#125; &#125; &#125; &#125;&#125; #include &lt;iostream&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS;#include &lt;iomanip&gt; // Provides setw#include \"graph.h\" // Provides graph#include \"prim.h\" // Provides Prim's algorithmusing namespace std;using namespace data_structures;using namespace algorithms;int main( )&#123; const int GRAPH_SIZE = 5; graph example(GRAPH_SIZE); example.set_vertex(\"V1\"); example.set_vertex(\"V2\"); example.set_vertex(\"V3\"); example.set_vertex(\"V4\"); example.set_vertex(\"V5\"); example.set_edge(1, 2, 1); example.set_edge(1, 3, 3); example.set_edge(2, 1, 1); example.set_edge(2, 3, 3); example.set_edge(2, 4, 6); example.set_edge(3, 1, 3); example.set_edge(3, 2, 3); example.set_edge(3, 4, 4); example.set_edge(3, 5, 2); example.set_edge(4, 2, 6); example.set_edge(4, 3, 4); example.set_edge(4, 5, 5); example.set_edge(5, 3, 2); example.set_edge(5, 4, 5); //display_graph(example); set_of_edges F = new edge[GRAPH_SIZE-1]; prim(GRAPH_SIZE, example, F); cout &lt;&lt; \"Given a graph, the minimum spanning tree consists of \" &lt;&lt; endl; for (int i = 0; i &lt; GRAPH_SIZE-1; ++i) &#123; cout &lt;&lt; setw(7) &lt;&lt; \"From\" &lt;&lt; setw(3) &lt;&lt; F[i].vertex[0] &lt;&lt; setw(3) &lt;&lt; \"to\" &lt;&lt; setw(3) &lt;&lt; F[i].vertex[1] &lt;&lt; \": \" &lt;&lt; F[i].weight &lt;&lt; endl; &#125; return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation There are two loops, each with n-1 iterations, inside the repeat loop. Executing the instructions inside each of them can be considered to be doing the basic operation once. Input size n, the number of vertices. Every-Case Time Complexity $T(n) = 2(n-1)(n-1) \\in \\Theta (n^2)$ Optimality ProofAlthough greedy algorithms are often easier to develop than dynamic programming algorithms, usually it is more difficult to determine whether or not a greedy algorithm always produces an optimal solution. Recall that for a dynamic programming algorithm we need only show that the principle of optimality applies. For a greedy algorithm we usually need a formal proof. Next we give such a proof for Prim’s algorithm. 프림 알고리즘이 찾아낸 신장트리가 최소신장트리인지 검증해야 한다. 다시 말하자면, 동 알고리즘을 통해 얻은 해답이 최적(optimal)인지를 결정해야 한다. 증명을 위해 보조 정리(Lemma)가 참임을 보이고 이를 이용하여 귀납법으로 프림 알고리즘이 최적의 원칙을 준수하는지 증명할 것이다. LemmaLemma Let G = (V, E) be a connected, weight, undirected graph; let F be a promising subset of E; and let Y be the set of vertices connected by the edges in F. If e is an edge of minimum weight that connects a vertex in Y to a vertex in V - Y, then F U {e} is promising. G = (V, E)는 연결되고, 가중치가 있는 비방향성 그래프라고 하자. F는 E의 유망한 부분집합이라 하자. Y는 F의 이음선들에 의해 연결된 정점들의 집합이라 하자. 이때 Y에 있는 정점과 V - Y에 있는 정점을 잇는 이음선 중, 그 가중치가 가장 작은 이음선을 e라고 하면, F U {e}는 유망하다. 유망하다는 말은, 비방향성 그래프 G = (V, E)가 주어지고 만약 E의 부분집합인 F에 최소신장트리가 되도록 이음선을 추가할 수 있으면 F는 유망하다(promising)라고 한다. Proof Because F is promising, there must be some set of edges F’ such that F ⊆ F’ and (V, F’) is a minimum spanning tree. F가 유망하기 때문에(F에 최소신장트리가 되도록 이음선 추가 가능), F ⊆ F’ 이면서 (V, F’)가 최소신장트리가 되는 이음선의 집합 F’가 반드시 존재한다. If e ∈ F’, then F U {e} ⊆ F’, which means F U {e} is promising. 만일 e ∈ F’라면, F U {e} ⊆ F’가 되고, 따라서 F U {e}도 유망하다. Otherwise, because (V, F’) is a spanning tree, F’ U {e} must contain exactly one simple cycle and e must be in the cycle. There must be another edge e’ ∈ F’ in the simple cycle that also connects a vertex in Y to one in V - Y. If we remove e’ from F’ U {e}, the simple cycle disappears, which means that we have a spanning tree. Because e is an edge of minimum weight that connects a vertex in Y to on in V - Y, the weight of e must be less than or equal to the weight of e’ (in fact, they must be equal.) So F’ U {e} - {e’} is a minimum spanning tree. Now F U {e} ⊆ F’ U {e} - {e’}, because e’ cannot be in F (recall that edges in F cannot only vertices in Y.) Therefore, F U {e} is promising. 만일 e ∉ F’ 라면, (V, F’)는 이미 신장트리라는 뜻이다. 따라서 F’ U {e}는 정확히 하나의 단순순환경로를 포함해야하고 e는 그 순환경로 내에 있어야 한다. (위의 예제에서는 $v_1$ $\\rightarrow$ $v_2$ $\\rightarrow$ $v_4$ $\\rightarrow$ $v_3$ $\\rightarrow$ $v_1$)Y에 있는 한 정점에서 V - Y에 있는 한 정점을 연결하는 임의의 이음선 e’ ⊆ F’는 그 순환경로 안에 반드시 존재하게 된다. F’ U {e}에서 e’를 제거하면 단순순환경로는 사라지며 다시 신장트리가 형성된다. e는 Y에 있는 한 정점에서 V - Y에 있는 한 정점을 연결하는 최소가중치 이음선이므로, e의 가중치는 반드시 e’의 가중치 보다 작거나 같다. (실제로 반드시 같게 된다.) 그러면 F’ U {e} - {e’}는 최소신장트리이다. 결론적으로 e’가 F안에 있을 수 없으므로(F안에 있는 이음선들은 Y안에 있는 정점들 만을 연결함을 기억하라) F U {e} ⊆ F’ U {e} - {e’}가 되고, 따라서 F U {e}는 유망하다. Theorem: Prim’s algorithm always produces a minimum spanning tree.Proof We use induction to show that the set F is promising after each iteration of the repeat loop.Induction base Clearly the empty set is promising.Induction hypothesis Assume that, after a given iteration of the repeat loop, the set of edges so far selected - namely, F is promising.Induction step We need to show that the set F U {e} is promising, where e is the edge selected in the next iteration. Because the edge e selected in the next iteration is an edge of minimum weight that connects a vertex in Y to one on V - Y, F U {e} is promising, by Lemma. This completes the induction proof. 매번 반복이 수행된 후 E의 부분집합 F에 최소신장트리가 되도록 이음선을 추가할 수 있다는 것을 보이면 된다. (즉, F는 유망하다는 것을 입증한다.) 처음 시작은 공집합이다. 연결되고, 가중치가 있는 비방향성 그래프에서는 항상 최소신장트리가 존재하므로, 공집합 F를 포함하는 최소신장트리가 존재한다. 따라서 공집합이 아닌 F에 대해 F U {e}가 유망하다는 사실만 보이면 된다. e는 다음 반복에서 선택된 이음선이다. e는 Y에 있는 정점을 V - Y에 있는 정점으로 연결하는 최소가중치를 지닌 이음선이기 때문에, 보조정리에 따라 F U {e}는 유망하다고 할 수 있다. 이것으로 귀납 증명이 완료된다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"},{"name":"최소신장트리","slug":"최소신장트리","permalink":"http://melomance.github.io/tags/최소신장트리/"}]},{"title":"Coin Change Problem(동전교환문제)","slug":"[AG][GA] Coin Chng Problem","date":"2011-07-19T23:36:00.000Z","updated":"2018-06-11T15:10:14.941Z","comments":true,"path":"2011/07/20/[AG][GA] Coin Chng Problem/","link":"","permalink":"http://melomance.github.io/2011/07/20/[AG][GA] Coin Chng Problem/","excerpt":"","text":"A simple example illustrates the greedy approach. Joe, the sales clerk, often encounters the problem of giving change for a purchase. Customers usually don’t want to receive a lot of coins. For example, most customers would be aggravated if he gave them 87 pennies when the change was $0.87. Therefore, his goal is not only to give the correct change, but to do so with as few coins as possible. 정확하게 거스름돈을 건네주면서 가능한 코인을 적게 주는 것이 이 문제의 핵심이다. 보통의 고객은 잔돈으로 많은 동전을 받기를 꺼려한다는 점을 상기하자. 잔돈을 거슬러주거나 받을 때 우리는 무의식적으로 탐욕적인 방법을 이미 사용하고 있다. Example A greedy algorithm for giving change. The amount owed is 36 cents. (quarter)¢25 (dime)¢10 (nickel)¢5 (penny)¢1 Joe가 보유한 코인 1개 2개 1개 2개 위의 그림은 주어진 문제에 대하여 탐욕적인 접근 방법을 잘 보여주고 있다. 36센트를 맞춰야 하므로 먼저 가장 큰 25센트를, 그 다음엔 10센트를, 마지막으로 1센트를 잡음으로써 최적의 해답에 도달한다. (￠36 = ￠25 ＋ ￠10 ＋ ￠1) Example The greedy algorithm is not optimal if a 12-cent coin is included. The amount owed is 16 cents. ¢12 ¢10 ¢5 ¢1 Joe가 보유한 코인 1개 1개 1개 4개 12센트짜리가 포함된 상태로 16센트를 거슬러줘야 한다. 탐욕 알고리즘으로 얻어진 해답은 (￠16 = ￠12 ＋ ￠1 ＋ ￠1 ＋ ￠1 ＋ ￠1) 로 동전의 개수가 5개이다. 하지만 최적의 해답은 (￠16 = ￠10 ＋ ￠5 ＋ ￠1) 으로 동전의 개수가 3개 임을 알 수 있다. 결론적으로 탐욕 알고리즘은 항상 최적의 해를 보장하지 못한다. 따라서 알고리즘으로 부터 얻은 결과가 최적의 해답인지를 반드시 검증해야 한다. Change Problem Algorithm Pseudocode// Pseudocode: Change Problemwhile (there are more coins and the instance is not solved)&#123; Grab the largest remaining coin; // selection procedure // feasibility check if (adding the coin makes the change exceed the amount owed) reject the coin; else add the coin to the change; // solution check if (the total value of the change equals the amount owed) the instance is solved;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"}]},{"title":"Greedy Approach(탐욕 알고리즘)","slug":"[AG][GA] Greedy Approach","date":"2011-01-23T13:41:00.000Z","updated":"2018-05-30T13:02:45.073Z","comments":true,"path":"2011/01/23/[AG][GA] Greedy Approach/","link":"","permalink":"http://melomance.github.io/2011/01/23/[AG][GA] Greedy Approach/","excerpt":"","text":"Charles Dicken’s classic character Ebenezer Scrooge may well be the most greedy person ever, fictional or real. Recall that Scrooge never considered the past or future. Each day his only drive was to greedily grab as much gold as he could. After the Ghost of Christmas Past reminded him of the past and the Ghost of Christmas Future warned him of the future, he changed his greedy ways.A greedy algorithm proceeds in the same way as Scrooge did. That is, it grabs data items in sequence, each time taking the one that is deemed “best” according to some criterion, without regard for the choices it has made before or will make in the future. 찰스 디킨스의 소설에 나오는 스크루지라는 인물을 예로들어 탐욕적인 방법과 연결시켜 설명하고 있다. 탐욕적인 방법은 과거나 미래를 고려하지 않고, 현재의 그 순간에서 최선을 결정한다는 점에서 스크루지의 방법과 같다고 할 수 있다. The Greedy ApproachLike dynamic programming, greedy algorithms are often used to solve optimization problems. However, the greedy approach is more straightforward. In dynamic programming, a recursive property is used to divide an instance into smaller instances. In the greedy approach, there is no division into smaller instances. A greedy algorithm arrives at a solution by making a sequence of choices, each of which simply looks the best at the moment. That is, each choice is locally optimal. The hope is that a globally optimal solution will be obtained, but this is not always the case. For a given algorithm, we must determine whether the solution is always optimal. A selection procedure chooses the next item to add to the set. The selection is performed according to a greedy criterion that satisfies some locally optimal consideration at the time. A feasibility check determines if the new set is feasible by checking whether it is possible to complete this set in such a way as to give a solution to the instance. A solution check determines whether the new set constitutes a solution to the instance. 탐욕 알고리즘은 동적계획법과 마찬가지로 종종 최적화 문제를 해결하는데 사용된다. 이 방법은 결정을 해야 할 때마다 그 순간에 가장 좋다고 생되는 것을 해답으로 선택함으로써 최종적인 해답에 도달한다. 그 순간의 선택은 그 당시에는 최적이다 (locally optimal). 하지만 최적이라고 생각했던 해답들을 모아 최종적인 해답을 만들었다고 해서, 그 해답이 궁극적으로 최적이라는 보장은 없다(globally optimal). 따라서 탐욕 알고리즘이 항상 최적의 해답을 주는지를 반드시 검증해야 한다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Greedy Approach","slug":"Algorithms/Greedy-Approach","permalink":"http://melomance.github.io/categories/Algorithms/Greedy-Approach/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","permalink":"http://melomance.github.io/tags/탐욕알고리즘/"}]},{"title":"Optimal Binary Search Trees(최적이진탐색트리)","slug":"[AG][DP] Optm Binsearch Tree","date":"2011-01-14T13:03:00.000Z","updated":"2019-05-19T09:01:33.358Z","comments":true,"path":"2011/01/14/[AG][DP] Optm Binsearch Tree/","link":"","permalink":"http://melomance.github.io/2011/01/14/[AG][DP] Optm Binsearch Tree/","excerpt":"","text":"Our goal is to organize the keys in a binary search tree so that the average time it takes to locate a key is minimized. In general, we cannot find an optimal binary search tree by considering all binary search trees because the number of such tree is at least exponential in n. 최적이진탐색트리 알고리즘의 목적은 Key를 찾는데 걸리는 평균시간이 최소화되도록 이진탐색트리의 Key를 구성하는 것이다. Example Shows the five different trees when n = 3. The actual values of the keys are not important. The only requirement is that they be ordered. $p_i$ is the probability that $Key_i$ is the search key. If $p_1$ = 0.7 ($Key_1$ 찾을 확률), $p_2$ = 0.2 ($Key_2$ 찾을 확률), and $p_3$ = 0.1 ($Key_3$ 찾을 확률), the average search times for the below trees are: 트리번호 평균검색시간 평균검색시간 설명 1 3(0.7) ＋ 2(0.2) ＋ 1(0.1) = 2.6 Key1을 세번 비교 후 찾을 확률 ＋ Key2를 두번 비교 후 찾을 확률 ＋ Key3를 한번 비교 후 찾을 확률. 2 2(0.7) ＋ 3(0.2) ＋ 1(0.1) = 2.1 … 3 2(0.7) ＋ 1(0.2) ＋ 2(0.1) = 1.8 Key1을 두번 비교 후 찾을 확률 ＋ Key2를 한번 비교 후 찾을 확률 ＋ Key3를 두번 비교 후 찾을 확률. 4 1(0.7) ＋ 3(0.2) ＋ 2(0.1) = 1.5 … 5 1(0.7) ＋ 2(0.2) ＋ 3(0.1) = 1.4 Key1을 한번 비교 후 찾을 확률 ＋ Key2를 두번 비교 후 찾을 확률 ＋ Key3를 세번 비교 후 찾을 확률. The fifth tree is optimal. $Key_1, Key_2, Key_3$로 구성된 트리 자료구조에서 사용자가 $Key_1$ 값을 검색하러 올 확률이 70%, $Key_2$ 값은 20%, $Key_3$ 값은 10%라고 하자. (이진탐색트리 특성에 따라, $Key_1 \\le Key_2 \\le Key_3$) 3개의 $Key$값으로 이진탐색트리를 구성하는 방법은 총 5가지이며, 이 중에서 5번 모양이 평균검색시간을 고려했을 때 최적화된 이진탐색트리이다. 트리의 균형이 깨지더라도 $Key_1$을 찾을 확률이 높으므로 $Key_1$을 루트로 둔다. Example Suppose we have three keys and the probabilities in this above Example. To determine A[2][3] we must consider the two trees. For those two trees we have the following: 트리번호 평균검색시간 평균검색시간 설명 1 1(p2) ＋ 2(p3) = 1(0.2) ＋ 2(0.1) = 0.4 Key2를 한번 비교 후 찾을 확률 ＋ Key3를 두번 비교 후 찾을 확률. 2 2(p2) ＋ 1(p3) = 2(0.2) ＋ 1(0.1) = 0.5 Key2를 두번 비교 후 찾을 확률 ＋ Key3를 한번 비교 후 찾을 확률. The first tree is optimal, and A[2][3] = 0.4. A[2][3]이란 $Key_2$와 $Key_3$으로 구성된 이진탐색트리의 최적화된 평균검색시간이다. 최적화된 평균검색시간을 갖는 트리 구성을 하려면 위의 1번 트리처럼 $Key_2$를 루트에 놓아야 한다. Optimal Binary Search Tree Algorithm Algorithm DesignThe average search time for tree k is given by, $$\\underbrace{A[1][k-1]} + \\underbrace{p_1 + \\cdots + p_{k-1}} + \\underbrace{p_k} + \\underbrace{A[k+1][n]} + \\underbrace{p_{k+1} + \\cdots + p_n}$$ $A[1][k-1]$ Average time in left subtree $p_1 + \\cdots + p_{k-1}$ Additional time comparing at root $p_k$ Average time searching for root $A[k+1][n]$ Average time in right subtree $p_{k+1} + \\cdots + p_n$ Additional time comparing at root which equals$$A[1][k-1] + A[k+1][n] + \\sum_{m=1}^np_m$$ Because one of the k trees must be optimal, the average search time for optimal tree is given by $$A[1][n] = minimum_{1 \\le k \\le n}(A[1][k-1] + A[k+1][n]) + \\sum_{m=1}^np_m,$$ $$\\begin{cases}A[i][j] = minimum_{i \\le k \\le j}(A[i][k-1] + A[k+1][j]) + \\sum_{m=i}^jp_m \\quad i &lt; j \\\\A[i][i] = p_i \\\\A[i][i-1] \\ \\text{and} \\ A[j+1][j] \\ \\text{are defined to be 0}.\\end{cases}$$ A[1][k-1]은 $Key_1, \\cdots, Key_{k-1}$로 구성된 왼쪽 부분트리의 최적화된 평균검색시간이다. A[k+1][n] 역시 마찬가지로 $Key_{k+1}, \\cdots, Key_n$으로 구성된 오른쪽 부분트리의 최적화된 평균검색시간을 뜻한다. 식이 복잡해 보일수도 있지만 사실 그렇지 않다. (왼쪽 부분트리에서의 평균검색시간) + (루트에서의 검색시간) + (오른쪽 부분트리에서의 평균검색시간)으로 이루어진 직관적인 수식이다. Pseudo Codevoid optsearchtree(int n, const float p[], float&amp; minavg, index R[][])&#123; index i, j, k, diagonal; float A[1...n+1][0...n]; for (i = 1; i &lt;= n; i++) &#123; A[i][i-1] = 0; A[i][i] = p[i]; R[i][i] = i; R[i][i-1] = 0; &#125; A[n][n+1] = 0; R[n+1][n] = 0; for (diagonal = 1; diagonal &lt;= n-1; diagonal++) &#123; for (i = 1; i &lt;= n-diagonal; i++) &#123; j = i + diagonal; A[i][j] = minimum(A[i][k-1] + A[k+1][j]) + (pi + ... + pj) R[i][j] = a value of k that gave the minimum; &#125; &#125; minavg = A[1][n];&#125; Source Code// File: optbintree.h#ifndef OPTBIN_TREE_H#define OPTBIN_TREE_H#include &lt;iomanip&gt; // Provides setw#include &lt;iostream&gt;namespace algorithms&#123; void optsearchtree(const int n, const float p[], float &amp;minavg, int **R); // Problem: Determine an optimal binary search tree for a set of keys, // each with a given pr of being the search key. // Inputs: n, the number of keys, and an array of real numbers p indexed // from 1 to n, where p[i] is the pr of searching for the ith key. // Outputs: A variable minavg, whose value is the average search time // for an optimal binary search tree; and a two-dimensional array R from // which an optimal tree can be constructed. R has its rows indexed from // 1 to n+1 and its columns indexed from 0 to n. R[i][j] is the index of // the key in the root of an optimal tree containing the ith through // the jth keys. float prsum(const float p[], const int i, const int j); // Postcondition: Calculate the sum of p from i to j template &lt;typename Item&gt; Item *get_vector_space(const int n) // Postcondition: Return the array containing n spaces &#123; Item *v = new Item[n]; --v; // offset the pointer for (int i = 1; i &lt;= n; ++i) v[i] = Item(); return v; &#125; template &lt;typename Item&gt; Item **get_matrix_space(const int m, const int n) // Postcondition: Return the array containing m*n spaces &#123; Item **a; a = new Item *[m]; --a; // Offset the pointer to get row index from 1 to m for (int i = 1; i &lt;= m; ++i) a[i] = new Item[n]; // Initialize the matrix for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = Item(); return a; &#125; template &lt;typename Item&gt; void release_vector_space(Item* d) &#123; delete (d); &#125; template &lt;typename Item&gt; void release_matrix_space(Item **d, int n) &#123; for (int i = 1; i &lt;= n; ++i) delete[](d[i] + 1); delete (d + 1); &#125;&#125; // namespace algorithms#endif // File: optbintree.cpp#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include &lt;climits&gt; // Provides INT_MAX#include \"optbintree.h\"namespace algorithms&#123; void optsearchtree(const int n, const float p[], float &amp;minavg, int **R) &#123; int i, j, k, diagonal; // Make sure that we have to allocate n+1 instead of n float **A = get_matrix_space&lt;float&gt;(n + 1, n + 1); for (i = 1; i &lt;= n; ++i) &#123; A[i][i - 1] = 0; A[i][i] = p[i]; R[i][i] = i; R[i][i - 1] = 0; &#125; A[n + 1][n] = 0; R[n + 1][n] = 0; for (diagonal = 1; diagonal &lt;= n - 1; ++diagonal) &#123; for (i = 1; i &lt;= n - diagonal; ++i) &#123; j = i + diagonal; float min = static_cast&lt;float&gt;(INT_MAX); // casting for (k = i; k &lt;= j; ++k) &#123; if ((A[i][k - 1] + A[k + 1][j]) &lt; min) &#123; A[i][j] = A[i][k - 1] + A[k + 1][j] + prsum(p, i, j); R[i][j] = k; // A value of k that gave the minimum min = A[i][k - 1] + A[k + 1][j]; // Update min value &#125; &#125; &#125; &#125; minavg = A[1][n]; &#125; float prsum(const float p[], const int i, const int j) &#123; float answer = float(); // Calculate the sum of pm from i to j for (int m = i; m &lt;= j; ++m) answer += p[m]; return answer; &#125;&#125; // namespace algorithms // File: optbintreetest.cpp#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include &lt;string&gt;#include \"binarytree.h\"#include \"optbintree.h\"using namespace std;using namespace data_structures;using namespace algorithms;int main( )&#123; const int MATRIX_SIZE = 6; // the number of keys string* Key; // an array Key containing the MATRIX_SIZE keys in order. // R is the index of the key in the root of an optimal tree containing // the ith through the jth keys. int** R; // Exercise 24 float* pr = get_vector_space&lt;float&gt;(MATRIX_SIZE); pr[1] = (float)0.05; pr[2] = (float)0.15; pr[3] = (float)0.05; pr[4] = (float)0.35; pr[5] = (float)0.05; pr[6] = (float)0.35; Key = get_vector_space&lt;string&gt;(MATRIX_SIZE); Key[1] = \"CASE\"; Key[2] = \"ELSE\"; Key[3] = \"END\"; Key[4] = \"IF\"; Key[5] = \"OF\"; Key[6] = \"THEN\"; // Make sure that we have to allocate MATRIX_SIZE+1 instead of MATRIX_SIZE R = get_matrix_space&lt;int&gt;(MATRIX_SIZE+1, MATRIX_SIZE+1); float minavg = float( ); // Initialize minavg optsearchtree(MATRIX_SIZE, pr, minavg, R); // Make an optimal binary tree binary_tree_node* root = tree(R, Key, 1, MATRIX_SIZE); // Print optimal binary tree cout &lt;&lt; \"The Optimal Binary Tree is..\" &lt;&lt; endl &lt;&lt; endl; print_bintree(root, 2); release_vector_space(pr); release_vector_space(Key); release_matrix_space(R, MATRIX_SIZE); return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation The instructions executed for each value of k. Input size n, the number of keys. Every-Case Time Complexity $T(n) = \\sum_{diagonal=1}^{n-1}[(n-diagonal) \\times (diagonal+1)] = \\frac{n(n-1)(n+4)}{6} \\in \\Theta(n^3)$ 루프구분 루프조건 수행 횟수 diagonal-loop 수행 횟수: 1 to n-1 n-1 i－loop 수행 횟수: 1 to n-diagonal n－diagonal k－loop 수행 횟수: i to j j － i ＋ 1 = (i ＋ diagonal) - i + 1 = diagonal + 1 ※ j = i ＋ diagonal Optimization Problem 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(optimal solution)을 찾아야 하는 문제를 최적화문제(optimization problem)라고 한다. 최적이진탐색트리 문제는 최적화문제에 속한다. Principle of Optimality 플로이드, 연쇄행렬곱셈과 마찬가지로 최적이진탐색트리의 부분 해는 최적 해를 구성하는 일부임을 알 수 있다. 따라서 최적이진탐색트리 역시 최적의 원칙을 만족하게 되며, 동적계획법을 사용하여 문제를 풀 수 있다. Dynamic Programming ExercisesCreate the optimal binary search tree for the following items, where the probability occurrence of each word is given in parentheses: CASE (0.05), ELSE (0.15), END (0.05), IF (0.35), OF (0.05), THEN (0.35). 다음은 책에 있는 연습문제를 알고리즘에 적용한 결과이다. 생성된 이진탐색트리를 출력할 때 재귀를 이용해서 출력했다. IF가 루트 ELSE는 IF의 왼쪽자식, TEHN이 IF의 오른쪽 자식이다. index 1 2 3 4 5 6 ___________________________________________ 1 │ 0.05 0.25 0.35 0.95 1.05 1.8 2 │ 0 0.15 0.25 0.8 0.9 1.65 3 │ 0 0 0.05 0.45 0.55 1.3 4 │ 0 0 0 0.35 0.45 1.2 5 │ 0 0 0 0 0.05 0.45 6 │ 0 0 0 0 0 0.35 7 │ 0 0 0 0 0 0index 1 2 3 4 5 6 ___________________________________________ 1 │ 1 2 2 4 4 4 2 │ 0 2 2 4 4 4 3 │ 0 0 3 4 4 4 4 │ 0 0 0 4 4 4 5 │ 0 0 0 0 5 6 6 │ 0 0 0 0 0 6 7 │ 0 0 0 0 0 0The Optimal Binary Tree is.. THEN OF IF END ELSE CASE","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"}]},{"title":"Chained Matrix Multiplication(연쇄행렬곱셈)","slug":"[AG][DP] Chained Mtrx Mult","date":"2011-01-13T13:03:00.000Z","updated":"2019-05-19T09:31:15.841Z","comments":true,"path":"2011/01/13/[AG][DP] Chained Mtrx Mult/","link":"","permalink":"http://melomance.github.io/2011/01/13/[AG][DP] Chained Mtrx Mult/","excerpt":"","text":"Consider the multiplication of the following four matrices. $$A \\quad\\times\\quad B \\quad\\times\\quad C \\quad\\times\\quad D \\\\(20\\times2) \\ (2\\times30) \\ (30\\times12) \\ (12\\times8)$$ A(B(CD)) (30×12×8) + ( 2×30× 8) + (20× 2× 8) = 3,680(AB)(CD) (20×2×30) + (30×12× 8) + (20×30× 8) = 8,880A((BC)D) (2×30×12) + ( 2×12× 8) + (20× 2× 8) = 1,232 // optimal order((AB)C)D (20×2×30) + (20×30×12) + (20×12× 8) = 10,320(A(BC))D (2×30×12) + (20× 2×12) + (20×12× 8) = 3,120 There are five different orders in which we can multiply four matrices, each possibly resulting in a different number of elementary multiplications. The third order is the optimal order for multiplying the four matrices. Our goal is to develop an algorithm that determines the optimal order for multiplying n matrices. The optimal order depends only on the dimension of the matrices. A, B, C, D라는 4개의 행렬에 대해 서로 다른 5가지 방법의 곱셈순서가 있으며, 이 중 세 번째 순서(A((BC)D))가 4개의 행렬을 곱할 때 최적의 순서이다. 연쇄행렬곱셈 알고리즘의 목적은 n개의 행렬을 곱할 때 최적의 순서를 찾는 것이다. Chained Matrix Multiplication AlgorithmAlgorithm DesignWe can obtain the following recursive property when multiplying n matrices. For 1 ≤ i ≤ j ≤ n, let $$\\begin{align}M[i][j] =&amp; minimum_{(i \\le k \\le j-1)}(M[i][k] + M[k+1][j] + d_{i-1}d_kd_j), \\text{ if } i &lt; j \\\\M[i][i] =&amp; 0\\end{align}$$ M[i][j]는 i＜ j 일 때 Ai 부터 Aj 까지의 행렬을 곱하는데 필요한 곱셈의 최소횟수를 뜻한다. M[i][i]의 값은 0이다. Example Suppose we have the following six matrices : $$A_1 \\quad\\times\\quad A_2 \\quad\\times\\quad A_3 \\quad\\times\\quad A_4 \\quad\\times\\quad A_5 \\quad \\times \\quad A_6\\\\(5 \\ \\times \\ 2) \\quad (2 \\ \\times \\ 3) \\quad (3 \\ \\times \\ 4) \\quad (4 \\ \\times \\ 6) \\quad (6 \\ \\times \\ 7) \\quad (7 \\ \\times \\ 8) \\\\(d_0 \\times d_1) \\ \\ \\ (d_1\\times d_2) \\ \\ \\ (d_2\\times d_3) \\ \\ \\ (d_3\\times d_4) \\ \\ \\ (d_4\\times d_5) \\ \\ \\ (d_5\\times d_6)$$ Compute diagonal 1:M[1][2] = minimum(M[1][k] + M[k+1][2] + d0dkd2) // (1 ≤ k ≤ 1) = M[1][1] + M[2][2] + d0d1d2 = 0 + 0 + 5 × 2 × 3 = 30. M[1][2]는 두 개의 행렬을 곱할 때의 연산횟수를 계산한 값이다. M[2][3], M[3][4], M[4][5], M[5][6] 값들 역시 같은 방법으로 계산해준다. Compute diagonal 2:M[1][3] = minimum(M[1][k] + M[k+1][3] + d0dkd3) // (1 ≤ k ≤ 2) = minimum(M[1][1] + M[2][3] + d0d1d3, // ( A1(A2A3) ) M[1][2] + M[3][3] + d0d2d3) // ( (A1A2)A3 ) = minimum(0 + 24 + 5 × 2 × 4, 30 + 0 + 5 × 3 × 4) = 64. M[1][3]은 A1 부터 A3 까지의 행렬을 곱하는데 필요한 최소횟수이다. 위에서 알 수 있듯이 3개의 행렬을 곱하는 경우의 수는 두 가지(A1(A2A3), (A1A2)A3)이며, 이 중 더 적은 연산을 수행하는 값이 M[1][3]이 된다. M[1][3]값을 계산하기 위해 앞서 구한 M[1][2], M[2][3] 값들이 이용됨을 알 수 있다. M[2][4], M[3][5], M[4][6] 값들 역시 같은 방법으로 계산해준다. Compute diagonal 3:M[1][4] = minimum(M[1][k] + M[k+1][4] + d0dkd4) // (1 ≤ k ≤ 3) = minimum(M[1][1] + M[2][4] + d0d1d4, M[1][2] + M[3][4] + d0d2d4, M[1][3] + M[4][4] + d0d3d4) = minimum(0 + 72 + 5 × 2 × 6, 30 + 72 + 5 × 3 × 6, 64 + 0 + 5 × 4 × 6) = 132. M[1][4]는 네 개의 행렬을 곱할 때의 연산횟수를 계산한 값이다. 앞서 구한 M[1][2], M[2][4], …, M[1][3] 등이 계산에 이용됨을 알 수 있다. 값을 재계산하지 않고 찾아서 재사용하는 것이 동적계획법의 특징이다. M[2][5] and M[3][6] 값들 역시 같은 방법으로 계산해주면 된다. Compute diagonal 4 and 5:The Optimal Order is.. (A1((((A2A3)A4)A5)A6)) = 348. diagonal 4와 5 둘다 위의 과정을 반복해주면 된다. 위의 예제의 경우 diagonal 5의 계산이 끝나면 최소한의 연쇄행렬곱셈의 결과값 M[1][6] = 348 을 구할 수 있다. 아래 그림을 참고하면 계산과정을 이해하는데 도움이 된다. Pseudo Codeint minmult(int n, const int d[ ], index p[ ][ ])&#123; index i, j, k , diagonal; int M[1...n][1...n]; for (i = 1; i &lt;= n; i++) M[i][i] = 0; for (diagonal = 1; diagonal &lt;= n-1; diagonal++) for (i = 1; i &lt;= n-diagonal; i++) &#123; j = i + diagonal; M[i][j] = minimum(M[i][k] + M[k+1][j] + d[i-1]*d[k]*d[j]); i &lt;= k &lt;= j-1 P[i][j] = a value of k that gave the minimum; &#125; return M[1][n];&#125; Source Code// File: minmult.h#ifndef CHAINED_MATRIX_MULTI_H#define CHAINED_MATRIX_MULTI_H#include &lt;iostream&gt;namespace algorithms&#123; int minmult(int n, const int *d, int **P); // Problem: Determining the minimum number of elementary multiplications // needed to multiply n matrices and an order that produces that minimum // number. // Inputs: the number of matrices n, and an array of integers d, indexed // from 0 to n, where d[i-1] * d[i] is the dimension of the ith matrix. // Outputs: minmult, the minimum number of elementary multiplications // need to multiply the n matrices; a two-dimensional array P from which // the optimal order can be obtained. P has its rows indexed from 1 // to n-1 and its columns indexed from 1 to n. P[i][j] is the point // where matrices i through j are split in an optimal order for // multiplying the matrices. void print_order(int i, int j, int **P); // Problem: Print the optimal order for multiplying n matrices. // Inputs: Positive integer n, and the array P produced by Algorithm 3.6. // P[i][j] is the point where matrices i through j are split in an optimal order // for multiplying those matrices. // Outputs: the optimal order for multiplying the matrices. template &lt;typename Item&gt; void print_matrix(Item **data, const int m, const int n); template &lt;typename Item&gt; Item **get_matrix_space(const int m, const int n) // Postcondition: Return the array containing m*n spaces &#123; Item **a; a = new Item *[m]; --a; // Offset the pointer to get row index from 1 to m for (int i = 1; i &lt;= m; ++i) &#123; a[i] = new Item[n]; --a[i]; &#125; // Initialize the matrix for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = Item(); return a; &#125; template &lt;typename Item&gt; void release_matrix_space(Item **d, int n) &#123; for (int i = 1; i &lt;= n; ++i) delete[](d[i] + 1); delete (d + 1); &#125;&#125; // namespace algorithms#endif // File: minmult.cpp#include &lt;iostream&gt;#include &lt;climits&gt; // Provides INT_MAX#include &lt;iomanip&gt; // Provides setw#include \"minmult.h\"using namespace std;namespace algorithms&#123; int minmult(int n, const int* d, int** P) &#123; int i, j, k, diagonal; int** M = get_matrix_space&lt;int&gt;(n, n); for (i = 1; i &lt;= n; ++i) M[i][i] = 0; for (diagonal = 1; diagonal &lt;= n-1; ++diagonal) &#123; for (i = 1; i &lt;= n-diagonal; ++i) &#123; j = i + diagonal; int minimum = INT_MAX; for (k = i; k &lt;= j-1; ++k) &#123; if ((M[i][k]+M[k+1][j] + d[i-1]*d[k]*d[j]) &lt; minimum) &#123; M[i][j] = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j]; minimum = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j]; P[i][j] = k; // a value of k that gave minimum &#125; &#125; &#125; &#125; print_matrix(M, n, n); return M[1][n]; &#125; void print_order(int i, int j, int** P) &#123; int k; if (i == j) cout &lt;&lt; \"A\" &lt;&lt; i; else &#123; k = P[i][j]; cout &lt;&lt; \"(\"; print_order(i, k, P); print_order(k+1, j, P); cout &lt;&lt; \")\"; &#125; &#125; template &lt;typename Item&gt; void print_matrix(Item **data, const int m, const int n) &#123; // Print matrix's index cout &lt;&lt; \"index\"; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; setw(7) &lt;&lt; i; cout &lt;&lt; endl &lt;&lt; \" ___________________________________________\" &lt;&lt; endl; // Print matrix's data for (int i = 1; i &lt;= m; ++i) &#123; cout &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \" |\"; for (int j = 1; j &lt;= n; ++j) cout &lt;&lt; setw(7) &lt;&lt; data[i][j]; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125;&#125; // namespace algorithms // File: minmulttest.cpp#include &lt;iostream&gt;#include \"minmult.h\"using namespace std;using namespace algorithms;int main( )&#123; const int NUM_OF_MATRICES = 5; // A1, A2, A3, A4, A5, A6 int* d; int** P; d = new int[NUM_OF_MATRICES]; // Do NOT need for offset d[0] = 10; d[1] = 4; d[2] = 5; d[3] = 20; d[4] = 2; d[5] = 50; P = get_matrix_space&lt;int&gt;(NUM_OF_MATRICES, NUM_OF_MATRICES); minmult(NUM_OF_MATRICES, d, P); // Minimum multiplications print_matrix(P, NUM_OF_MATRICES, NUM_OF_MATRICES); cout &lt;&lt; \"The Optimal Order is.. \"; print_order(1, NUM_OF_MATRICES, P); // Print optimal order cout &lt;&lt; endl; delete d; release_matrix_space(P, NUM_OF_MATRICES); return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation The instructions executed for each value of k. Input size n, the number of matrices to be multiplied. Every-Case Time Complexity $T(n) = \\sum_{diagonal=1}^{n-1}[(n-diagonal) \\times diagonal] = \\frac{n(n-1)(n+1)}{6} \\in \\Theta(n^3)$ 루프구분 루프조건 수행 횟수 diagonal-loop 수행 횟수: 1 to n-1 n-1 i－loop 수행 횟수: 1 to n-diagonal n－diagonal k－loop 수행 횟수: i to j-1 (j－1) － i ＋ 1 = (i ＋ diagonal - 1) - i + 1 = diagonal ※ j = i ＋ diagonal (참고) The bruth-force Time Complexity 2개의 행렬을 곱하는 방법의 수 AB t2 = 1 3개의 행렬을 곱하는 방법의 수 (AB)C, A(BC) t3 = 2 4개의 행렬을 곱하는 방법의 수 ((AB)C)D, (A(BC))D, A((BC)D), A(B(CD)), (AB)(CD) t4 = 5 … … … n개의 행렬을 곱하는 방법의 수 exponential-time(Θ(2^n)) tn &gt;= 2^(n-2) 무작정 방법으로 연쇄행렬곱셈 최적의 순서를 찾는다면 그 시간복잡도는 exponential-time이다. Optimization Problem 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(optimal solution)을 찾아야 하는 문제를 최적화문제(optimization problem)라고 한다. 연쇄행렬곱셈 문제는 최적화문제에 속한다. Principle of Optimality n개의 행렬을 곱하는 최적의 순서는 n개의 행렬 중 일부 부분집합에 속하는 행렬을 곱하는 최적의 순서를 항상 포함한다. 예를 들어, 6개의 행렬(A1 , A2 ,…, A6)을 곱할 때의 최적해가 A1 ((((A2 A3) A4) A5) A6)라면, 3개의 행렬(A2, A3, A4)을 곱하는 최적의 순서는 (A2 A3) A4이다. 따라서 최적의 원칙을 만족하게 되며, 동적계획법을 사용하여 문제를 풀 수 있다. Dynamic Programming ExercisesFind the optimal order, and its cost, for evaluating the product A1 × A2 × A3 × A4 × A5, where $$A_1 \\ \\ \\times \\ \\ A_2 \\ \\ \\times \\ \\ A_3 \\ \\ \\times \\ \\ A_4 \\ \\ \\times \\ \\ A_5 \\\\(10 \\times 4) (4 \\times 5) (5 \\times 20) (20 \\times 2) (2 \\times 50)$$ Show the final matrices M and P produced by Minimum Multiplications algorithm. index 1 2 3 4 5 _____________________________________ 1 | 0 200 1200 320 1320 2 | 0 0 400 240 640 3 | 0 0 0 200 700 4 | 0 0 0 0 2000 5 | 0 0 0 0 0index 1 2 3 4 5 _____________________________________ 1 | 0 1 1 1 4 2 | 0 0 2 2 4 3 | 0 0 0 3 4 4 | 0 0 0 0 4 5 | 0 0 0 0 0The Optimal Order is.. ((A1(A2(A3A4)))A5)","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"}]},{"title":"Principle of Optimality(최적의 원칙)","slug":"[AG][DP] Principle of Optimality","date":"2011-01-13T13:03:00.000Z","updated":"2018-06-03T06:07:29.017Z","comments":true,"path":"2011/01/13/[AG][DP] Principle of Optimality/","link":"","permalink":"http://melomance.github.io/2011/01/13/[AG][DP] Principle of Optimality/","excerpt":"","text":"The principle of optimality is said to apply in a problem if an optimal solution to an instance of a problem always contains optimal solutions to all substances. If the principle of optimality applies in a given problem, we can develop a recursive property that gives an optimal solution to an instance in terms of optimal solutions to subinstances. The important but subtle reason why we can then use dynamic programming to construct an optimal solution to an instance is that the optimal solutions to the subinstances can be any optimal solutions. 어떤 문제의 입력에 대한 최적 해가 그 입력을 나눈 부분에 대해서도 최적 해를 항상 포함하고 있으면, 그 문제는 최적의 원칙이 적용된다 라고 한다. 즉, 부분적인 최적 해가 전체 해안에 포함되어 있을때, 부분 해를 이용하여 최적 해를 찾을 수 있다는 뜻이다. 주어진 문제에 대해 최적의 원칙이 적용될 수 있어야 동적계획법으로 해결할 수 있다. 하지만 모든 최적화 문제를 동적 프로그래밍으로 해결할 수 있는 것은 아니다. Example In case of the Shortest Paths problem we showed that if $v_k$ is a vertex on an optial path from $v_i$ to $v_j$, then the subpaths from $v_i$ to $v_k$ and from $v_k$ to $v_j$ must also be optmimal. Therefore, the optimal solution to the instance contains optimal solutions to all subinstances, and the principle of optimality applies. 최단경로를 구하는 문제에서, $v_k$를 $v_i$에서 $v_j$로 가는 최적 경로 상의 정점이라고 하면, $v_i$에서 $v_k$로 가는 부분경로와 $v_k$에서 $v_j$로 가는 부분경로도 반드시 최적이어야 한다. 모든 경우에 대해 위와 같은 성질을 만족하면 최적의 원칙을 준수하게 되므로 동적계획법을 사용하여 알고리즘을 구축할 수 있다. (참고) 최적의 원칙이 적용되지 않는 예제Consider the Longest Paths problem of finding the longest simple paths from each vertex to all other vertices. In the below figure, the optimal (longest) simple path from $v_1$ to $v_4$ is [$v_1, v_3, v_2, v_4$]. However, the subpath [$v_1, v_3$] is not an optimal (longest) path from $v_1$ to $v_3$ because Length([$v_1, v_3$]) = 1 and Length([$v_1, v_2, v_3$]) = 4. Therefore, the principle of optimality does not apply. $v_1$에서 $v_4$로의 최장경로는 [$v_1, v_3, v_2, v_4$]=8가 된다. 하지만 이 경로의 부분 경로인 $v_1$에서 $v_3$으로의 최장경로는 [$v_1, v_3$]=1이 아니고, [$v_1, v_2, v_3$]=4이다. 따라서 최장경로 문제에서는 최적의 원칙이 적용되지 않는다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"}]},{"title":"Floyd's Algorithm for Shortest Paths(플로이드 알고리즘)","slug":"[AG][DP] Floyd","date":"2011-01-12T14:37:00.000Z","updated":"2019-05-19T09:09:29.416Z","comments":true,"path":"2011/01/12/[AG][DP] Floyd/","link":"","permalink":"http://melomance.github.io/2011/01/12/[AG][DP] Floyd/","excerpt":"","text":"A common problem encountered by air travelers is the determination of the shortest way to fly from one city to another when a direct flight does not exist. Next we develop an algorithm that solves this and similar problems. First, let’s informally review some graph theory. Graph TheoryTerminology vertex, node 정점 edge, arc 이음선 directed graph, digraph 방향 그래프 weight 가중치 simple path 단순경로 (같은 정점을 두 번 지나지 않음) path 경로 (두 정점사이에 edge가 있는 정점들의 나열) cycle 순환 (한 정점에서 다시 그 정점으로 돌아오는 경로) cyclic graph 순환 그래프 acyclic graph 비순환 그래프 weighted graph 가중치 포함 그래프 length 길이(weighted graph) the sum of weights on the path(unweighted graph) the number of edges on the path Weighted Grapha weighted graph containing n vertices by an array W where $$W[i][j] =\\begin{cases}\\text{weight on edge} &amp; \\text{if there is an edge from $v_i$ to $v_j$} \\\\\\infty &amp; \\text{if there is no edge from $v_i$ to $v_j$}\\\\0 &amp; i=j\\end{cases}$$ 플로이드 알고리즘은 인풋과 아웃풋으로 그래프를 사용하기 때문에 그래프 자료구조에 대한 이해가 필요하다. Floyd’s Algorithm for Shortest Paths using Dynamic Programming $W$ represents the graph in the above figure. $D$ contains the lengths of the shortest paths. $D^{(k)}[i][j]$ = length of a shortest path from $v_i$ to $v_j$ using only vertices in the set {$v_1, v_2, \\cdots, v_k$} as intermediate vertices. $W$는 그래프의 인접행렬을, $D$는 그래프 상 정점들 간의 최단경로 길이를 나타낸다. $D^{(k)}[i][j]$는 {$v_1, v_2 , …, v_k$}의 정점들 만을 통해서 $v_i$에서 $v_j$로 가는 최단경로의 길이이다. Algorithm Design Establish a recursive property (process) with which we can compute $D^{(k)}$ from $D^{(k-1)}$. $$\\begin{align} D^{(k)}[i][j] = minimum(&amp; D^{(k-1)}[i][j], &amp;&amp; \\text{Case 1} \\\\ &amp; D^{(k-1)}[i][k] + D^{(k-1)}[k][j]) &amp;&amp; \\text{Case 2}\\end{align}$$ Case 1 At least one shortest path from $v_i$ to $v_j$ using only vertices in the set {$v_1, v_2, \\cdots, v_k$} as intermediate vertices, does not use $v_k$. Case 2 All shortest paths from $v_i$ to $v_j$, using only vertices in the set {$v_1, v_2, \\cdots, v_k$} as intermediate vertices, do use $v_k$. Solve an instance of the problem in a bottom-up fashion by repeating the process (established in Step 1) for k =1 to n. $D^{(0)}[2][5]$는 중간 정점으로 아무것도 지나지 않고 $v_2$에서 $v_5$로 가는 최단경로의 길이이다. 위의 인접행렬에서 확인할 수 있듯이 그 값은 $\\infty$이다.$D^{(1)}[2][5]$는 $v_2$에서 $v_1$을 거쳐 $v_5$로 가는 최단경로의 길이를 나타내며 그 값은 14이다. ($v_2$ $\\rightarrow$ $v_1$ $\\rightarrow$ $v_5$) 그래프 상의 어떤 정점도 중간 정점으로 이용하지 않는 $D^{(0)}$은 $W$와 동일하다. 반면 그래프 상의 모든 정점을 중간 정점으로 이용하는 $D^{(n)}$이 구하고자 하는 최종해($D$)이다.($D^{(0)} = W, \\ D^{(n)} = D$)결국 정점들의 개수가 n개이면 $D^{(0)}, D^{(1)}, \\cdots, D^{(n)}$ 값을 계산해 나가고, $D = D^{(n)}$이 구하고자 하는 모든 정점들 사이의 최단 경로가 된다. Pseudo Codevoid floyd(const size_t n, const graph&amp; g, int** D, int** P);&#123; int i, j, k; D = W; for(k=1; k &lt;= n; k++) for(i=1; i &lt;= n; i++) for(j=1; j &lt;= n; j++) D[i][j] = minimum(D[i][j], D[i][k]+D[k][j]);&#125; Source Code#ifndef FLOYD_H#define FLOYD_H#include \"graph.h\" // Provides graphusing namespace data_structures;namespace algorithms&#123; void floyd(const int n, const graph g, int** D, int** P); // Problem: Compute shortest paths from each vertex in a weighted graph // to each of the other vertices. The weights are nonnegative numbers. // Inputs: A weighted, directed graph and n, the number of vertices // in the graph. The graph is represented by a two-dimensional array // edges, which has both its rows and columns indexed from 1 to n, // where edges[i][j] is the weight on the edge from the ith vertex // to the jth vertex. // Outputs: A two-dimensional array d, which has both its rows and // columns indexed from 1 to n, where d[i][j] is the length of a // shortest path from the ith vertex to the jth vertex. void path(int** P, int q, int r); // Problem: Print the intermediate vertices on a shortest path from one // vertex to another vertex in a weighted graph. // Inputs: the array P produced by floyd, and two indices, q and r, of // vertices in the graph that is the input to floyd. // P[i][j] = highest index of an intermediate vertex on the shortest path // from vi to vj, if at least one intermediate vertex exists. // 0, if no intermediate vertex exists. // Outputs: the intermediate vertex exists. void display_graph(const graph g); void print_matrix(int** data, const int m, const int n); template &lt;typename Item&gt; Item** get_matrix_space(const int m, const int n) // Postcondition: Return the array containing m*n spaces &#123; Item** a; a = new Item*[m]; --a; // Offset the pointer to get row index from 1 to m for (int i = 1; i &lt;= m; ++i) &#123; a[i] = new Item[n]; --a[i]; &#125; // Initialize the matrix for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = Item( ); return a; &#125; template &lt;typename Item&gt; void release_matrix_space(Item** d, int n) &#123; for (int i = 1; i &lt;= n; ++i) delete [ ] (d[i] + 1); delete (d+1); &#125;&#125;#endif // File: floyd.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include \"floyd.h\"using namespace std;namespace algorithms&#123; void floyd(const int n, const graph g, int **D, int **P) &#123; int i, j, k; for (i = 1; i &lt;= g.get_size(); ++i) for (j = 1; j &lt;= g.get_size(); ++j) &#123; D[i][j] = g.get_edge(i, j); P[i][j] = 0; &#125; for (k = 1; k &lt;= n; ++k) for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= n; ++j) &#123; if (D[i][k] + D[k][j] &lt; D[i][j]) &#123; P[i][j] = k; D[i][j] = std::min(D[i][j], D[i][k] + D[k][j]); &#125; &#125; &#125; void path(int **P, int q, int r) &#123; if (P[q][r] != 0) &#123; path(P, q, P[q][r]); cout &lt;&lt; \"V\" &lt;&lt; P[q][r] &lt;&lt; \" \"; path(P, P[q][r], r); &#125; &#125; void print_matrix(int** data, const int m, const int n) &#123; // Print matrix's index cout &lt;&lt;\"index\"; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; setw(7) &lt;&lt; i; cout &lt;&lt; endl &lt;&lt; \" ______________________________________________\" &lt;&lt; endl; // Print matrix's data for (int i = 1; i &lt;= m; ++i) &#123; cout &lt;&lt; \" \" &lt;&lt; i &lt;&lt;\" |\"; for (int j = 1; j &lt;= n; ++j) cout &lt;&lt; setw(7) &lt;&lt; data[i][j]; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125;&#125; // namespace algorithms // File: floydtest.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS#include \"graph.h\" // Provides graph#include \"floyd.h\" // Provides Floyd's algorithmusing namespace std;using namespace data_structures;using namespace algorithms;int main( )&#123; graph exercise(7); exercise.set_vertex(\"V1\"); exercise.set_vertex(\"V2\"); exercise.set_vertex(\"V3\"); exercise.set_vertex(\"V4\"); exercise.set_vertex(\"V5\"); exercise.set_vertex(\"V6\"); exercise.set_vertex(\"V7\"); exercise.set_edge(1, 2, 4); exercise.set_edge(1, 6, 10); exercise.set_edge(2, 1, 3); exercise.set_edge(2, 4, 18); exercise.set_edge(3, 2, 6); exercise.set_edge(4, 2, 5); exercise.set_edge(4, 3, 15); exercise.set_edge(4, 5, 2); exercise.set_edge(4, 6, 19); exercise.set_edge(4, 7, 5); exercise.set_edge(5, 4, 1); exercise.set_edge(5, 3, 12); exercise.set_edge(6, 7, 10); exercise.set_edge(7, 4, 8); int** distance = get_matrix_space&lt;int&gt;(7, 7); int** inter = get_matrix_space&lt;int&gt;(7, 7); // Algorithms 3.3 in page 102. floyd(exercise.get_size( ), exercise, distance, inter); cout &lt;&lt; endl &lt;&lt; \"&lt;matrix D - the lengths of the shortest paths&gt;\" &lt;&lt; endl; print_matrix(distance, 7, 7); cout &lt;&lt; endl &lt;&lt; \"&lt;matrix P - the highest indices of the intermediate vertices\" &lt;&lt; \"on the shortest paths&gt;\" &lt;&lt; endl; print_matrix(inter, 7, 7); release_matrix_space&lt;int&gt;(distance, 7); return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation The instruction in the for-j loop. Input size n, the number of vertices in the graph. We have a loop within a loop within a loop, with n passes through each loop. Every-Case Time Complexity $T(n) = n \\times n \\times n \\in \\Theta (n^3)$ Optimization ProblemThe Shortest Paths problem is an optimization problem. There can be more than one candidate solution to an instance of an optimization problem. Each candidate solution has a value associated with it, and a solution to the instance is any candidate solution that has an optimal value. A candidate solution is a path from one vertex to another, the value is the length of the path, and the optimal value is the minimum of these lengths. 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(optimal solution)을 찾아야 하는 문제를 최적화문제(optimization problem)라고 한다. 최단경로 찾기 문제는 최적화문제에 속한다. Principle of OptimalityIn case of the Shortest Paths problem we showed that if $v_k$ is a vertex on an optial path from $v_i$ to $v_j$, then the subpaths from $v_i$ to $v_k$ and from $v_k$ to $v_j$ must also be optmimal. Therefore, the optimal solution to the instance contains optimal solutions to all subinstances, and the principle of optimality applies. 최단경로를 구하는 문제에서, $v_k$를 $v_i$에서 $v_j$로 가는 최적 경로 상의 정점이라고 하면, $v_i$에서 $v_k$로 가는 부분경로와 $v_k$에서 $v_j$로 가는 부분경로도 반드시 최적이어야 한다. 이렇게 되면 최적의 원칙을 준수하게 되므로 동적계획법을 사용하여 이 문제를 풀 수 있다. Dynamic Programming ExercisesUse Floyd’s algorithm for Shortest Paths problem to construct the matrix D, which contains the lengths of the shortest paths, and the matrix P, which contains the highest indices of the intermediate vertices on the shortest paths, for the following graph. /* adjacency matrix for the above graph */index 1 2 3 4 5 6 7 __________________________________________________ 1 │ 0 4 ∞ ∞ ∞ 10 ∞ 2 │ 3 0 ∞ 18 ∞ ∞ ∞ 3 │ ∞ 6 0 ∞ ∞ ∞ ∞ 4 │ ∞ 5 15 0 2 19 5 5 │ ∞ ∞ 12 1 0 ∞ ∞ 6 │ ∞ ∞ ∞ ∞ ∞ 0 10 7 │ ∞ ∞ ∞ 8 ∞ ∞ 0 /* matrix D, which contains the lengths of the shortest paths */index 1 2 3 4 5 6 7 __________________________________________________ 1 │ 0 4 36 22 24 10 20 2 │ 3 0 32 18 20 13 23 3 │ 9 6 0 24 26 19 29 4 │ 8 5 14 0 2 18 5 5 │ 9 6 12 1 0 19 6 6 │ 26 23 32 18 20 0 10 7 │ 16 13 22 8 10 26 0/* matrix P, which contains the highest indices of the intermediate vertices on the shortest paths */index 1 2 3 4 5 6 7 __________________________________________________ 1 │ 0 0 5 2 4 0 6 2 │ 0 0 5 0 4 1 4 3 │ 2 0 0 2 4 2 4 4 │ 2 0 5 0 0 2 0 5 │ 4 4 0 0 0 4 4 6 │ 7 7 7 7 7 0 0 7 │ 4 4 5 0 4 4 0","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"},{"name":"최단경로탐색","slug":"최단경로탐색","permalink":"http://melomance.github.io/tags/최단경로탐색/"}]},{"title":"Binomial Coefficient(이항계수)","slug":"[AG][DP] Bincoeff","date":"2011-01-11T13:12:28.000Z","updated":"2019-05-19T08:53:57.328Z","comments":true,"path":"2011/01/11/[AG][DP] Bincoeff/","link":"","permalink":"http://melomance.github.io/2011/01/11/[AG][DP] Bincoeff/","excerpt":"","text":"$$\\begin{align}{n \\choose k} &amp;= \\frac{n!}{k!(n-k)!} \\quad for \\ 0 \\leq k \\leq n&amp;. \\\\{n \\choose k} &amp;=\\begin{cases} {n-1 \\choose k-1} + {n-1 \\choose k} &amp;\\text{0 &lt; $k$ &lt; $n$} \\\\ 1 &amp; \\text{$k$=0 or $k$=$n$}\\end{cases}\\end{align}$$ Binomial Coefficient Pseudocode using Divide-and-Conquerint bincoeff(int n, int k)// Problem: Compute the binomial coefficient.// Inputs: nonnegative integers n and k, where k &lt;= n.// Outputs: the binomial coefficient nCk&#123; if (k == 0 || n == k) return 1; else return bincoeff(n-1, k-1) + bincoeff(n-1, k);&#125; 이항계수를 분할정복법으로 구현하기는 간단하지만 효율적이지는 않다. bincoeff(n-1, k-1)과 bincoeff(n-1, k)는 모두 bincoeff(n-2, k-1)의 결과가 필요하고 이 값은 해당 알고리즘에서 중복 계산되므로 알고리즘의 효율이 떨어진다. 분할정복법은 나눠진 문제들 간에 서로 연관성이 없는 문제를 해결하는데 적합함을 상기하자. Binomial Coefficient Using Dynamic ProgrammingAlgorithm Design Establish a recursive property. B[i][j] will contain $ _iC_j$ $$B[i][j] =\\begin{cases}B[i-1][j-1] + B[i-1][j], &amp; \\text{0 &lt; $j$ &lt; $i$} \\\\1, &amp; \\text{$j$ = 0 or $j$ = $i$}.\\end{cases}$$ Solve an instance of the problem in a bottom-up fashion by computing the rows in B in sequence starting with the first row. $ _nC_k$를 구하기 위해 B[0][0]부터 시작해서 위에서 아래로 재귀관계식을 적용해 배월을 채워나간다. 결국 최종해는 B[n][k]에 저장된다. Compute row 0:B[0][0] = 1 Compute row 1:B[1][0] = 1B[1][1] = 1 Compute row 2:B[2][0] = 1B[2][1] = B[1][0] + B[1][1] = 1 + 1 = 2B[2][2] = 1 Compute row 3:B[3][0] = 1B[3][1] = B[2][0] + B[2][1] = 1 + 2 = 3B[3][2] = B[2][1] + B[2][2] = 2 + 1 = 3B[3][3] = 1 Compute row 4:B[4][0] = 1B[4][1] = B[3][0] + B[3][1] = 1 + 3 = 4B[4][2] = B[3][1] + B[3][2] = 3 + 3 = 6 Pseudo Codeint bincoeff2(int n, int k)&#123; index i, j; int B[0..n][0..k]; for (i = 0; i &lt;= n; ++i) for (j = 0; j &lt;= minimum(i,k); ++j) if (j == 0 || j == i) B[i][j] = 1; else B[i][j] = B[i-1][j-1] + B[i-1][j]; return B[n][k];&#125; Source Code// File: binomial2.h#ifndef BINCOEFF_H#define BINCOEFF_Hnamespace algorithms&#123; int binomial_coefficient(int** b, int n, int k); // Problem: Compute the binomial coefficient. // Input: nonnegative integers n and k, where k &lt;= n. // Output: the binomial coefficient (n, k).&#125; // namespace algorithms#endif // File: binomial2.cpp#include &lt;algorithm&gt; // Provides min#include \"binomial2.h\"namespace algorithms&#123; int binomial_coefficient(int** B, int n, int k) &#123; // Improvement to the algorithm would be // to take advantage of the fact that (n,k) = (n, n-k) // if ((n/2) &lt; k) // k = n - k; for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= std::min(i, k); ++j) &#123; if (j == 0 || j == i) B[i][j] = 1; else B[i][j] = B[i - 1][j - 1] + B[i - 1][j]; &#125; &#125; return B[n][k]; &#125;&#125; // namespace algorithms // File: bincoefftest.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS;#include \"binomial2.h\"using namespace std;using namespace algorithms;int** get_matrix_space(int m, int n);void release_matrix_space(int** b, int m);int main( )&#123; int** binomial; int n, k; cout &lt;&lt; \"Compute the binomial coefficient (n, k): \"; cin &gt;&gt; n &gt;&gt; k; binomial = get_matrix_space(n, k); cout &lt;&lt; \"The answer for (\" &lt;&lt; n &lt;&lt; \", \" &lt;&lt; k &lt;&lt; \") is \" &lt;&lt; binomial_coefficient(binomial, n, k) &lt;&lt; endl; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= k; ++j) &#123; if (binomial[i][j] != 0) cout &lt;&lt; setw(4) &lt;&lt; binomial[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; release_matrix_space(binomial, n); return EXIT_SUCCESS;&#125;int** get_matrix_space(int m, int n)&#123; // Allocate the matrix // Please make sure that we need to allocate [m+1][n+1] int **data = new int *[m + 1]; for (int i = 0; i &lt; m + 1; ++i) data[i] = new int[n + 1]; // Initialize the matrix for (int i = 0; i &lt; m + 1; ++i) for (int j = 0; j &lt; n + 1; ++j) data[i][j] = 0; return data;&#125;void release_matrix_space(int** b, int m)&#123; for (int i = 0; i &lt; m + 1; ++i) delete[] b[i]; delete[] b;&#125; Time Complexity AnalysisBasic operation the number of passes through the for-j loop Input size n, k Every-Case Time Complexity $T(n) = \\frac{k(k+1)}{2} + (n-k+1)(k+1) = \\frac{(2n-k+2)(k+1)}{2} \\in \\Theta (nk)$ i 0 1 2 3 … k-1 k k+1 … n j-loop수행횟수 1 2 3 4 … k k+1 k+1 … k+1 $$1+2+3+4+ \\cdots + k + \\underbrace{(k+1) + (k+1) + \\cdots + (k+1)}_{\\text{$n$ - $k$ + 1 times}}$$ 동 알고리즘의 퍼포먼스를 향상시키고 싶다면 위의 소스코드 중 주석 처리한 부분을 참고하면 된다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"}]},{"title":"Dynamic Programming(동적계획법)","slug":"[AG][DP] Dynm Prgrming","date":"2011-01-11T11:38:00.000Z","updated":"2018-05-28T14:45:55.633Z","comments":true,"path":"2011/01/11/[AG][DP] Dynm Prgrming/","link":"","permalink":"http://melomance.github.io/2011/01/11/[AG][DP] Dynm Prgrming/","excerpt":"","text":"The divide and conquer algorithm works in problems such as Mergesort, where the smaller instances are unrelated. However, in problems such as nth Fibonacci term, the smaller instances are related. For example, to compute the fifth Fibonacci term we need to compute the fourth and third Fibonacci terms. However, the determinations of the fourth and third Fibonacci terms are related in that they both require the second Fibonacci term. Because the divide-and-conquer algorithm makes these two determinations independently, it ends up computing the second Fibonacci term more than once. 분할정복법으로 피보나치 수열을 계산하면 같은 항을 여러번 계산하는 결과를 초래하므로 비효율적인 알고리즘이 된다. 분할정복법은 합병정렬과 같이 분할된 부분들 사이에 서로 상관관계가 없는 문제를 해결하는데 적합한 방식임을 기억해야 한다. // nth Fibonacci Term using Divide-and-Conquerint fib(int n)&#123; if (n &lt;= 1) return n; else return fib(n-1) + fib(n-2);&#125;// 5th Fibonacci Term : fib(2)를 두 번 이상 계산하는 비효율 발생fib(5) = fib(4) + fib(3)fib(4) = fib(3) + fib(2) // fib(4)에서도 fib(2)를 독립적으로 계산fib(3) = fib(2) + fib(1) // fib(3)에서도 fib(2)를 독립적으로 계산... 피보나치 수열을 동적계획법 기법으로 해결하면 훨씬 더 효율적인 계산이 가능해진다. n번째 항의 값을 구할 때 이미 구해놓은 n-1번째 항과 n-2번째 항을 이용하기 때문이다. // nth Fibonacci Term using Dynamic Programmingint fibonacci(int n)&#123; int i; int f[n]; f[0] = 0; if (n &gt; 0) &#123; f[1] = 1; for (i = 2; i &lt;= n; ++i) f[i] = f[i-1] + f[i-2]; &#125; return f[n];&#125; The Dynamic Programming ApproachDynamic programming is similar to divide-and-conquer in that an instance of a problem is divided into smaller instances. However, in this approach we solve small instances first, store the results, and later, whenever we need a result, look it up instead of recomputing it. The terms “dynamic programming” comes from control theory, and in this sense “programming” means the use of an array (table) in which a solution is constructed. Establish a recursive property that gives the solution to an instance of the problem. Solve an instance of the problem in a bottom-up fashion by solving smaller instances first. Dynamic programming is a bottom-up approach. 동적계획법은 원래의 문제를 더 작은 문제로 분할한다는 점에서 분할정복법과 유사하다. 이 기법은 bottom-up 방식으로, 먼저 작은 문제들을 풀어 그 결과를 저장하고 나중에 결과가 필요할 때마다 값을 재계산하지 않고 찾아보며 최종 해에 도달하게 된다. 분할정복법의 top-down 방식과는 정반대되는 개념이다. “동적계획법(동적프로그래밍)”이라는 용어는 제어 이론에서 나온다.이 의미에서 “프로그래밍”은 솔루션이 구성되는 배열(테이블)의 사용을 의미한다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Dynamic Prgrming","slug":"Algorithms/Dynamic-Prgrming","permalink":"http://melomance.github.io/categories/Algorithms/Dynamic-Prgrming/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://melomance.github.io/tags/동적계획법/"}]},{"title":"When Not to Use Divide-and-Conquer(분할정복법 사용을 피해야 하는 경우)","slug":"[AG][DQ] When Not To Use Divd and Conqr","date":"2011-01-10T06:41:00.000Z","updated":"2018-06-04T14:21:33.307Z","comments":true,"path":"2011/01/10/[AG][DQ] When Not To Use Divd and Conqr/","link":"","permalink":"http://melomance.github.io/2011/01/10/[AG][DQ] When Not To Use Divd and Conqr/","excerpt":"","text":"If possible, we should avoid divide-and-conquer in the following two cases: An instance of size n is divided into or more instances each almost of size n. // n th Fibonacci Term (Recursive)fib(n) = fib(n－1) ＋ fib(n－2) // n &lt; 2n-3 크기 n인 문제가 분할과정에서 거의 각각 n 크기의 문제로 분할되는 경우 피보나찌 수열을 예로 들면, fib(n)을 구하기 위해 문제를 fib(n-1)과 fib(n-2)로 분할했지만 그렇게 함으로써 문제의 크기는 처음 가지고 있던 것보다 더 커지게 된다. (n &lt; 2n-3) An instance of size n is divided into almost n instances of size n/c, where c is a constant. 크기 n인 문제가 n/c(c는 상수)의 크기로 거의 n개로 분할되는 경우 The first partitioning leads to an exponential-time algorithm, where the second leads to a n^Θ(logn) algorithm. 첫번째 경우는 exponential-time 알고리즘으로 이어지고, 두번째는 n^Θ(logn) 알고리즘의 결과를 초래한다. 결론적으로 상기 두 가지 경우처럼 분할했을 때의 크기가 처음 가지고 있던 문제의 크기 보다 커지거나 혹은 비슷하다면 분할정복법 사용을 지양해야 한다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Divide and Conquer","slug":"Algorithms/Divide-and-Conquer","permalink":"http://melomance.github.io/categories/Algorithms/Divide-and-Conquer/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분할정복법","slug":"분할정복법","permalink":"http://melomance.github.io/tags/분할정복법/"}]},{"title":"Quicksort(퀵정렬)","slug":"[AG][DQ] Quicksort","date":"2011-01-08T14:06:00.000Z","updated":"2019-05-18T14:11:07.022Z","comments":true,"path":"2011/01/08/[AG][DQ] Quicksort/","link":"","permalink":"http://melomance.github.io/2011/01/08/[AG][DQ] Quicksort/","excerpt":"","text":"Quicksort is similar to Mergesort in that the sort is accomplished by dividing the array into two partitions and then sorting each partition recursively. However, in quicksort, the array is partitioned by placing all items smaller than some pivot item before that item and all items larger than the pivot item after it. The pivot item can be any item, and for convenience we will simply make it the first one. 퀵정렬은 선택된 피벗값을 기준으로 배열을 두 개의 파티션으로 나누고 재귀를 이용하여 각 파티션을 정렬한다는 점에서 합병정렬과 비슷하나, 정렬과정에서 추가적인 작업공간을 필요로 하지 않는다. 즉, 퀵정렬은 in-place sort이다. Example The steps done by a human when sorting with Quicksort. Quicksort AlgorithmAlgorithm Design Partition the array so that all items smaller than the pivot item are to the left of it and all items larger are to the right. Sort the subarrays. 선택된 피벗 값을 기준으로 피벗보다 작은 값들은 왼쪽에, 큰 값들은 오른쪽에 오도록 배열을 분할하고 각 부분배열을 정렬한다. Pseudo Codevoid quicksort(index low, index high)&#123; index pivotpoint; if (high &gt; low) &#123; partition(low, high, pivotpoint); quicksort(low, pivotpoint-1); quicksort(pivotpoint+1, high); &#125;&#125;void partition(index low, index high, index&amp; pivotpoint)&#123; index i, j; keytype pivotitem; pivotitem = S[low]; // Choose first item for pivotitem. j = low; for (i = low+1; i &lt;= high; i++) if (S[i] &lt; pivotitem) &#123; j++; exchange S[i] and S[j]; &#125; pivotpoint = j; exchange S[low] and S[pivotpoint]; // Put pivotitem at pivotpoint.&#125; Source Code// File: sorting.h#ifndef SORTING_H#define SORTING_Hnamespace algorithms&#123; void quicksort(int data[ ], int low, int high); // Problem: Sort n keys in nondecreasing order. // Inputs: positive integer n, array of keys S indexed from 1 to n. // Outputs: the array S containing the keys in nondecreasing order. void partition(int data[ ], int low, int high, int&amp; pivotpoint); // Problem: Partition the array S for Quicksort. // Inputs: two indices, low and high, and the subarray of S indexed // from low to high. // Outputs: pivotpoint, the pivot point for the subarray indexed // from low to high.&#125;#endif // File: sorting.cpp#include &lt;algorithm&gt; // Provides swap#include \"sorting.h\"namespace algorithms&#123; void quicksort(int data[ ], int low, int high) &#123; int pivotpoint; if (high &gt; low) &#123; partition(data, low, high, pivotpoint); quicksort(data, low, pivotpoint-1); // before the pivotpoint quicksort(data, pivotpoint+1, high); // after the pivotpoint &#125; &#125; void partition(int data[ ], int low, int high, int&amp; pivotpoint) &#123; int i, j; int pivotitem; pivotitem = data[low]; // Choose first item for pivotitem. j = low; for (i = low+1; i &lt;= high; ++i) &#123; if (data[i] &lt; pivotitem) &#123; ++j; std::swap(data[i], data[j]); &#125; &#125; pivotpoint = j; std::swap(data[low], data[pivotpoint]); // Put pivotitem at pivotpoint. &#125;&#125; // File: sorttest.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;ctime&gt;#include \"sorting.h\" // Provides sorting functions.using namespace std;using namespace algorithms;// PROTOTYPE of a function that will test one of the sorting functions:void testsort(void sorter(int data[ ], int start, int last), const char* file_name, const char* sorting_name);void open_for_read(ifstream&amp; f, const char filename[ ]);// Postcondition: The ifstream f has been opened for reading using the given// filename. If any errors occurred then an error message has been printed// and the program has been halted.bool is_more(istream&amp; source);// Precondition: input is an open istream.// Postcondition: The return value is true if input still has more data to// read; otherwise the return value is false.void process_read(ifstream&amp; f, int data[ ]);// Precondition: input is an open istream.// Postcondition: The values in inputfile are assigned to data array.int main(int argc, char* argv[ ])&#123; assert(argc == 2); testsort(quicksort, argv[1], \"quicksort\"); return EXIT_SUCCESS;&#125;void testsort(void sorter(int data[ ], int start, int last), const char* file_name, const char* sorting_name)&#123; const int ARRAY_SIZE = 100000; int data[ARRAY_SIZE]; ifstream infile; open_for_read(infile, file_name); process_read(infile, data); infile.close( ); clock_t start, end; cout &lt;&lt; \"Testing the \" &lt;&lt; sorting_name &lt;&lt; endl; start = clock( ); sorter(data, 0, ARRAY_SIZE-1); // Sort the numbers end = clock( ); // Check the sorting result. for (int i = 1; i &lt; ARRAY_SIZE; ++i) &#123; if (data[i-1] &gt; data[i]) exit(0); &#125; cout &lt;&lt; \"Sorting completed correctly.\" &lt;&lt; endl; double result = (double)(end-start) / CLOCKS_PER_SEC; cout &lt;&lt; sorting_name &lt;&lt; \"'s elpased time is : \"&lt;&lt; result &lt;&lt; \" sec.\" &lt;&lt; endl;&#125;void open_for_read(ifstream&amp; f, const char filename[ ])&#123; f.open(filename); if (f.fail( )) &#123; cerr &lt;&lt; \"Could not open input file.\" &lt;&lt; endl; exit(0); &#125;&#125;bool is_more(ifstream&amp; source)&#123; return (source &amp;&amp; source.peek( ) != EOF);&#125;void process_read(ifstream&amp; f, int data[ ])&#123; size_t index = 0; while (is_more(f)) &#123; assert(f); f &gt;&gt; data[index]; ++index; &#125;&#125; Time Complexity AnalysisBasic operation the comparison of S[i] with pivotitem in partition. Input size n, the number of items in the array S. Worst-Case Time Complexity $W(n) = \\frac{n(n-1)}{2} \\in \\Theta (n^2)$ Average-Case Time Complexity $A(n) \\approx 1.38(n+1)logn \\in \\Theta (nlogn)$ 시간복잡도가 최악인 경우, 퀵정렬의 비교횟수는 n^2(quadratic time)을 요구한다. 하지만 정렬하고자 하는 키값들이 무작위로 분산되어 있다면, 평균적으로 퀵정렬이 수행하는 비교횟수는 nlogn에 비례한다. 퀵정렬의 성능향상을 위해서는 중간값에 가까운 피벗을 선택해야 한다. 선택된 피벗이 중간값에 가까울수록 좌우 파티션이 균등하게 이루어져 더 빨리 정렬할 수 있다. 위의 예시처럼 첫번째 항목을 피벗으로 잡는건 효율적이라고 할 수 없다. 피벗값 선택시 랜덤하게 3~5개의 원소를 선택 한 후, 그 중에서 중간값을 취하는 방법도 있다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Divide and Conquer","slug":"Algorithms/Divide-and-Conquer","permalink":"http://melomance.github.io/categories/Algorithms/Divide-and-Conquer/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분할정복법","slug":"분할정복법","permalink":"http://melomance.github.io/tags/분할정복법/"}]},{"title":"Mergesort(합병정렬)","slug":"[AG][DQ] Mergesort","date":"2011-01-08T13:19:28.000Z","updated":"2019-05-18T14:04:44.506Z","comments":true,"path":"2011/01/08/[AG][DQ] Mergesort/","link":"","permalink":"http://melomance.github.io/2011/01/08/[AG][DQ] Mergesort/","excerpt":"","text":"A process related to sorting is merging. By two-way merging we mean combining two sorted arrays into one sorted array. By repeatedly applying the merging procedure, we sort an array. Example The steps done sorting with Mergesort Mergesort AlgorithmAlgorithm Design Divide the array into two subarrays each with n/2 items. Conquer(solve) each subarray by sorting it. Unless the array is sufficiently small, use recursion to do this. Combine the solutions to the subarrays by merging them into a single sorted array. Pseudo Codevoid mergesort2(index low, index high)&#123; index mid; if (low &lt; high) &#123; mid = (low + high) / 2; mergesort2(low, mid); mergesort2(mid+1, high); merge2(low, mid, high); &#125;&#125;void merge2(index low, index mid, index high)&#123; index i, j, k; keytype U[low..high]; // A local array needed for the merging i = low; j = mid + 1; k = low; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (S[i] &lt; S[j]) &#123; U[k] = S[i]; i++; &#125; else &#123; U[k] = S[j]; j++; &#125; k++; &#125; if (i &gt; mid) move S[j] through S[high] to U[k] through U[high]; else move S[i] through S[mid] to U[k] through U[high]; move U[low] through U[high] to S[low] through S[high];&#125; Source Code// File: sorting.h#ifndef SORTING_H#define SORTING_Hnamespace algorithms&#123; void mergesort2(int data[ ], int low, int high); // Problem: Sort n keys in nondecreasing sequence. // Inputs: positive integer n, array of key S indexed from 1 to n. // the array S containing the keys in nondecreasing order. void merge2(int data[ ], int low, int mid, int high); // Problem: Merge the two sorted subarrays of S created in Mergesort 2. // Inputs: indices low, mid, and high, and the subarray of S indexed // from low to high. The keys in array slots from low to mid are already // sorted in nondecreasing order, as are the keys in array slots from // mid +1 to high. // Outputs: the subarray of S indexed from low to high containing the // keys in nondecreasing order.&#125; #endif // File: sorting.cppnamespace algorithms&#123; void mergesort2(int data[ ], int low, int high) &#123; int mid; if (low &lt; high) &#123; mid = (low + high) / 2; mergesort2(data, low, mid); mergesort2(data, mid+1, high); merge2(data, low, mid, high); &#125; &#125; void merge2(int data[ ], int low, int mid, int high) &#123; int i, j, k; // A local array needed for the merging int* temp = new int[(high-low) + 1]; i = low; j = mid + 1; k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (data[i] &lt; data[j]) temp[k] = data[i++]; // Copy from first half else temp[k] = data[j++]; // Copy from second half k++; &#125; // Copy any remaining entries in the left and right subarrays. if (i &gt; mid) &#123; while (j &lt;= high) temp[k++] = data[j++]; &#125; else &#123; while (i &lt;= mid) temp[k++] = data[i++]; &#125; // Copy from temp back to the data array, and release temp's memory. i = low; for (k = 0; k &lt; (high-low) + 1 ; ++k) data[i++] = temp[k]; delete [ ] temp; &#125;&#125; // File: sorttest.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;ctime&gt;#include \"sorting.h\" // Provides sorting functions.using namespace std;using namespace algorithms;// PROTOTYPE of a function that will test one of the sorting functions:void testsort(void sorter(int data[ ], int start, int last), const char* file_name, const char* sorting_name);void open_for_read(ifstream&amp; f, const char filename[ ]);// Postcondition: The ifstream f has been opened for reading using the given// filename. If any errors occurred then an error message has been printed// and the program has been halted.bool is_more(istream&amp; source);// Precondition: input is an open istream.// Postcondition: The return value is true if input still has more data to// read; otherwise the return value is false.void process_read(ifstream&amp; f, int data[ ]);// Precondition: input is an open istream.// Postcondition: The values in inputfile are assigned to data array.int main(int argc, char* argv[ ])&#123; assert(argc == 2); testsort(mergesort2, argv[1], \"mergesort\"); return EXIT_SUCCESS;&#125;void testsort(void sorter(int data[ ], int start, int last), const char* file_name, const char* sorting_name)&#123; const int ARRAY_SIZE = 100000; int data[ARRAY_SIZE]; ifstream infile; open_for_read(infile, file_name); process_read(infile, data); infile.close( ); clock_t start, end; cout &lt;&lt; \"Testing the \" &lt;&lt; sorting_name &lt;&lt; endl; start = clock( ); sorter(data, 0, ARRAY_SIZE-1); // Sort the numbers end = clock( ); // Check the sorting result. for (int i = 1; i &lt; ARRAY_SIZE; ++i) &#123; if (data[i-1] &gt; data[i]) exit(0); &#125; cout &lt;&lt; \"Sorting completed correctly.\" &lt;&lt; endl; double result = (double)(end-start) / CLOCKS_PER_SEC; cout &lt;&lt; sorting_name &lt;&lt; \"'s elpased time is : \"&lt;&lt; result &lt;&lt; \" sec.\" &lt;&lt; endl;&#125;void open_for_read(ifstream&amp; f, const char filename[ ])&#123; f.open(filename); if (f.fail( )) &#123; cerr &lt;&lt; \"Could not open input file.\" &lt;&lt; endl; exit(0); &#125;&#125;bool is_more(ifstream&amp; source)&#123; return (source &amp;&amp; source.peek( ) != EOF);&#125;void process_read(ifstream&amp; f, int data[ ])&#123; size_t index = 0; while (is_more(f)) &#123; assert(f); f &gt;&gt; data[index]; ++index; &#125;&#125; Time Complexity AnalysisBasic operation the comparison that takes place in merge Input size n, the number of items in the array S Worst-Case Time Complexity $W(n) = W(h) + W(m) + h+m-1 = 2W(n/2) + n-1 \\in \\Theta (nlogn)$ W(h) = Time to sort U h = n/2 W(m) = Time to sort V m = n － h = n － n/2 = n/2 W(h) = Time to merge h ＋ m = n/2 ＋ n/2 = n W(n) = W(h) ＋ W(m) ＋ (h＋m－1) W(n/2) ＋ W(n/2) ＋ n－1 합병정렬은 퀵정렬과는 달리 정렬과정에서 추가적인 작업공간이 필요하다. 합병정렬의 장점은 시간복잡도가 최악인 경우의 비교횟수 마저도 O(nlogn)라는 점이다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Divide and Conquer","slug":"Algorithms/Divide-and-Conquer","permalink":"http://melomance.github.io/categories/Algorithms/Divide-and-Conquer/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분할정복법","slug":"분할정복법","permalink":"http://melomance.github.io/tags/분할정복법/"}]},{"title":"Binary Search(이진탐색)","slug":"[AG][DQ] Binsearch","date":"2011-01-07T10:47:00.000Z","updated":"2019-05-18T04:57:27.012Z","comments":true,"path":"2011/01/07/[AG][DQ] Binsearch/","link":"","permalink":"http://melomance.github.io/2011/01/07/[AG][DQ] Binsearch/","excerpt":"","text":"Binary Search locates a key x in a stored (nondecreasing order) array by first comparing x with the middle item of the array. If they are equal, the algorithm is done. If not, the array is divided into two subarrays, one containing all the items to the left of the middle item and the other containing all the items to the right. If x is smaller than the middle item, this procedure is then applied to the left subarray. Otherwise, it is applied to the right subarray. If they are equal, the algorithm is done. If not, the subarray is divided in two. This procedure is repeated until x is found or it is determined that x is not in the array. 이진탐색은 정렬된 배열에서 x를 찾기 위해 중간항목과 값을 비교한다. 만일 값이 일치하면 알고리즘은 종료되지만 그렇지 않은 경우, 해당 배열을 두 개의 부분배열로 나누고 x가 중간항목보다 작으면 왼쪽 부분배열에, 큰 경우 오른쪽 부분배열에 같은 비교절차를 적용한다. 일치하면 알고리즘은 완료되나 그렇지 않은 경우, x가 발견되거나 x가 배열에 없다고 결정될 때까지 상기 과정을 반복한다. Example The steps done when sorting with Binary Search. (x=18) Binary Search AlgorithmAlgorithm DesignIf x equals the middle item, quit. Otherwise: Divide the array into two subarrays about half as large. If x is smaller than the middle item, choose the left subarray. If x is larger than the middle item, choose the right subarray. Conquer(solve) the subarray by determining whether x is in that subarray. Unless the subarray is sufficiently small, use recursion to do this. Obtain the solution to the array from the solution to the subarray. Pseudo Code// Binary Search (Recursive)index binsearch(index low, index high)// Problem: Determine whether x is in the sorted array S of size n.// Inputs: positive integer n, sorted array of keys S indexed from// 1 to n, a key x.// Outputs: location, the location of x in S (0 if x is not in S).&#123; index mid; if (low &gt; high) // stopping case return 0; else &#123; mid = (low + high) / 2; if (x == S[mid]) return mid; else if (x &lt; S[mid]) return binsearch(low, mid - 1); // left subarray else return binsearch(mid + 1, high); // right subarray &#125;&#125; // Binary Search (Iteration)void binsearch(int n, const keytype S[ ], keytype x, index&amp; location)// Problem: Determine whether x is in the sorted array S of size n.// Inputs: positive integer n, sorted array of keys S indexed from// 1 to n, a key x.// Outputs: location, the location of x in S (0 if x is not in S).&#123; index low, high, mid; low = 1; high = n; location = 0; while (low &lt;= high &amp;&amp; location == 0) &#123; mid = (low + high) / 2; if (x == S[mid]) location = mid; else if (x &lt; S[mid]) high = mid - 1; else low = mid + 1; &#125;&#125; Source Code// File: binsearch.h#ifndef BINSEARCH_H#define BINSEARCH_Hnamespace algorihtms&#123; void binsearch1(const int S[ ], int first, int size, int target, bool&amp; found, int&amp; location); // Problem: Determine whether x is in the sorted array S of size n. // Inputs: positive integer n, sorted array of keys S indexed from // 1 to n, a key x. // Outputs: location, the location of x in S (0 if x is not in S). void binsearch2(const int S[ ], int size, int target, bool&amp; found, int&amp; location); // Problem: Determine whether x is in the sorted array S of size n. // Inputs: positive integer n, sorted array of keys S indexed from // 1 to n, a key x. // Outputs: location, the location of x in S (0 if x is not in S).&#125;#endif // File: binsearch.cpp// Binary Search (Iteration)# include \"binsearch.h\"namespace algorihtms&#123; // Binary Search (Recursive) void binsearch1(const int S[ ], int first, int size, int target, bool&amp; found, int&amp; location) &#123; int mid; if (size == 0) found = false; else &#123; mid = first + size/2; if (target == S[mid]) &#123; location = mid; found = true; &#125; else if (target &lt; S[mid]) // The target is less than S[mid], so search before the mid binsearch1(S, first, size/2, target, found, location); else // The target must be greater than S[mid], so search after the mid binsearch1(S, mid+1, (size-1)/2, target, found, location); &#125; &#125; // Binary Search (Iteration) void binsearch2(const int S[ ], int size, int target, bool&amp; found, int&amp; location) &#123; int low, high, mid; low = 0; high = size; location = 0; found = false; while (low &lt; high &amp;&amp; location == 0) &#123; mid = (low + high) / 2; if (target == S[mid]) &#123; location = mid; found = true; &#125; else if (target &lt; S[mid]) high = mid - 1; else low = mid + 1; &#125; &#125;&#125; // File: searchtest.cpp#include &lt;cstdlib&gt; // Provides EXIT_SUCCESS, int#include &lt;iostream&gt; // Provides cin, cout#include \"binsearch.h\"using namespace std;using namespace algorihtms;int main( )&#123; const int MANY = 13; int example[MANY] = &#123;10, 12, 13, 14, 18, 20, 25, 27, 30, 35, 40, 45, 47&#125;; int target = 0; int location = 0; bool found = false; target = 25; binsearch1(example, 0, MANY, target, found, location); if (found) cout &lt;&lt; target &lt;&lt; \" is at [\" &lt;&lt; location &lt;&lt; \"] in my array.\" &lt;&lt; endl; else cout &lt;&lt; target &lt;&lt; \" does not exists.\" &lt;&lt; endl; target = 18; binsearch2(example, MANY, target, found, location); if (found) cout &lt;&lt; target &lt;&lt; \" is at [\" &lt;&lt; location &lt;&lt; \"] in my array.\" &lt;&lt; endl; else cout &lt;&lt; target &lt;&lt; \" does not exists.\" &lt;&lt; endl; return EXIT_SUCCESS;&#125; Time Complexity AnalysisBasic operation the comparison of x with S[mid] Input size n, the number of items in the array Worst-Case Time Complexity $W(n) = logn + 1 \\in \\Theta (logn)$","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Divide and Conquer","slug":"Algorithms/Divide-and-Conquer","permalink":"http://melomance.github.io/categories/Algorithms/Divide-and-Conquer/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분할정복법","slug":"분할정복법","permalink":"http://melomance.github.io/tags/분할정복법/"}]},{"title":"Divide and Conquer(분할정복법)","slug":"[AG][DQ] Divd and Conqr","date":"2011-01-07T08:06:00.000Z","updated":"2018-05-28T14:45:36.936Z","comments":true,"path":"2011/01/07/[AG][DQ] Divd and Conqr/","link":"","permalink":"http://melomance.github.io/2011/01/07/[AG][DQ] Divd and Conqr/","excerpt":"","text":"Divide-and-conquer is patterned after the brilliant strategy employed by the French emperor Napoleon in the Battle of Austerlitz on December 2, 1805. A combined army of Austrians and Russians outnumbered Napoleon’s army by about 15,000 soldiers. The Austro-Russian army launched a massive attack against the French right flank. Anticipating their attack, Napoleon drove against their center and split their forces in two. Because the two smaller armies were individually no match for Napoleon, they each suffered heavy losses and were compelled to retreat. By dividing the large army into two smaller armies and individually conquering these two smaller armies, Napoleon was able to conquer the large army. 분할정복법은 Austerlitz 전투에서 나폴레옹이 고안한 전략을 모방한 것이다. 프랑스군은 오스트리아와 러시아 연합군에 비해 수적으로 열세였지만, 나폴레옹이 적 중앙을 돌파하여 적의 부대를 둘로 나누고 각개격파함으로써 전쟁에서 승리할 수 있었다. The Divide-and-Conquer ApproachIt divides an instance of a problem into two or more smaller instances. The smaller instances are usually instances of the original problem. If solutions to the smaller instances can be obtained readily, the solution to the original instance can be obtained by combining these solutions. If the smaller instances are still too large to be solved readily, they can be divided into still smaller instances. This process of dividing the instances continues until they are so small that a solution is readily obtainable. 1. Divide 문제를 해결하기 쉽도록 여러개의 작은 부분으로 나눈다. 이 작은 문제들은 원래 문제의 한 부분이다. 2. Conquer - Solve 나눈 작은 문제를 각각 해결한다. 만약 문제가 여전히 커서 쉽게 해결되지 않으면 더 작은 부분으로 나눈다. 3. Combine - Obtain the solution 필요하다면 해결된 해답을 모은다. The divide-and-conquer approach is a top-down approach. 분할정복법은 top-down 방식으로 문제를 접근/해결한다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Divide and Conquer","slug":"Algorithms/Divide-and-Conquer","permalink":"http://melomance.github.io/categories/Algorithms/Divide-and-Conquer/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"},{"name":"분할정복법","slug":"분할정복법","permalink":"http://melomance.github.io/tags/분할정복법/"}]},{"title":"Order(빅오, 오메가, 세타 표기법)","slug":"[AG][AF] Order","date":"2011-01-07T04:54:00.000Z","updated":"2018-07-01T12:50:29.637Z","comments":true,"path":"2011/01/07/[AG][AF] Order/","link":"","permalink":"http://melomance.github.io/2011/01/07/[AG][AF] Order/","excerpt":"","text":"big OFor a given complexity function f(n), O(f(n)) is the set of complexity functions g(n) for which there exists some positive real constant c and some nonnegative integer N such that for all n ≥ N, g(n) ≤ c $\\times$ f(n). 주어진 복잡도 함수 f(n)에 대해서 g(n) ∈ O(f(n))이면, n ≥ N인 모든 정수 n에 대해서 g(n) ≤ c $\\times$ f(n)이 성립하는 실수 c ＞ 0와 음이 아닌 정수 N이 존재한다. If g(n) ∈ O(f(n)), we say that g(n) is big O of f(n) 어떤함수 g(n)이 $O(n^2)$에 속한다는 말은, 그 함수는 궁극적으로 (어떤 임의의 N보다 큰 값에 대해서는) 어떤 2차함수 $c \\times n^2$ 보다는 작은 값을 가지게 된다는 것을 뜻한다. 따라서 g(n)은 어떤 2차함수 $c \\times n^2$보다는 궁극적으로 좋다고 말할 수 있다. g(n) ∈ O(f(n)) g(n): 분석된 결과 O(f(n)): 기껏해야 f(n)의 비율로 증가하는 함수 g는 f보다 빠르게 증가하지 않는다. (상수 비율의 차이는 무시) an asymptotic upper bound: 점근적 상한 big O는 x가 증가할수록 g(x)보다 항상 스케일이 큰 f(x)를 찾는 것이다. 어떤 알고리즘의 시간복잡도가 O(f(n))이라면, 입력크기 n에 대해서 이 알고리즘의 수행시간은 아무리 늦어도 f(n)은 된다. 다시 말하면 이 알고리즘의 수행시간은 f(n)보다 절대로 더 느릴수는 없다는 말이다. (f(n)이 상한) OmegaFor a given complexity function f(n), Ω(f(n)) is the set of complexity functions g(n) for which there exists some positive real constant c and some nonnegative integer N such that, for all n ≥ N, g(n) ≥ c $\\times$ f(n). 주어진 복잡도 함수 f(n)에 대해서 g(n) ∈ Ω(f(n))이면, n ≥ N인 모든 정수 n에 대해서 g(n) ≥ c $\\times$ f(n)이 성립하는 실수 c ＞ 0와 음이 아닌 정수 N이 존재한다. If g(n) ∈ Ω(f(n)), we say that g(n) is omega of f(n) 어떤 함수 g(n)이 $\\Omega(n^2)$에 속한다는 말은, 그 함수는 궁극에 가서는 (어떤 임의의 N값보다 큰 값에 대해서는) 어떤 2차 함수 $c \\times n^2$의 값보다는 큰 값을 가지게 된다는 것을 뜻한다. 따라서 함수 g(n)은 어떤 2차 함수 $c \\times n^2$보다는 궁극적으로 나쁘다고 할 수 있다. g(n) ∈ Ω(f(n)) g(n): 분석된 결과 Ω(f(n)): 적어도 f(n)의 비율로 증가하는 함수. O(f(n))과 대칭적 g는 f보다 느리게 증가하지 않는다. an asymptotic lower bound: 점근적 하한 omega는 x가 증가할수록 g(x)보다 항상 스케일이 작은 f(x)를 찾는 것이다. 어떤 알고리즘의 시간복잡도가 Ω(f(n))이라면, 입력의 크기 n에 대해서 이 알고리즘의 수행시간은 아무리 빨라도 f(n)밖에 되지 않는다. 다시 말하면 이 알고리즘의 수행시간은 f(n)보다 절대로 더 빠를 수는 없다는 말이다. (f(n)이 하한) ThetaFor a given complexity function f(n), Θ(f(n)) = O(f(n)) ∩ Ω(f(n)). This means that is the set of complexity functions g(n) for which there exists some positive real constants c and d and some nonnegative integer N such that, for all n ≥ N, c $\\times$ f(n) ≤ g(n) ≤ d $\\times$ f(n). Θ(f(n))은 다음을 만족하는 복잡도 함수 g(n)의 집합이다. n ≥ N인 모든 정수 n에 대해서 c $\\times$ f(n) ≤ g(n) ≤ d $\\times$ f(n)이 성립하는 실수 c &gt; 0와 d &gt; 0, 그리고 음이 아닌 정수 N이 존재한다. If g(n) ∈ Θ(f(n)), we say that g(n) is order of f(n)g(n) ∈ Θ(f(n)) Θ(f(n)) = O(f(n)) ∩ Ω(f(n)) g(n) : 분석된 결과 Θ(f(n)) : f(n)의 비율로 증가하는 함수 g는 f와 같은 정도로 증가한다. an asymptotic tight bound (O ∩ Ω) big O는 상한을, omega는 반대로 하한을 찾는 것이므로 실제 수행시간과는 괴리가 있을 수 있다. $$\\begin{align}(5n + 7) &amp;\\in O(n^2) \\\\(6n^6 + n^4) &amp;\\in Ω(n^2)\\end{align}$$ Theta는 big O와 omega의 교집합으로 시간복잡도를 분석하는데 있어 가장 정확한 표기법이다. Complexity Categories Θ(1): constant time입력크기에 상관없이 수행횟수가 일정하다. Θ(logn): logarithmic timeΘ(n): linear time수행시간이 입력 크기에 따라 선형적으로 증가함을 의미한다. Θ(nlogn): loglinear timeΘ(n^2): quadratic timeΘ(n^3): cubic timeΘ(2^n): exponential timeΘ(n!): factorial time","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Foundation","slug":"Algorithms/Foundation","permalink":"http://melomance.github.io/categories/Algorithms/Foundation/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"Analysis of Algorithms(알고리즘 분석)","slug":"[AG][AF] Analysis of Algorithms","date":"2011-01-06T11:19:00.000Z","updated":"2018-08-30T15:48:29.538Z","comments":true,"path":"2011/01/06/[AG][AF] Analysis of Algorithms/","link":"","permalink":"http://melomance.github.io/2011/01/06/[AG][AF] Analysis of Algorithms/","excerpt":"","text":"Time Complexity AnalysisWe analyze the algorithm’s efficiency by determining the number of times some basic operation is done as a function of the size of the input. In general, a time complexity analysis of an algorithm is the determination of how many times the basic operation is done for each value of the input size. 알고리즘의 복잡도 분석은 각 입력크기 대해 기본연산이 수행된 횟수를 결정하는 것이다. 이를 결정함으로써 알고리즘의 효율성 분석이 가능하다. T(n): Every-Case Time Complexity (모든 경우를 분석) T(n) is defined as the number of times the algorithm does the basic operation for an instance of size n. T(n) is called the every-case time complexity of the algorithm, and the determination of T(n) is called an every-case time complexity analysis. 모든 경우 분석. 입력크기에 종속되지만 입력값과는 무관하게 결과값은 항상 일정하다.e.g. Add array members $\\rightarrow$ T(n) = ne.g. Matrix multiplication $\\rightarrow$ T(n) = n^3 W(n): Worst-Case Time Complexity (최악의 경우를 분석) W(n) is defined as the maximum number of times the algorithm will ever do its basic operation for an input size of n. So W(n) is called the worst-case time complexity of the algorithm, and the determination of W(n) is called a worst-case time complexity analysis. 입력크기와 입력값 모두에 종속되며 단위연산 수행횟수가 최대인 경우 선택한다.e.g. Sequential Search $\\rightarrow$ W(n) = n A(n): Average-Case Time Complexity (평균의 경우를 분석) A(n) is defined as the average (expected value) of the number of times the algorithm does the basic operation for an input size of n. A(n) is called the average-case time complexity of the algorithm, and the determination of A(n) is called an average-case time complexity analysis. 입력크기와 입력값 모두에 종속되며 모든 입력에 대해서 단위연산이 수행되는 횟수가 평균이다. 일반적으로 worst-case보다 계산이 복잡하다. e.g. Sequential Search $\\rightarrow$ A(n) = (n + 1)/2 B(n): Best-Case Time Complexity (최선의 경우를 분석) B(n) is defined as the minimum number of times the algorithm will ever do its basic operation for an input size of n. So B(n) is called the best-case time complexity of the algorithm, and the determination of B(n) is called a best-case time complexity analysis. 입력크기와 입력값 모두에 종속되며 단위연산 수행횟수가 최소인 경우 선택한다. e.g. Sequential Search $\\rightarrow$ B(n) = 1","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Foundation","slug":"Algorithms/Foundation","permalink":"http://melomance.github.io/categories/Algorithms/Foundation/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]},{"title":"Algorithms(알고리즘)","slug":"[AG][AF] Algorithms","date":"2011-01-05T04:48:07.000Z","updated":"2018-06-17T12:55:18.923Z","comments":true,"path":"2011/01/05/[AG][AF] Algorithms/","link":"","permalink":"http://melomance.github.io/2011/01/05/[AG][AF] Algorithms/","excerpt":"","text":"DefinitionApplying a technique to a problem results in a step-by-step procedure for solving the problem. This step-by-step procedure is called an algorithm for the problem. 알고리즘이란 문제를 해결하기 위한 일련의 절차적인 과정이다. ObjectivesThe purpose of studying these techniques and their applications is so that, when confronted with a new problem, you have a repertoire of techniques to consider as possible ways to solve the problem. 알고리즘을 학습하는 목적은 새로운 문제에 직면했을 때, 그 문제를 해결할 수 있는 방법으로 고려해야 할 기술의 레퍼토리를 가지기 위함이다. In addition, we will be concerned not only with determining whether a problem can be solved using a given technique but also with analyzing how efficient the resulting algorithm is in terms of time and storage. 주어진 기술을 사용하여 문제해결의 가능여부를 결정해야 하며, 결과알고리즘이 시간 및 스토리지면에서 얼마나 효율적인지 분석해야 한다. The Importance of Developing Efficient AlgorithmsRegardless of how fast computers become or how cheap memory gets, efficiency will remain an important consideration. Next we show why this is so by comparing two algorithms for the same problem. 컴퓨터가 얼마나 빠른지 상관없이 알고리즘의 효율성은 중요한 고려사항이다. Array Size Number of Comparisons by Sequential Search Number of Comparisons by Binary Search 128 128 8 1,024 1,024 11 1,048,576 1,048,576 21 4,294,967,296 4,294,967,296 33 Binary Search does only 33 comparisons, whereas Sequential Search compares x with all 4 billion items. Even if the computer was capable of completing one pass through the while loop in a nanosecond, Sequential Search would take 4 seconds to determination almost instantaneously. This difference would be significant in an online application or if we needed to search for many items. Binary Search는 33번의 비교연산이면 충분하지만, Sequential Search는 40억개의 배열항목과 모두 비교해야 한다. 이 차이는 온라인 응용프로그램이나 많은 항목을 검색해야 할 때 중대한 사항이다. The Important Features of Algorithms Input(입력) Information or data that comes in. Output(출력) Information or data that goes out. Definiteness(명확성) Precisely defined.각 단계는 명확하게 정의되어야 한다. Correctness(정확성) Outputs correctly relate to inputs.입력 값의 각 집합에 대해서 정확한 출력 값을 만들어야 한다. Finiteness(유한성) Won’t take forever to describe or run. Effectiveness(효율성) Individual steps are all do-able.각 단계는 유한한 양의 시간에 수행되어야 한다. Generality(일반성) Works for many possible inputs.특정한 입력이 아닌 모든 가능한 입력에 대해서 동작하여야 한다.","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://melomance.github.io/categories/Algorithms/"},{"name":"Foundation","slug":"Algorithms/Foundation","permalink":"http://melomance.github.io/categories/Algorithms/Foundation/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"http://melomance.github.io/tags/알고리즘/"}]}]}